[{"categories":["CS"],"content":" 学习资源： 根据计算机自学指南的评论： MIT6.824: Distributed System 课程简介 所属大学：MIT 先修要求：计算机体系结构，并行编程 编程语言：Go 课程难度：🌟🌟🌟🌟🌟🌟 预计学时：200 小时 这门课和 MIT 6.S081 一样，出品自 MIT 大名鼎鼎的 PDOS 实验室，授课老师 Robert Morris 教授曾是一位顶尖黑客，世界上第一个蠕虫病毒 Morris 病毒就是出自他之手。 这门课每节课都会精读一篇分布式系统领域的经典论文，并由此传授分布式系统设计与实现的重要原则和关键技术。同时其课程 Project 也是以其难度之大而闻名遐迩，4 个编程作业循序渐进带你实现一个基于 Raft 共识算法的 KV-store 框架，让你在痛苦的 debug 中体会并行与分布式带来的随机性和复杂性。 所以我选了20版本的，因为21年之后就不是 Morris 教授了 MIT 6.824 Distributed Systems (Spring 2020) ","date":"2026-02-07","objectID":"/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/:0:0","tags":["CS"],"title":"分布式系统","uri":"/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"},{"categories":["CS"],"content":"分布式系统 ","date":"2026-02-07","objectID":"/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/:1:0","tags":["CS"],"title":"分布式系统","uri":"/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"},{"categories":["CS"],"content":"MapReduce 谷歌在 2004 年发表了一篇划时代的论文： MapReduce(论文原文以及翻译在这) 它的核心思想是设计了一种受限的分布式编程模型，将并行执行、任务调度、数据分发以及容灾恢复等系统复杂性，封装在了谷歌用 C++ 实现的 MapReduce 库中。在此之上，用户只需要实现其中确定性的 Map() 和 Reduce() 两个方法，即可在大规模集群上完成分布式计算。 1. 整体架构 首先我们来看看整体架构图： image-20260208192807885 具体操作流程(对应着图中的操作编号)： 输入数据切分与 worker 启动： 用户程序中运行一个 MapReduce 对象任务，MapReduce 库首先会将输入文件分割成 $M$ 块数据分片，这些数据分片由大小为 $64\\text{MB}$ 的小数据块组成(大小可以自定义)，然后在服务器集群中启动多个运行同一个 MapReduce 程序的 worker 进程。 Master 选举与任务调度： 这些启动的进程中，有一个会被宣布为 Master(主节点)，其余的节点都会由主节点进行调度。然后系统中有 $M$ 个 map task（任务） 和 $R$ 个 reduce task（任务） 需要调度。主节点每次都会去寻找空闲的 worker(节点)，然后给它调度一个 map 任务或者 reduce 任务。 Map 任务执行与中间结果生成： 被调度 map 任务的节点 $i$ 都会读取自己这个任务所相应的输入数据分片 $M_i$ (map 任务的数量正好等于划分好的输入数据块的数量)，然后从中解析出键值对，用它们作为传参来调用用户自己定义的 Map() 方法，并将调用产生的 intermediate key/value pairs(中间键值对)缓存在内存中。 中间结果分区与位置汇报： 被调度 map 任务的节点 $i$ 的缓存在内存中的中间键值对会被定期写入这个节点的磁盘中，并且由分区函数来将其划分为 $R$ 个区域（对应的就是 $R$ 个 reduce 任务）。这些区域的地址会被传给主节点，这样主节点就能将位置转发给相应的 reduce 任务的节点，让他进行下一步。 Shuffle 与排序： 当被调度 reduce 任务的节点 $j$ 收到了来自主节点转发的具体的位置信息，它就可以通过 RPC 来从所有被调度 map 任务的节点产生的第 $R_j$ 个分区中读出中间键值对，然后 copy 到本地。等到所有的中间键值对都拿到了之后，再按照 key 进行排序，用来将相同 key 的 value 放进同一个 list 中。 reduce 任务执行与结果输出： 被调度 reduce 任务的节点 $j$ 会将相同的 key 的 value 的 list，作为传参来调用用户自己定义的 Reduce()方法。方法的输出会先写入本地的临时文件，待当前 reduce 任务成功全部完成后，再以原子方式写入全局的 GFS 系统中，生成最终的输出文件 $j$。 任务完成与用户程序返回： 当所有的 map 任务和 reduce 任务全都执行完，主节点才会唤醒用户程序。这时候用户程序中运行的 MapReduce 对象任务也调用返回了。 任务执行结束后，我们会得到 $R$ 个输出文件。一般情况下，用户也不需要将这 $R$ 个文件合并，而是直接作为另一个 MapReduce 对象任务的输入。 2. 系统设计 我们来聊聊 MapReduce 库的底层设计哲学 2.1 编程模型 Map() 和 Reduce() 这两个编程原语来源于 Lisp 和需要其他函数式语言。 作者意识到：大部分的并行计算问题，我们其实都可以表达为一种 MapReduce 计算，即通过对输入数据通过 map函数 映射为一组中间的键值对，然后所有相同 key 的中间键值对由同一个 reduce 函数来完成处理。 比如我们来看看经典的词频统计问题是如何通过 MapReduce 计算来完成的： 首先我们输入的是一个纯 String 的大文件，我们会读取其中的内容，然后通过 map 将这种字节流映射为单词和它出现的次数，即 \u003cword, counts\u003e 这样的中间键值对。然后许多个不同的 map worker 计算得到的结果会被 reduce worker 进行规约，就是把同一个 word 的 counts 累加起来，得到的就是这个 word 最终的结果。 我们用伪代码描述就是下面这样： // key: document name, value: document contents void Map(String key, String value) { for each word w in value: Emit_Intermediate(w, \"1\"); } // key: a word, values: a list of counts void Reduce(String key, Iterator values) { int result = 0; for each v in values: result += ParseInt(v); Emit(AsString(result)); } 多么的简洁优雅，又很高效的一种编程范式。 我们的 Map() 和 Reduce() 方法，通常需要设计为一种 pure function 的形式，来符合函数式编程的思想。 这样的话，对于同样的输入来说，输出结果和数学函数一样，是恒定的，那么我们下面的容错机制，就可以设计为只对出问题的任务进行重新调度即可，无需影响太多的其他任务。（这是因为如果不是纯函数的话，我们的结果就和执行顺序有关，这样在实际集群环境下，出问题的话需要全部回滚，影响非常大） 当然出于一些特殊的目的，比如打印输出日志或者进行中间运算过程中的统计计算时，这时候可以考虑不适用纯函数。 2.2 容错机制 worker 故障 主节点通过心跳机制来判断是否有 worker 出现了故障。主节点定期会给每一个 worker 发送心跳确认包，如果一定时间没收到回复，并且重复尝试也无效，就会将其标记为故障。 该 worker 上正在进行的任务会被主节点标记为未执行，需要重新进行调度。 该 worker 上已经完成的任务，需要区分是 map 任务还是 reduce 任务： 对于已经完成的 reduce 任务，由于是完成后最终写入了全局的 GFS 文件系统中，所以机器挂了也能读到结果，所以不需要重新执行； 对于已经完成的 map 任务，由于中间键值对写入的是本地磁盘，所以会丢失导致无法通过 RPC 访问，因此需要全部重新执行 而对于重新执行的 map 任务来说，我们还需要考虑它对所有的 reduce 任务的影响。主节点会通知所有正在运行的 reduce 任务更新该 map 任务输出的中间键值对的位置信息。 对于还未读取该 map 任务输出的中间键值的 reduce 任务，就会去新的地址上去 RPC 访问； 已经成功读取完旧的 map 任务输出的中间键值的 reduce 任务，无需回滚或者重新执行，继续执行就好。 2.3 可扩展机制 分区函数 MapReduce 库提供了一个默认的分区函数： hash(key) mod R，这种分区方式在大部分情况下，都可以做到语义上将某些 key 放在同一个分区里，并且在很多时候分区也是比较均匀的。 但是有些时候，出于特殊的目的，我们需要按照其他的方式进行分区，就可以自己指定一个可选的分区函数，来完成这种要求。 合并函数 有的时候，Map 任务产生的中间键值对存在很多重复，而网络传输经常是性能的瓶颈，我们这时候可以通过指定一个可选的合并函数来完成中间键值对的部分合并。 比如我们上面的词频统计任务，Map 任务会产生大量的形如 \u003c\"hello\", \"1\"\u003e 的中间键值对，我们可以通过合并函数将它们先累加，这样可以极大的减少输出的中间键值对的文件大小。 参数设置 前面提到：我们将输入文件划分为 $M$ 块数据分片，中间键值对被划分为 $R$ 个区域。 那么 $M,R$ 在实际使用时如何选取比较合适呢？ 理想情况下: $M,R$ 应该 $»$ 集群中的服务器数量，这样才能做到动态的负载均衡，因为这时候每个机器就能执行许多不同的任务了。 但是 $M, R$ 也不能无限的大，因为主节点的调度需要 $O(M+R)$ 时间，然后还得记录 $O(M*R)$ 个状态在主节点的内存的数据结构中。以及 $R$ 还会影响最终输出的文件的数量，所以我们需要一个 trade off。 在实践中，我们一般将 $M$ 调整的比较大，然后 $R$ 一般是我们集群中的服务器的较小倍数。 在谷歌的论文中指出，它们一般设置 $M = 200,000$ $R = 5,000$ 来进行 MapReduce 计算，集群服务器数量为 $2,000$。 备份任务 实际开发过程中，我们会发现经常会出现长尾任务，这个任务会成为性能瓶颈。比如说一个机器可能大部分的资源被调度到其他的进程任务上，这时候留给我们执行 reduce 任务的资源就会锐减，时间就会大大延长。 这时候我们可以通过备份机制来缓解这个问题。当 MapReduce 操作接近完成时，主节点会调度剩余进行中的任务的备份来执行，这样只要有一个执行完了，我们就认为这个任务完成了。论文中测试发现，这个方法降低了大概 44%。 优化网络传输 网络带宽经常会成为系统的瓶颈，reduce 任务的远程 rpc 调用获取 map 任务产生的中间键值对，会产生大量的网络传输，因此如果想要优化，在","date":"2026-02-07","objectID":"/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/:1:1","tags":["CS"],"title":"分布式系统","uri":"/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"},{"categories":["CS"],"content":"GFS ","date":"2026-02-07","objectID":"/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/:1:2","tags":["CS"],"title":"分布式系统","uri":"/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"},{"categories":["AI"],"content":" 学习资源： LLM 视频： 李沐 动手学深度学习PyTorch版 MLsys 视频: ZOMI酱 AI系统系列视频 ","date":"2026-02-06","objectID":"/%E7%8E%B0%E4%BB%A3%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/:0:0","tags":["CS","AI"],"title":"现代人工智能","uri":"/%E7%8E%B0%E4%BB%A3%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"},{"categories":["AI"],"content":"LLM ","date":"2026-02-06","objectID":"/%E7%8E%B0%E4%BB%A3%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/:1:0","tags":["CS","AI"],"title":"现代人工智能","uri":"/%E7%8E%B0%E4%BB%A3%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"},{"categories":["AI"],"content":"MLsys 先看一篇入门好文： AI-Infra 总览：构建支撑大规模训练与推理基础设施平台 我们来看看一个完整的 AI Infra 的架构分别都有什么： ","date":"2026-02-06","objectID":"/%E7%8E%B0%E4%BB%A3%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/:2:0","tags":["CS","AI"],"title":"现代人工智能","uri":"/%E7%8E%B0%E4%BB%A3%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"},{"categories":["编程"],"content":"自我介绍 面试官您好，我叫xx，来自xxxx。本科毕业于电子科技大学软件工程专业，目前是中国科学技术大学软件学院的研二学生。 目前我在百度搜索架构部实习，主要负责基础检索召回服务相关的研发工作，重点参与了 DIDB中 Storelib底层能力建设，包括原地更新的全内存存储格式 设计、属性写入与反查链路优化，在实际业务场景中显著降低了内存占用并提升了稳定性。 此外，我参加了中科院组织的开源之夏活动，为 ApacheFory 开源项目实现了Go方向的编译时代码生成功能，替代运行时反射，并参与了类型分析、确定 性序列化和工具链建设，对系统设计和工程质量有了比较深入的理解。 我的技术栈以 Java、C++ 为主，对 Go 和 python 也有一定的了解，希望能在贵部门进一步学习和成长。谢谢。 Hello interviewer, My name is xx, and I’m from xx, xx Province. I did my undergraduate studies at the School of Software Engineering, University of Electronic Science and Technology of China, and I’m currently a first-year postgraduate student at the School of Software Engineering, University of Science and Technology of China. My main programming language is Java, and I also have some knowledge of C++. The projects I’ve worked on include a Snake Battle mini-game, a food exploration note project, and an intelligent medical AI agent project. According to the training program of our college, we are required to intern in enterprises for practical learning, so I can commit to a stable one-year internship. I would love to have the opportunity to learn in your department. Thank you. 简历中项目应该按照时间顺序，把最新的项目放在上面 ","date":"2026-01-25","objectID":"/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E6%8C%87%E5%8D%97/:1:0","tags":["编程"],"title":"程序员面试指南","uri":"/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E6%8C%87%E5%8D%97/"},{"categories":["编程"],"content":"项目介绍： ","date":"2026-01-25","objectID":"/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E6%8C%87%E5%8D%97/:2:0","tags":["编程"],"title":"程序员面试指南","uri":"/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E6%8C%87%E5%8D%97/"},{"categories":["编程"],"content":"Apache Fory 1. 项目信息 项目名称：为 Fury Go 实现编译时代码生成功能 方案描述： 总体目标： 在编译阶段生成面向 Fury 二进制协议的强类型序列化/反序列化代码，替代反射热路径，保证协议一致性、性能与类型安全。 实施思路（项目初期规划）： 类型发现：通过 go generate/CLI，扫描源码中带 //fory:generate 注解的结构体，形成待生成清单。 类型分析：获取结构体导出字段的编译期类型信息，识别基础类型、字符串、时间类（如时间戳与本地日期）、指针、结构体、切片与映射等；限定映射键为可比较的基础类型。 字段排序：按运行时反射路径的分组与规则生成稳定顺序（primitive/final/other/collection/map），组内再按类型与命名排序，确保与反射序列化的字段顺序一致。 结构哈希：将字段类型映射为协议类型标识并迭代计算结构哈希；对切片/映射使用统一标识；对指针命名结构体按规则取符号；避免零哈希。 代码生成：为每个目标类型生成一个序列化器及工厂，注册到运行时；生成强类型 WriteTyped/ReadTyped 与接口兼容方法；先读写结构哈希，再按排序顺序逐字段编码/解码。 写入规则：可引用类型（指针、结构体、字符串等）走带引用跟踪通道；非引用基本类型写非空标识后再写值；字符串写引用标识后写内容；时间写微秒，本地日期写天数并处理零日期标记；切片先写长度后遍历；映射先写长度、对键排序后写入键值对。 读取规则：对称恢复并校验结构哈希；字符串先读并丢弃引用标识；切片/映射按长度分配或置空；可引用类型走带引用跟踪通道读取并回填。 编译期守卫：生成结构体“快照”与编译期校验。当结构体变更但未重新生成时代码无法通过编译，并给出强制刷新与再生成指引。 开发体验：提供文件/包/类型多入口与 --force 选项；统一注解为 //fory:generate；在出现守卫冲突时输出可操作的提示信息。 兼容与迁移：生成路径与反射路径保持格式完全一致，可在同一工程内混用并互通，支持按文件/类型的增量引入。 测试与验证：构造包含基础类型、切片、映射、指针与嵌套的样例结构体；对比反射与生成路径的二进制；验证读写互通与确定性排序；覆盖零值与引用回路等边界。 风险与应对：针对键排序一致性、变长编码差异、可寻址性、零日期语义等风险，分别通过显式排序、遵循协议编码 API、可寻址写入与专门分支规避。 验收标准：能为 Struct/Slice/Map 生成零反射开销的序列化器；与反射路径二进制完全一致；守卫可检测失配并提供清晰恢复路径；可无侵入增量接入。 时间规划： 7 月：熟悉仓库与跨语言协议；学习 Java/Python 版本实现；设计 Go 端 AOT 方案与文件结构 8 月下：提交首个 PR（Struct 代码生成，先支持基础类型） 9 月中：提交第二个 PR（扩展支持 Slice） 9 月下：提交第三个 PR（扩展支持 Map）；完善 CLI、文档与测试，收尾优化 2. 项目进度 已完成工作 编译时代码生成全链路 元信息解析与类型分析：parser.go、utils.go 代码生成核心：encoder.go（WriteTyped）、decoder.go（ReadTyped）、generator.go 编译期一致性保护（结构体快照与强校验）：guard.go CLI 工具与使用指引：cmd/fory/main.go、README.md 支持的类型与特性 Struct：基础类型、命名类型（含 time.Time、fory.Date）、指针、嵌套结构体 Slice：支持任意维度嵌套 slice 的序列化与反序列化 Map：对基本可比较键的 Map，按键排序实现确定性序列化 引用追踪与接口兼容：生成强类型 WriteTyped/ReadTyped，并生成 reflect.Value 兼容接口方法 字段排序与结构哈希：复刻反射路径排序与哈希规则，确保跨语言/反射路径完全一致 体验与一致性改进 生成文件包含 init() 自动注册，零显式接线 统一注解从 //fory:gen 调整为更语义化的 //fory:generate CLI 支持 --force 自动清理并重试，缓解编译期快照失配引发的错误 测试与示例 新增/完善 tests/structs.go 覆盖 Struct、Slice、Map、动态切片等示例类型（如 ValidationDemo、SliceDemo、DynamicSliceDemo、MapDemo） 生成器及跨语言模式相关用例：tests/generator_test.go、tests/generator_xlang_test.go 遇到的问题及解决方案 反射路径对齐与排序一致性 问题：生成代码需与反射序列化在字段排序、类型分组、哈希计算上完全一致，否则跨语言/回放失败。 方案：严格复刻反射实现的分组与排序规则；哈希计算对 Slice/Map 采用统一 TypeId（如 LIST=21、MAP=23）；为 int、string 等细节做特判，保证编码一致。 可空与引用追踪 问题：区分可引用类型与非引用类型的头标识（RefValueFlag/NotNullValueFlag），以及字符串/指针等路径的差异。 方案：在生成代码中统一通过 WriteReferencable/ReadReferencable 或非引用路径写入正确标识；字符串等最终类型按协议处理。 特殊类型与零值语义 问题：time.Time 与 fory.Date 在协议中的编码语义不同（如本地日期零值标记）。 方案：为这两类命名类型生成专门分支，零值与时间单位严格按协议读写。 Map 确定性输出 问题：Go map 无序，跨平台/回放可能不一致。 方案：对不同键类型生成相应的排序逻辑（string/int/uint/float/bool），确保序列化稳定。 Varint 编码与类型位宽 问题：部分基础类型在反射路径使用变长编码（如 int32/int64）；若不一致会导致不兼容。 方案：在非引用路径下为对应类型使用变长编码 API，保证与反射路径完全一致。 编译期守卫导致的首次失败 问题：结构体变更后未重新生成会触发守卫，造成一轮编译失败。 方案：CLI 增加智能提示与 --force 清理重试；文档同步指引。 后续工作安排 类型支持拓展：set、array、更丰富的 map 键类型、enum/decimal 等 兼容模式完善：元共享（MetaShare）与 schema 演进场景代码生成 工具链与稳定性：增加 Reflect vs Codegen 对照测试、fuzz 测试、性能基准与 CI 校验 生态完善：更多示例与最佳实践文档，支持更细粒度的生成选项（按包/按文件/按类型） 代码质量：进一步收敛边界分支（指针可寻址性、接口落地类型），提升可维护性 ","date":"2026-01-25","objectID":"/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E6%8C%87%E5%8D%97/:2:1","tags":["编程"],"title":"程序员面试指南","uri":"/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E6%8C%87%E5%8D%97/"},{"categories":["编程"],"content":"小智医疗 嵌入模型：阿里云百炼平台嵌入模型 text-embedding-v3，向量维度1024 持久化数据库：MongoDB 向量数据库：Pinecone。通过设置 minScore 阈值，能够过滤掉那些与查询文本相关性较低的结果 分片方式：按段落分割文档：每个片段包含不超过 300个token，并且有 30个token的重叠部分保证连贯性 流式输出：修改chatModel为streamingChatModel = \"qwenStreamingChatModel\",并修改chat方法返回值为Flux\u003cString\u003e @AiService: Function calling:用 @Tool 注解的方法,并配置工具名称和描述 ","date":"2026-01-25","objectID":"/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E6%8C%87%E5%8D%97/:2:2","tags":["编程"],"title":"程序员面试指南","uri":"/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E6%8C%87%E5%8D%97/"},{"categories":["编程"],"content":"探店笔记 项目介绍 仿大众点评 APP，实现了用户登录、关注、发布推送博客以及优惠券秒杀等功能，用户可以浏览首页热门内容，搜索查看附近商家，发布及查看探店博客。 主要功能模块 1.登录 因为如果使用Session在集群不同服务器之间无法共享，所以我们选择借助可以自动进行数据共享的Redis+token的存储方式。 这里有三个细节： 用户脱敏的处理：不能将从MySQL中取出来的用户的所有信息都直接在浏览器间传输（需要保护敏感信息），所以需要将基本可展示的属性封装成单独的DTO进行传递 使用双拦截器进行刷新token以及登录验证：如果只用一个拦截器，是无法完成对所有页面刷新token以及对于需要登录的页面进行登录验证的，所以我们设计了双拦截器模式，第一层拦截器会对所有的页面放行，同时刷新用户token的有效期，第二层拦截器会对需要登录的页面进行登录验证。 在第一层拦截器使用 ZSet 结合时间窗口进行登录限流。通过每次用户发起登录请求时，向 ZSet 插入一个 以当前时间戳为 score 和 member 的记录；然后使用 ZREMRANGEBYSCORE 删除 窗口开始时间之前 的所有记录（滑动窗口的核心）；最后通过 ZCARD 获取 ZSet 中剩余成员的数量（即当前窗口内的请求次数），将超过阈值的用户触发限流，拒绝请求。（通过 Lua 脚本 将 ZADD + ZREMRANGEBYSCORE + ZCARD 合并为原子操作，避免并发问题） 面试题：讲讲Session和Token的区别 维度 Session Token 存储位置 服务端存储（如 Redis、DB） 客户端存储（如 Cookie、LocalStorage） 状态性 有状态（服务端维护会话） 无状态（服务端不存储） 典型实现 Session ID + 服务端存储 JWT、OAuth2 Token 扩展性 跨服务器需共享存储 天然支持分布式 安全性 依赖服务端保护 需防篡改（如签名/加密） token可以优化成JWT格式（私钥和公钥） 2.商户缓存 细节点： 2.1 双写一致性： 数据库与缓存数据不一致的问题： 查：如果缓存未命中，就查询数据库，将结果写入缓存，并设置超时时间 改：先修改数据库，再删除缓存。 2.2 缓存穿透问题： 缓存并缓存空对象，项目中就用的这个 布隆过滤器（实现比较复杂） 2.3 缓存击穿问题： 使用互斥锁：这里借助Redis提供的setnx方法来实现，本项目就是使用的这个。 逻辑过期：异步构建缓存 3.优惠卷秒杀 基于Redis的setNx方法使得满足分布式系统下多进程可见并且互斥的锁。 细节点： 利用setnx方法进行加锁，同时增加过期时间，防止死锁。 释放锁时防误删（使用Lua脚本：在存入锁时，放入自己线程的标识，在删除锁时，判断当前这把锁的标识是不是自己存入的） 一人一单：比如时间是否充足，如果时间充足，则进一步判断库存是否足够，然后再根据优惠卷id和用户id查询是否已经下过这个订单，如果下过这个订单，则不再下单，否则进行下单 优化： 采用消息队列去将判断和执行操作进行异步化。 新增秒杀优惠卷的同时，将优惠卷信息保存到Redis中 基于Lua脚本，判断秒杀库存，一人一单，决定用户是否抢购成功 如果抢购成功，将优惠卷id和用户id封装后存入消息队列（这里我们使用Redis中的Stream作为消息队列） 开启线程任务，不断从消息队列中获取信息，实现异步下单操作 4. 达人探店 4.1 实现一个人只能点赞一次 给Blog类中添加一个isLike字段，标示是否被当前用户点赞 修改点赞功能，利用Redis的set集合判断是否点赞过，未点赞过则点赞数+1，已点赞过则点赞数-1 4.2 共同关注功能 当然是使用我们之前学习过的set集合咯，在set集合中，有交集并集补集的api，我们可以把两人的关注的人分别放入到一个set集合中，然后再通过api去查看这两个set集合中的交集数据。 4.3 好友关注-Feed流实现方案+滚动分页的实现 5. 查看附近商户 使用Redis的GEO数据结构存储经纬度，实现附近商户查询功能。 当我们点击美食之后，会出现一系列的商家，商家中可以按照多种排序方式，我们此时关注的是距离，这个地方就需要使用到我们的GEO，向后台传入当前app收集的地址(我们此处是写死的) ，以当前坐标作为圆心，同时绑定相同的店家类型type，以及分页信息，把这几个条件传入后台，后台查询出对应的数据再返回。 我们要做的事情是：将数据库表中的数据导入到redis中去，redis中的GEO，GEO在redis中就一个menber和一个经纬度，我们把x和y轴传入到redis做的经纬度位置去，但我们不能把所有的数据都放入到menber中去，毕竟作为redis是一个内存级数据库，如果存海量数据，redis还是力不从心，所以我们在这个地方存储他的id即可。 但是这个时候还有一个问题，就是在redis中并没有存储type，所以我们无法根据type来对数据进行筛选，所以我们可以按照商户类型做分组，类型相同的商户作为同一组，以typeId为key存入同一个GEO集合中即可 6.全局唯一id 这个需要通过redis实现分布式id 为了提高数据库的性能，id会采用数值类型（Long）直接插入数据库（因为数值类型在数据库中占用空间较小，建立索引方便，速度更快）。 因为采用的是Long型，有8个字节，64个比特位， 第一个比特位是符号位，永远为0。 中间31个bit为时间戳（以秒为单位，定一个初始的时间，在计算下订单时的时间与初始时间的时间差是多少秒并记录下来，可以使用69年），用来增加ID复杂性，不是单纯的Redis自增。 后面32位bit为序列号，序列号中就是Redis自增的值。支持每秒产生2^32个不同ID 因此如果在一秒钟下了多份订单，即使时间戳相同，那么后面的序列号也会不同。 综上所述，利用redis就能够满足分布式系统中全局唯一ID的五大特性。 注意事项：不能只选择一个key来坐自增长，即无论订单业务持续多长时间，自始至终就只是这一个key在做自增长，随着不断的发展，key的值会也来越大，而redis单个key的自增长的数值是有限度的，上限为2 ^ 64。而且真正用来记录的序列号只有32位bit，如果接下来存的数值超过了2^32位，那么序列号这一部分就存不下。因此不能一直使用同一个key，哪怕是同一个业务。 解决方案，可以在该key后面在拼接一个时间戳，比如哪一天下的订单，当天的key就为 key名+ “20250605”。向下类推。这样还可以统计每一天下单的总量。 String date = LocalDateTime.now().format(DateTimeFormatter.ofPattern(\"yyyy:MM:dd\")); long count = stringRedisTemplate.opsForValue().increment(\"icr:\" + keyPrefix +\":\"+ date); ","date":"2026-01-25","objectID":"/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E6%8C%87%E5%8D%97/:2:3","tags":["编程"],"title":"程序员面试指南","uri":"/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E6%8C%87%E5%8D%97/"},{"categories":["编程"],"content":"蛇蛇大作战 主要包含模块： pk模块 对局列表模块： 排行榜模块 用户中心模块 websocket（全双工） KOB项目可能面试题 问题：在实现Bot服务时，如何确保代码的安全性，避免恶意代码的执行？ 为确保代码安全性，我们可以对用户提交的Bot代码进行过滤和限制。例如，可以使用沙箱技术隔离代码执行环境，限制代码对系统资源的访问。同时，我们还可以对代码进行静态分析，以识别并阻止潜在的恶意行为。 问题：请谈谈项目中使用WebSocket的优势以及在实际应用中遇到的挑战。 WebSocket的主要优势是提供了一种实时双向通信机制，允许服务器与客户端之间进行低延迟、高效的数据交换。这对于在线游戏这样要求快速响应和实时交互的应用场景非常重要。在实际应用中，我们可能会遇到WebSocket连接不稳定、网络延迟和浏览器兼容性等问题。为了解决这些问题，我们需要确保代码具有足够的容错能力，如重连机制，以及对各种浏览器的充分测试。 问题：在匹配服务中，如何根据玩家的分值差距和等待时间进行智能匹配？ 在匹配服务中，我们使用一个定时线程来定期检查待匹配玩家列表。根据玩家的分值差距和等待时间，我们可以为每个玩家计算一个匹配优先级。优先级越高，匹配的可能性越大。我们可以利用优先级队列来快速找到最佳匹配对手。为了实现更精确的匹配，我们可以根据实际情况调整优先级计算的权重和阈值。 问题：在项目中，为什么选择将功能划分为三个独立的SpringBoot进程模块？ 将主服务、匹配服务和Bot服务独立出来，可以降低各个模块之间的耦合度，使每个模块专注于自己的功能，便于维护和扩展。 可扩展性：各个模块可以根据实际需求进行横向扩展，提高系统的整体性能。 容错性：将功能拆分为多个独立的进程可以提高系统的容错性。当某个模块出现故障时，不会影响到其他模块的正常运行。 灵活部署：各个模块可以根据实际情况灵活部署，例如在不同的服务器上运行，以满足不同模块的资源需求。 问题：项目中如何实现线程安全的游戏状态同步？ 为了实现线程安全的游戏状态同步，我们采用了以下策略： 对共享资源进行同步访问：在涉及到多线程访问共享资源的地方，我们使用锁或其他同步机制来保证数据的一致性。 尽量减少共享资源：通过将共享资源封装在ThreadLocal中，可以实现线程之间的数据隔离，从而减少同步的需求。 优先使用无锁数据结构：在适当的场景下，使用无锁数据结构（如ConcurrentHashMap、AtomicInteger等）可以降低锁竞争带来的性能开销。 问题：在项目中，如何保证Bot代码执行的性能和资源占用？ 为了保证Bot代码执行的性能和资源占用，我们采用了以下策略： 使用线程池：通过线程池控制并发的Bot任务数量，避免过多的线程导致系统资源耗尽。 设置超时限制：为Bot代码执行设置合理的超时限制，防止某些任务长时间占用系统资源。 资源限制：为每个Bot任务分配固定的资源，例如CPU和内存，以防止某些任务过度消耗系统资源。 问题：如何保证匹配服务在高并发情况下的性能？ 为了保证匹配服务在高并发情况下的性能，我们采用了以下策略： 使用高性能数据结构：选择高性能的数据结构（如ConcurrentHashMap、PriorityQueue等）来维护待匹配玩家列表，以减小并发访问的性能开销。 异步处理：通过将匹配任务放入队列并采用异步处理方式，可以有效降低用户请求的响应时间。 定时线程：使用定时线程按照分值差距和等待时间进行动态配对，减少匹配过程中的计算量。 问题：在实现Bot服务时，如何防止恶意代码的执行？ 为了防止恶意代码的执行，我们在Bot服务中采用了以下策略： 代码审查：在用户提交Bot代码前，可以通过代码审查工具对其进行安全性检查，过滤掉潜在的恶意代码。 沙箱环境：将Bot代码运行在隔离的沙箱环境中，限制其对系统资源的访问，从而降低恶意代码对系统的影响。 资源限制：为每个Bot任务分配固定的资源，例如CPU和内存，以防止恶意代码消耗过多的系统资源。 问题：在游戏平台中，如何处理用户的实时在线对战功能？ 为了处理用户的实时在线对战功能，我们采用了以下策略： WebSocket：使用WebSocket实现双向实时通信，使服务器能够及时将游戏状态推送给客户端，同时接收客户端的操作。 多线程处理：针对多对玩家的操作，我们采用多线程处理方式，每对玩家的操作在一个独立的线程中执行，以提高并发处理能力。 游戏状态同步：通过服务器端的游戏状态管理和同步机制，确保所有客户端看到的游戏状态是一致的。 项目整体架构类 请简要描述这个项目的整体架构，包括前端、后端和数据库的交互流程。 项目中使用了哪些微服务？它们之间是如何通信和协作的？ 请说明项目中不同模块（如匹配系统、对战系统、回放系统）之间的依赖关系和调用逻辑。 技术细节类 前端部分 在 web/src/assets/scripts/GameMap.js 中，add_listening_events 方法在回放模式和正常游戏模式下的处理逻辑有何不同？ 前端使用了哪些技术来实现游戏的动画效果，如蛇的移动和死亡状态？ 前端如何与后端进行数据交互，特别是在获取对局记录和发送玩家操作方面？ 后端部分 在 kob/backendcloud/backend/src/main/java/com/kob/backend/consumer/utils/Game.java 中，nextStep 方法的作用是什么？它是如何实现等待玩家下一步操作的？ 后端使用了哪些技术来实现多线程处理，如 Game 类继承 Thread 类的作用和实现方式？ 请解释 kob/backendcloud/botrunningsystem/src/main/java/com/kob/botrunningsystem/service/impl/utils/Consumer.java 中 startTimeout 方法的作用和实现逻辑。 数据库部分 项目中使用了哪种数据库？请说明数据库表结构，特别是与对局记录相关的表。 在 kob/backendcloud/backend/src/main/java/com/kob/backend/consumer/utils/Game.java 中，saveToDatabase 方法是如何将对局信息保存到数据库中的？ 如何保证数据库操作的事务性和数据一致性？ 问题解决类 如果在对局回放过程中出现卡顿或延迟，你会从哪些方面进行排查和解决？ 当多个玩家同时请求匹配时，如何处理并发问题，确保匹配系统的稳定性和公平性？ 如果前端无法获取后端的对局记录，你会如何进行调试和定位问题？ 代码优化类 请分析 web/src/assets/scripts/Snake.js 中 update_move 方法的性能瓶颈，并提出优化建议。 对于 kob/backendcloud/matchingsystem/src/main/java/com/kob/matchingsystem/service/impl/utils/Player.java 类，你认为可以从哪些方面进行代码优化？ 如何优化前端的网络请求，减少响应时间和数据传输量？ 扩展性和维护性类 如果要增加一种新的游戏模式，你会从哪些方面对项目进行修改和扩展？ 如何保证项目代码的可维护性，特别是在多人协作开发的情况下？ 请说明项目中使用的依赖管理工具（如 npm 和 Maven）对项目扩展性和维护性的影响。 ","date":"2026-01-25","objectID":"/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E6%8C%87%E5%8D%97/:2:4","tags":["编程"],"title":"程序员面试指南","uri":"/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E6%8C%87%E5%8D%97/"},{"categories":["编程"],"content":"c++ 可以先看看我的c++学习笔记 c++语法方面的八股可以看：代码随想录（最强八股文）第五版（C++篇）.pdf 小红书引擎架构面试原题 Q: 对于一个 struct vector： struct vector { int x; int y; } 如果我们有线程 a 和线程 b,它们一个在不停的修改 x,一个在不停的修改 y，请问会有性能问题吗？ A: 会有的。因为现代的 CPU cache line 一般为 64 字节，所以整个 vector 会在同一个 CPU cache line 里。 这是一个经典的 False Sharing（伪共享） 问题。 假设： 线程 A 跑在 core 0 线程 B 跑在 core 1 第一次写： core 0 写 x cache line 被加载到 core 0 的 L1 cache 状态变成 Modified (M) 然后线程 B 写 y: core 1 想写 y 根据 MESI 协议： core 1 不能直接写 必须先让 core 0 的那条 cache line 失效（invalidate） cache line 被“抢”到 core 1 core 1 写 y → Modified 再轮到线程 A core 0 再写 x invalidate core 1 cache line 再被拉回 core 0 小红书引擎架构面试原题 Q. 1.我们的程序在执行 char* data = new char[1024 * 1024 * 1024]后，会立马分配 1GB 的内存空间吗？ 2.如果我们这时候访问 data[0]，os会做哪些事情？ 3.malloc 很大的空间和很小的空间会有什么差异吗？ ","date":"2026-01-25","objectID":"/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E6%8C%87%E5%8D%97/:3:0","tags":["编程"],"title":"程序员面试指南","uri":"/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E6%8C%87%E5%8D%97/"},{"categories":["编程"],"content":"Java代码题 交替打印\"ABC\" import java.util.concurrent.locks.*; public class PrintABCUsingLock { Lock lock = new ReentrantLock(); int state = 0; int times; PrintABCUsingLock(int times) { this.times = times; } void printLetter(String str, int target_state) { for (int i = 0; i \u003c times; ) { lock.lock(); if (target_state == state % 3) { i ++; state ++; System.out.println(str); } lock.unlock(); } } public static void main(String args[]) { PrintABCUsingLock printABCUsingLock = new PrintABCUsingLock(10); new Thread(() -\u003e { printABCUsingLock.printLetter(\"a\", 0); }).start(); new Thread(() -\u003e { printABCUsingLock.printLetter(\"b\", 1); }).start(); new Thread(() -\u003e { printABCUsingLock.printLetter(\"c\", 2); }).start(); } } public class PrintABCUsingLock { final Object lock = new Object(); int state = 0; int times; PrintABCUsingLock(int times) { this.times = times; } void printLetter(String str, int target) { for (int i = 0; i \u003c times; i ++) { synchronized (lock) { while (state % 3 != target) { try { lock.wait(); } catch (InterruptedException e) { throw new RuntimeException(e); } } state ++; System.out.println(str); lock.notifyAll(); } } } public static void main(String[] args) { PrintABCUsingLock printABCUsingLock = new PrintABCUsingLock(5); new Thread(() -\u003e { printABCUsingLock.printLetter(\"A\", 0); }).start(); new Thread(() -\u003e { printABCUsingLock.printLetter(\"B\", 1); }).start(); new Thread(() -\u003e { printABCUsingLock.printLetter(\"C\", 2); }).start(); } } ","date":"2026-01-25","objectID":"/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E6%8C%87%E5%8D%97/:4:0","tags":["编程"],"title":"程序员面试指南","uri":"/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E6%8C%87%E5%8D%97/"},{"categories":["编程"],"content":"交替打印1-100 import java.util.Objects; import java.util.concurrent.locks.Lock; import java.util.concurrent.locks.ReentrantLock; public class Print100UsingLock { final Object lock = new Object(); int mx; int cur = 1; int status = 0; Print100UsingLock(int mx) { this.mx = mx; } void printNumber(int target) { while (true) { synchronized (lock) { while (status % 3 != target) { try { lock.wait(); } catch (InterruptedException e) { throw new RuntimeException(e); } } if (cur \u003e mx) { lock.notifyAll(); break; } status ++; System.out.println(cur); cur ++; lock.notifyAll(); } } } public static void main(String[] args) { Print100UsingLock print100UsingLock = new Print100UsingLock(100); new Thread(() -\u003e { print100UsingLock.printNumber(0); }).start(); new Thread(() -\u003e { print100UsingLock.printNumber(1); }).start(); new Thread(() -\u003e { print100UsingLock.printNumber(2); }).start(); } } ","date":"2026-01-25","objectID":"/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E6%8C%87%E5%8D%97/:4:1","tags":["编程"],"title":"程序员面试指南","uri":"/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E6%8C%87%E5%8D%97/"},{"categories":["编程"],"content":"网络 ","date":"2026-01-25","objectID":"/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E6%8C%87%E5%8D%97/:5:0","tags":["编程"],"title":"程序员面试指南","uri":"/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E6%8C%87%E5%8D%97/"},{"categories":["编程"],"content":"HTTP的常用方法有哪些 GET POST DELETE PUT HEAD ","date":"2026-01-25","objectID":"/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E6%8C%87%E5%8D%97/:5:1","tags":["编程"],"title":"程序员面试指南","uri":"/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E6%8C%87%E5%8D%97/"},{"categories":["编程"],"content":"有哪些常用状态码 img 其中常见的具体状态码有： 200:请求成功； 301:永久重定向；302：临时重定向； ‌HTTP 403 Forbidden‌ 是客户端错误状态码，表示服务器理解请求但‌拒绝执行，通常是因为客户端‌没有访问资源的权限。404:无法找到此页面；405：请求的方法类型不支持；401 表示“未授权”（Unauthorized） 500:服务器内部出错。 ","date":"2026-01-25","objectID":"/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E6%8C%87%E5%8D%97/:5:2","tags":["编程"],"title":"程序员面试指南","uri":"/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E6%8C%87%E5%8D%97/"},{"categories":["编程"],"content":"讲一下TCP连接的三次握手和四次挥手 这样双方都完成了一次“发送-收到回复”的过程。 接下来，从三个方面分析三次握手的原因： 1. 三次握手才可以阻止重复历史连接的初始化（主要原因） 我们来看看RFC793指出的TCP连接使用三次握手的首要原因： The principle reason for the three-way handshake is to prevent old duplicate connection initiations fromcausing confusion. 简单来说，三次握手的首要原因是为了防止旧的重复连接初始化造成混乱。 如果是两次握手连接，就无法阻止历史连接，那为什么TCP两次握手为什么无法阻止历史连接呢？ 我先直接说结论，主要是因为在两次握手的情况下，服务端没有中间状态给客户端来阻止历史连接，导致服务端可能建立一个历史连接，造成资源浪费。 2. 三次握手才可以同步双方的初始序号 TCP协议的通信双方，都必须维护一个「序列号」，序列号是可靠传输的一个关键因素，它的作用： 接收方可以去除重复的数据； 接收方可以根据数据包的序列号按序接收； 可以标识发送出去的数据包中，哪些是已经被对方收到的（通过 ACK 报文中的序列号知道）； 3. 三次握手才可以避免资源浪费 即两次握手会造成消息滞留情况下，服务端重复接受无用的连接请求 SYN 报文，而造成重复分配资源。 ","date":"2026-01-25","objectID":"/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E6%8C%87%E5%8D%97/:5:3","tags":["编程"],"title":"程序员面试指南","uri":"/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E6%8C%87%E5%8D%97/"},{"categories":["编程"],"content":"tcp和udp共用端口的问题 可以的 ","date":"2026-01-25","objectID":"/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E6%8C%87%E5%8D%97/:5:4","tags":["编程"],"title":"程序员面试指南","uri":"/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E6%8C%87%E5%8D%97/"},{"categories":["编程"],"content":"如何实现一个可靠的UDP UDP本身是无连接、不可靠的传输层协议，但其低延迟和灵活性使其适用于实时性要求高的场景（如游戏、音视频传输）。若需在UDP基础上实现可靠性，需通过‌应用层协议设计‌来弥补其不足。以下是实现可靠UDP的核心方案： ‌1. 核心机制设计‌ ‌机制‌ ‌实现目标‌ ‌具体方案‌ ‌序列号‌ 确保数据包顺序正确性 为每个数据包分配递增的序列号（Sequence Number），接收方按序重组数据。 ‌**确认应答（ACK）**‌ 确认数据包到达，触发重传 接收方收到数据包后发送ACK，携带已确认的最大序列号或选择性确认（SACK）。 ‌超时重传‌ 处理丢包问题 发送方维护未确认数据包的计时器，超时后重传。动态计算超时时间（基于RTT）。 ‌流量控制‌ 防止发送方压垮接收方 通过滑动窗口机制限制发送速率，接收方动态通告窗口大小（类似TCP）。 ‌拥塞控制‌ 避免网络过载 实现类似TCP的拥塞控制算法（如AIMD、BBR），根据丢包和延迟调整发送速率。 ‌数据分片与重组‌ 处理大数据传输 发送方将应用层数据分片为适合MTU的包，接收方根据序列号重组。 ","date":"2026-01-25","objectID":"/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E6%8C%87%E5%8D%97/:5:5","tags":["编程"],"title":"程序员面试指南","uri":"/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E6%8C%87%E5%8D%97/"},{"categories":["编程"],"content":"TSL四次握手 ","date":"2026-01-25","objectID":"/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E6%8C%87%E5%8D%97/:5:6","tags":["编程"],"title":"程序员面试指南","uri":"/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E6%8C%87%E5%8D%97/"},{"categories":["编程"],"content":"CA证书验证流程，存储在哪里？ ","date":"2026-01-25","objectID":"/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E6%8C%87%E5%8D%97/:5:7","tags":["编程"],"title":"程序员面试指南","uri":"/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E6%8C%87%E5%8D%97/"},{"categories":["编程"],"content":"常见攻击手段和预防手段 1. ddos攻击 ‌攻击原理‌ ‌常见手法‌ ‌预防手段‌ 通过海量恶意流量耗尽目标服务器资源，导致服务不可用。 - ‌流量型攻击‌（如UDP Flood、ICMP Flood） - ‌协议型攻击‌（如SYN Flood、ACK Flood） - ‌应用层攻击‌（如HTTP Flood） - ‌流量清洗‌：使用CDN或云防护服务（如Cloudflare、AWS Shield）过滤异常流量。 - ‌限速与黑名单‌：通过防火墙或Nginx限速（limit_req）。 - ‌协议优化‌：配置服务器抵御SYN Flood（如启用SYN Cookies）。 - ‌负载均衡‌：分散流量至多台服务器。 2. SQL注入 ‌攻击原理‌ ‌常见手法‌ ‌预防手段‌ 通过注入恶意SQL代码，篡改数据库查询逻辑。 - ‌联合查询注入‌（UNION SELECT） - ‌布尔盲注‌ - ‌时间盲注‌ - ‌报错注入‌ - ‌参数化查询‌：使用预编译语句（如Java的PreparedStatement）。 - ‌ORM框架‌：如Hibernate、SQLAlchemy，避免直接拼接SQL。 - ‌输入过滤‌：对特殊字符（如'、;）进行转义或白名单验证。 - ‌最小权限原则‌：数据库账户仅授予必要权限。 3. CSRF攻击 ‌攻击原理‌ ‌常见手法‌ ‌预防手段‌ 诱导用户执行非预期的跨站请求（如转账、改密）。 - ‌伪造GET请求‌（通过图片链接） - ‌伪造POST表单‌（通过隐藏表单） - ‌CSRF Token‌：服务端生成随机Token，嵌入表单或请求头，验证请求来源。 - ‌SameSite Cookie属性‌：设置为Strict或Lax（防止跨域携带Cookie）。 - ‌检查Referer头‌：验证请求来源域名是否合法。 4. XSS攻击 ‌攻击原理‌ ‌常见手法‌ ‌预防手段‌ 注入恶意脚本到网页中，窃取用户数据或会话。 - ‌存储型XSS‌（恶意脚本存入数据库） - ‌反射型XSS‌（通过URL参数反射脚本） - ‌DOM型XSS‌（客户端DOM操作触发） - ‌输入输出过滤‌：对用户输入进行HTML实体转义（如\u003c转义为\u003c）。 - ‌Content Security Policy (CSP)‌：限制脚本来源（如script-src 'self'）。 - ‌HttpOnly Cookie‌：防止JavaScript窃取会话Cookie。 ","date":"2026-01-25","objectID":"/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E6%8C%87%E5%8D%97/:5:8","tags":["编程"],"title":"程序员面试指南","uri":"/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E6%8C%87%E5%8D%97/"},{"categories":["编程"],"content":"Socket有哪些了解（wxg，快手都问了） 我对 Socket 编程有比较深入的了解，它是在网络编程中实现进程间通信（特别是跨网络通信）的基础技术。以下是我对 Socket 编程关键方面的理解： ‌**核心概念与作用：**‌ ‌**Socket 的本质：**‌ 是由操作系统提供的一种编程接口（API），是应用层与传输层之间的抽象层。它允许应用程序通过网络发送和接收数据。 ‌**通信端点：**‌ 每个 Socket 代表网络通信的一个端点，由 IP地址 + 端口号 唯一标识。 ‌**类比：**‌ 类似于电话插座（Socket）和电话机（应用程序），插座提供了连接网络的物理/逻辑接口。 ‌**关键模型：TCP vs UDP：**‌ ‌TCP (SOCK_STREAM): ‌**面向连接：**‌ 通信前需要建立连接（三次握手）。 ‌**可靠传输：**‌ 保证数据顺序、无差错、不丢失、不重复地到达。 ‌**流式传输：**‌ 数据被视为字节流，没有明确边界。应用程序需要自己处理消息边界（如添加长度前缀或分隔符）。 ‌**适用场景：**‌ 需要高可靠性的应用，如网页浏览 (HTTP/HTTPS)、文件传输 (FTP)、电子邮件 (SMTP/POP3/IMAP)、数据库连接。 ‌UDP (SOCK_DGRAM): ‌**无连接：**‌ 无需建立连接，直接发送数据报。 ‌**不可靠传输：**‌ 不保证数据一定到达、到达顺序、不丢失、不重复。可能丢包、乱序。 ‌**数据报传输：**‌ 数据以独立的数据包（Datagram）为单位传输，有明确边界。 ‌**高效、低延迟：**‌ 由于开销小，通常比 TCP 更快、延迟更低。 ‌**适用场景：**‌ 实时性要求高、能容忍少量丢包的应用，如视频/音频直播、在线游戏、DNS 查询、广播/多播应用（如 DHCP）。 ‌**核心编程步骤（以 TCP 服务器为例）：**‌ # 伪代码示意核心步骤 # 1. 创建服务器端 Socket (TCP) server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM) # AF_INET 指 IPv4 # 2. 绑定 Socket 到地址和端口 server_socket.bind(('0.0.0.0', 8080)) # 监听所有网络接口的 8080 端口 # 3. 开始监听连接请求 (TCP特有) server_socket.listen(5) # 设置等待连接队列的最大长度 # 4. 接受客户端连接 (阻塞直到有连接进来) client_socket, client_address = server_socket.accept() # 5. 与客户端通信 (接收/发送数据) data = client_socket.recv(1024) # 接收最多 1024 字节 client_socket.send(b'Hello Client!') # 发送数据 (注意字节串) # 6. 关闭连接 client_socket.close() # 7. (可选) 回到步骤4接收新连接 或 关闭服务器Socket server_socket.close() ‌**核心编程步骤（以 TCP 客户端为例）：**‌ # 伪代码示意核心步骤 # 1. 创建客户端 Socket (TCP) client_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM) # 2. 连接到服务器 (TCP特有) client_socket.connect(('server_ip', 8080)) # 替换为实际服务器IP和端口 # 3. 与服务器通信 (发送/接收数据) client_socket.send(b'Hello Server!') data = client_socket.recv(1024) # 4. 关闭连接 client_socket.close() ‌**关键技术与概念：**‌ ‌**地址族：**‌ AF_INET (IPv4), AF_INET6 (IPv6), AF_UNIX (本地 Unix 域套接字)。 ‌**套接字类型：**‌ SOCK_STREAM (TCP), SOCK_DGRAM (UDP), SOCK_RAW (原始套接字)。 ‌阻塞 vs 非阻塞： ‌**阻塞：**‌ 调用 accept(), connect(), recv(), send() 等函数时，程序会暂停执行，直到操作完成（如连接建立、数据到达）。 ‌**非阻塞：**‌ 这些函数会立即返回，无论操作是否完成。需要使用 select, poll, epoll (Linux), kqueue (BSD/macOS) 或异步 I/O 模型（如 asyncio）来高效管理多个 Socket。 ‌**I/O 多路复用：**‌ select, poll, epoll, kqueue 等技术，允许一个进程/线程同时监视多个 Socket 的状态（是否可读、可写、有异常），提高并发性能。 ‌**字节序：**‌ 网络字节序是大端序。需要使用 htonl(), htons(), ntohl(), ntohs() 等函数在主机字节序和网络字节序之间转换数据（尤其是多字节整数和端口号）。 ‌**粘包/拆包：**‌ TCP 流式传输的特性导致发送方多次发送的数据可能在接收方缓冲区中被合并成一个数据块（粘包），或者一个数据块被拆分成多次接收（拆包）。应用程序需要设计协议（如固定长度、长度前缀、分隔符）来处理边界。 ‌**错误处理：**‌ 网络通信异常丰富（连接超时、中断、对端关闭、资源不足等），健壮的 Socket 程序必须妥善处理各种错误和异常。 ‌**超时设置：**‌ 可以为 Socket 操作设置超时时间 (settimeout())，防止程序无限期阻塞。 ‌**实际应用：**‌ 几乎所有网络应用底层都使用 Socket：Web 服务器 (Nginx, Apache)、数据库 (MySQL, Redis)、消息队列 (RabbitMQ, Kafka)、FTP/SFTP 客户端/服务器、邮件客户端/服务器、即时通讯软件、网络游戏、自定义协议的分布式系统通信等。 ","date":"2026-01-25","objectID":"/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E6%8C%87%E5%8D%97/:5:9","tags":["编程"],"title":"程序员面试指南","uri":"/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E6%8C%87%E5%8D%97/"},{"categories":["编程"],"content":"场景题 ","date":"2026-01-25","objectID":"/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E6%8C%87%E5%8D%97/:6:0","tags":["编程"],"title":"程序员面试指南","uri":"/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E6%8C%87%E5%8D%97/"},{"categories":["编程"],"content":"如何利用线程池去实现一个比如整点进行日志记录功能 【美团面试没做出来血的教训】 ","date":"2026-01-25","objectID":"/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E6%8C%87%E5%8D%97/:6:1","tags":["编程"],"title":"程序员面试指南","uri":"/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E6%8C%87%E5%8D%97/"},{"categories":["编程"],"content":"三个服务器如何进行负载均衡，让同一内容的请求打到同一台副本上，以及如何动态扩容在不影响前面三台机器的前提下 【百度面试没做出来血的教训】 了解一下一致性hash算法 提前预估出1000个哈希桶，然后进行划分（也就是做好提前量） ","date":"2026-01-25","objectID":"/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E6%8C%87%E5%8D%97/:6:2","tags":["编程"],"title":"程序员面试指南","uri":"/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E6%8C%87%E5%8D%97/"},{"categories":["编程"],"content":"如何用redis筛选出前100名的排行榜，也就是动态更新redis，同时用户非常多，redis中放不下所有的 【快手面试没做出来血的教训】 ","date":"2026-01-25","objectID":"/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E6%8C%87%E5%8D%97/:6:3","tags":["编程"],"title":"程序员面试指南","uri":"/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E6%8C%87%E5%8D%97/"},{"categories":["编程"],"content":"操作系统 ","date":"2026-01-25","objectID":"/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E6%8C%87%E5%8D%97/:7:0","tags":["编程"],"title":"程序员面试指南","uri":"/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E6%8C%87%E5%8D%97/"},{"categories":["编程"],"content":"进程，线程和协程 最后是协程。协程是一种用户态的轻量级线程，其调度完全由用户程序控制，而不需要内核的参与。协程拥有自己的寄存器上下文和栈，但与其他协程共享堆内存。协程的切换开销非常小，因为只需要保存和恢复协程的上下文，而无需进行内核级的上下文切换。这使得协程在处理大量并发任务时具有非常高的效率。然而，协程需要程序员显式地进行调度和管理，相对于线程和进程来说，其编程模型更为复杂。 ‌二、协程的核心优势‌ ‌1. 轻量级并发‌ ‌内存占用极低‌：协程栈大小通常为KB级（如Go的goroutine默认2KB）。 ‌切换成本极低‌：协程切换在用户态完成（无需内核介入），单次切换耗时约100纳秒。 ‌支持超高并发‌：单机可轻松创建数百万协程（如Go的goroutine）。 ","date":"2026-01-25","objectID":"/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E6%8C%87%E5%8D%97/:7:1","tags":["编程"],"title":"程序员面试指南","uri":"/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E6%8C%87%E5%8D%97/"},{"categories":["编程"],"content":"select、poll和epoll讲讲区别 核心对比表 IO复用技术 特性 select poll epoll ‌时间复杂度‌ O(n) - 每次轮询所有fd O(n) - 每次轮询所有fd O(1) - 只处理就绪事件 ‌最大文件描述符‌ 有限制 (通常1024) 无硬性限制 无硬性限制 ‌工作方式‌ 轮询所有文件描述符 轮询所有文件描述符 回调通知机制 ‌内核数据结构‌ 位图 (fd_set) 链表 (pollfd) 红黑树+就绪链表 ‌触发模式‌ 仅支持水平触发 (LT) 仅支持水平触发 (LT) 支持水平触发 (LT) + 边缘触发 (ET) ‌内存拷贝开销‌ 每次调用需复制整个fd_set 每次调用需复制整个pollfd数组 注册时一次拷贝 ‌适用场景‌ 低并发/跨平台场景 需要更多fd但并发不高 高并发场景 (\u003e1000连接) ‌API复杂度‌ 简单 较简单 较复杂 ‌跨平台性‌ 广泛支持 POSIX标准 Linux特有 ","date":"2026-01-25","objectID":"/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E6%8C%87%E5%8D%97/:7:2","tags":["编程"],"title":"程序员面试指南","uri":"/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E6%8C%87%E5%8D%97/"},{"categories":["编程"],"content":"内核态与用户态 ","date":"2026-01-25","objectID":"/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E6%8C%87%E5%8D%97/:7:3","tags":["编程"],"title":"程序员面试指南","uri":"/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E6%8C%87%E5%8D%97/"},{"categories":["编程"],"content":"操作系统中进程死锁条件（那四个），如何死锁避免，死锁检测 ‌死锁的四个必要条件‌（必须同时存在才会死锁） ‌条件‌ ‌说明‌ 1. ‌互斥‌ 资源一次只能被一个进程独占（如打印机） 2. ‌占有并等待‌ 进程已持有资源，同时请求新资源且不释放已有资源 3. ‌不可抢占‌ 资源只能由持有者主动释放，不可强行剥夺 4. ‌循环等待‌ 进程间形成环形等待链：P1等P2的资源，P2等P3的资源… Pn等P1的资源 ‌死锁避免策略‌（预防死锁发生） ‌资源分配策略‌ ‌银行家算法：进程申请资源时，预判分配后系统是否仍处于‌安全状态‌（即存在安全序列） 若不安全则拒绝分配（即使当前资源足够） ‌资源有序分配法‌：为所有资源类型定义全局顺序，进程必须按序申请资源（如只能先申请A再申请B） ‌进程启动控制‌ 新进程启动时检查其最大资源需求，若可能引发不安全状态则延迟启动 ‌‌死锁检测方法‌（发生后识别） ‌资源分配图（RAG）检测‌ ‌顶点‌：进程（P） + 资源类型（R） ‌边： ‌请求边‌ P → R（进程等待资源） ‌分配边‌ R → P（资源已被进程占用） ‌检测循环‌：使用图算法（如DFS）检查图中是否存在闭环 → 存在环即死锁 ‌检测时机‌ 定时检测（如每5分钟） 当CPU利用率骤降时触发检测 ‌死锁恢复手段‌（检测到后处理） ‌方法‌ ‌操作‌ ‌进程终止‌ 强制终止所有死锁进程（简单粗暴）或按优先级逐步终止进程直到死锁解除 ‌资源抢占‌ 强制回收某个进程的资源（需解决被抢占进程的后续恢复问题，如回滚操作） ","date":"2026-01-25","objectID":"/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E6%8C%87%E5%8D%97/:7:4","tags":["编程"],"title":"程序员面试指南","uri":"/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E6%8C%87%E5%8D%97/"},{"categories":["编程"],"content":"MySQL ","date":"2026-01-25","objectID":"/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E6%8C%87%E5%8D%97/:8:0","tags":["编程"],"title":"程序员面试指南","uri":"/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E6%8C%87%E5%8D%97/"},{"categories":["编程"],"content":"SQL基础 数据库三大范式是什么 好的！数据库的三大范式（Normalization）是关系型数据库设计的核心原则，目的是减少数据冗余、提高数据一致性。我用生活中的例子帮你轻松理解，保证不枯燥！ 先看一个“反面教材”表格 假设设计一个「学生课程表」，直接存成这样： 学号 姓名 课程 学分 教师 教师办公室 1001 张三 数学,英语 4,3 王老师 A栋301, B栋202 1002 李四 物理 2 张老师 C栋105 问题： 数据冗余：同一门课程的教师和办公室被重复存储。 更新异常：如果“王老师”换办公室，所有相关行都要改。 插入异常：新教师没安排课程时，无法录入信息。 删除异常：删除某门课程可能连带删除教师信息。 第一范式（1NF）——原子性 核心要求：每列的值必须是不可再分的最小数据单元（原子性）。 问题：上表中“课程”、“学分”、“教师”、“教师办公室”包含多个值。 解决方案：拆分为单值： 学号 姓名 课程 学分 教师 教师办公室 1001 张三 数学 4 王老师 A栋301 1001 张三 英语 3 李老师 B栋202 1002 李四 物理 2 张老师 C栋105 关键点： 每行数据描述一个独立实体（比如一门课程）。 但仍有冗余（如“张老师”的信息重复）。 第二范式（2NF）——消除部分依赖 核心要求：表中每个字段必须完全依赖主键（不能只依赖主键的一部分）。 前提：表必须有复合主键（多个字段共同作为主键）。 分析上表： 主键是（学号, 课程），因为需要这两个字段唯一标识一行。 问题： “姓名”只依赖学号（与课程无关）→ 部分依赖。 “教师”和“教师办公室”只依赖课程（与学号无关）→ 部分依赖。 解决方案：拆分为三张表！ 学生表（主键：学号）： 学号 姓名 1001 张三 1002 李四 课程表（主键：课程）： 课程 学分 教师 教师办公室 数学 4 王老师 A栋301 英语 3 李老师 B栋202 物理 2 张老师 C栋105 选课表（主键：学号+课程）： 学号 课程 1001 数学 1001 英语 1002 物理 关键点： 每张表只描述一件事（学生、课程、选课关系）。 冗余消除：教师信息只存一次，修改时只需改一处。 第三范式（3NF）——消除传递依赖 核心要求：表中字段不能依赖其他非主键字段（即避免“间接依赖”）。 分析课程表： 主键是“课程”。 “教师办公室”依赖“教师”（教师 → 教师办公室），而“教师”依赖主键“课程”。 存在传递依赖：课程 → 教师 → 教师办公室。 问题： 如果“王老师”换办公室，需修改所有他教授的课程对应的行。 解决方案：继续拆分！ 教师表（主键：教师）： 教师 教师办公室 王老师 A栋301 李老师 B栋202 张老师 C栋105 课程表（主键：课程）： 课程 学分 教师 数学 4 王老师 英语 3 李老师 物理 2 张老师 关键点： 教师办公室信息只与教师相关，和课程无关。 修改教师办公室时，只需改“教师表”中的一行。 总结：三大范式的作用 范式 核心要求 解决的问题 1NF 数据原子性 字段不可再分（如拆分多值字段） 2NF 消除部分依赖 拆分依赖复合主键的部分字段 3NF 消除传递依赖 拆分间接依赖的非主键字段 1. 减少数据冗余 问题：如果数据重复存储（如学生表中每个课程都重复学生姓名），会浪费存储空间，且容易导致数据不一致。 解决：通过拆分表（如学生表、课程表、选课表），每个信息只存一次。 -- 反例：冗余存储学生姓名和课程信息 CREATE TABLE bad_design ( student_id INT, student_name VARCHAR(50), course_name VARCHAR(50), teacher VARCHAR(50) ); -- 遵循范式：拆分为多表 CREATE TABLE students (student_id INT PRIMARY KEY, student_name VARCHAR(50)); CREATE TABLE courses (course_id INT PRIMARY KEY, course_name VARCHAR(50), teacher VARCHAR(50)); CREATE TABLE enrollments (student_id INT, course_id INT); 2. 避免更新异常 问题：冗余数据会导致修改时多处同步。 例如，如果“王老师”的办公室地址在多个课程行中重复存储，修改时漏掉某一行会导致数据不一致。 解决：通过范式拆分后，只需在「教师表」中修改一次。 -- 反范式设计（修改麻烦） UPDATE courses SET teacher_office = 'A栋302' WHERE teacher = '王老师'; -- 范式设计（只需改一处） UPDATE teachers SET office = 'A栋302' WHERE teacher_name = '王老师'; 3. 消除插入和删除异常 问题： 插入异常：无法单独插入未分配课程的教师信息。 删除异常：删除某门课程可能连带删除教师信息。 解决：拆分表后，教师和课程独立存在。 -- 插入异常示例（反范式）： -- 如果“新教师”未授课，无法插入到课程表中。 -- 范式设计下： INSERT INTO teachers (teacher_name, office) VALUES ('赵老师', 'D栋101'); -- 允许独立插入 4. 提高数据一致性 问题：冗余数据可能导致矛盾（如某个课程的学分在不同行中不一致）。 解决：通过范式设计，学分只存储在「课程表」中，所有引用该课程的地方通过外键关联，确保一致性。 -- 反范式设计（学分可能不一致） INSERT INTO bad_table (course_name, credit) VALUES ('数学', 4); INSERT INTO bad_table (course_name, credit) VALUES ('数学', 5); -- 矛盾！ -- 范式设计（学分唯一）： CREATE TABLE courses (course_id INT PRIMARY KEY, credit INT); 5. 增强可维护性 问题：当业务需求变化时（如新增字段），冗余的表结构修改成本高。 解决：范式设计后，表结构清晰，修改只需调整局部。 -- 反范式设计：新增“课程类型”字段需修改所有相关行。 -- 范式设计：只需在「课程表」中加一列。 ALTER TABLE courses ADD COLUMN course_type VARCHAR(20); MySQL 怎么连表查询？ 数据库有以下几种联表查询类型： 内连接(INNERJOIN) 左外连接（LEFTJOIN) 右外连接(RIGHTJOIN) 全外连接(FULLJOIN） 讲讲ACID 这四个特性分别是原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation） 和持久性（Durability）。 ","date":"2026-01-25","objectID":"/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E6%8C%87%E5%8D%97/:8:1","tags":["编程"],"title":"程序员面试指南","uri":"/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E6%8C%87%E5%8D%97/"},{"categories":["编程"],"content":"存储引擎 讲一讲mysql的引擎吧，你有什么了解？ InnoDB：InnoDB是MySQL的默认存储引l擎，具有ACID事务支持、行级锁、外键约束等特性。它适用于 高并发的读写操作，支持较好的数据完整性和并发控制。 MyISAM：MyISAM是MySQL的另一种常见的存储引擎，具有较低的存储空间和内存消耗，适用于大量 读操作的场景。然而，MyISAM不支持事务、行级锁和外键约束，因此在并发写入和数据完整性方面有 一定的限制。 Memory：Memory引l擎将数据存储在内存中，适用于对性能要求较高的读操作，但是在服务器重启或 崩溃时数据会丢失。它不支持事务、行级锁和外键约束。 ","date":"2026-01-25","objectID":"/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E6%8C%87%E5%8D%97/:8:2","tags":["编程"],"title":"程序员面试指南","uri":"/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E6%8C%87%E5%8D%97/"},{"categories":["编程"],"content":"索引 索引有哪些优化手段，讲一下B+树索引 常见优化索引|的方法： 前缀索引优化：使用前缀索引是为了减小索引字段大小，可以增加一个索引顶中存储的索引值，有效提 高索引的查询速度。在一些大字符串的字段作为索引时，使用前缀索引可以帮助我们减小索引项的大 小。 覆盖索引I优化：覆盖索引是指SQL中query的所有字段，在索引|B+Tree的叶子节点上都能找得到的那 些索引，从二级索引中查询得到记录，而不需要通过聚簇索引查询获得，可以避免回表的操作。 主键索引最好是自增的： ​ ○ 如果我们使用自增主键，那么每次插入的新数据就会按顺序添加到当前索引节点的位置，不需要移 ​ 动已有的数据，当页面写满，就会自动开辟一个新页面。因为每次插入一条新记录，都是追加操 ​ 作，不需要重新移动数据，因此这种插入数据的方法效率非常高。 ​ ○ 如果我们使用非自增主键，由于每次插入主键的索引值都是随机的，因此每次插入新的数据时，就 ​ 可能会插入到现有数据页中间的某个位置，这将不得不移动其它数据来满足新数据的插入，甚至需 ​ 要从一个页面复制数据到另外一个页面，我们通常将这种情况称为页分裂。页分裂还有可能会造成 ​ 大量的内存碎片，导致索引结构不紧凑，从而影响查询效率。 防止索引失效： ​ ○ 当我们使用左或者左右模糊匹配的时候，也就是 like%xx 或者 like%xx% 这两种方式都会造成索 ​ 引失效； ​ ○ 当我们在查询条件中对索引列做了计算、函数、类型转换操作，这些情况下都会造成索引失效； ​ ○ 联合索引要能正确使用需要遵循最左匹配原则，也就是按照最左优先的方式进行索引的匹配，否则 ​ 就会导致索引失效。 ​ ○ 在WHERE子句中，如果在OR前的条件列是索引列，而在OR后的条件列不是索引I列，那么索引会 ​ 失效。 如果给每一列都建立一个索引会有什么问题？ 空间占用多，然后写入频繁场景，因为索引要被更新，所以维护B+树付出的性能消耗也大 ","date":"2026-01-25","objectID":"/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E6%8C%87%E5%8D%97/:8:3","tags":["编程"],"title":"程序员面试指南","uri":"/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E6%8C%87%E5%8D%97/"},{"categories":["编程"],"content":"事务 隔离级别 隔离级别 解决的并发问题 读未提交 读提交 脏读 可重复读 不可重复读 串行化 幻读 mvcc解释一下 多版本并发控制 ","date":"2026-01-25","objectID":"/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E6%8C%87%E5%8D%97/:8:4","tags":["编程"],"title":"程序员面试指南","uri":"/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E6%8C%87%E5%8D%97/"},{"categories":["编程"],"content":"锁 讲一下mysql里有哪些锁？ 行级锁：InnoDB引擎是支持行级锁的，而MyISAM引擎并不支持行级锁。 记录锁，锁住的是一条记录。而且记录锁是有S锁和X锁之分的，满足读写互斥，写写互斥 间隙锁，只存在于可重复读隔离级别，目的是为了解决可重复读隔离级别下幻读的现象。 Next-KeyLock称为临键锁，是Record Lock+GapLock的组合，锁定一个范围，并且锁定记录本身。 ","date":"2026-01-25","objectID":"/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E6%8C%87%E5%8D%97/:8:5","tags":["编程"],"title":"程序员面试指南","uri":"/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E6%8C%87%E5%8D%97/"},{"categories":["编程"],"content":"性能调优 慢sql优化 分析查询语句：使用EXPLAIN命令分析SQL执行计划，找出慢查询的原因，比如是否使用了全表扫描，是否存在索引未被利用的情况等，并根据相应情况对索引进行适当修改。 创建或优化索引：根据查询条件创建合适的索引I，特别是经常用于WHERE子句的字段、Orderby排序的字段、Join连表查询的字典、groupby的字段，并且如果查询中经常涉及多个字段，考虑创建联合索引，使用联合索引要符合最左匹配原则，不然会索引失效 **避免索引失效：**比如不要用左模糊匹配、函数计算、表达式计算等等。 查询优化：避免使用SELECT，只查询真正需要的列；使用覆盖索引I，即索引I包含所有查询的字段；联表查询最好要以小表驱动大表，并且被驱动表的字段要有索引，当然最好通过冗余字段的设计，避免联表查询。 **分页优化：**针对limit n,y深分页的查询优化，可以把Limit查询转换成某个位置的查询：selectfrom tb_skuwhere id\u003e20000 limit 10，该方案适用于主键自增的表， 优化数据库表：如果单表的数据超过了干万级别，考虑是否需要将大表拆分为小表，减轻单个表的查询压力。也可以将字段多的表分解成多个表，有些字段使用频率高，有些低，数据量大时，会由于使用频率低的存在而变慢，可以考虑分开。 使用缓存技术：引入缓存层，如Redis，存储热点数据和频繁查询的结果，但是要考虑缓存一致性的问题，对于读请求会选择旁路缓存策略，对于写请求会选择先更新db，再删除缓存的策略。 ","date":"2026-01-25","objectID":"/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E6%8C%87%E5%8D%97/:8:6","tags":["编程"],"title":"程序员面试指南","uri":"/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E6%8C%87%E5%8D%97/"},{"categories":["编程"],"content":"Java基础 final关键字用法 1. final修饰变量 基本类型变量 被final修饰的基本类型变量一旦初始化就不能被修改 必须在声明时或构造函数中初始化 final int MAX_VALUE = 100; // MAX_VALUE = 200; // 编译错误，不能修改final变量 引用类型变量 引用不能改变，但对象内部状态可以改变 final List\u003cString\u003e list = new ArrayList\u003c\u003e(); list.add(\"Hello\"); // 允许 // list = new ArrayList\u003c\u003e(); // 编译错误，不能重新赋值 2. final修饰方法 被final修饰的方法不能被子类重写 常用于防止子类改变方法的行为 class Parent { public final void show() { System.out.println(\"Parent show\"); } } class Child extends Parent { // @Override // public void show() {} // 编译错误，不能重写final方法 } 3. final修饰类 被final修饰的类不能被继承 常用于设计不希望被扩展的类 final class StringUtils { // 工具类方法 } // class MyStringUtils extends StringUtils {} // 编译错误 4. final参数 方法参数被final修饰后，方法内不能修改该参数 public void process(final int value) { // value = 10; // 编译错误 } 5. final与并发编程 final变量在多线程环境下是线程安全的，不需要额外的同步措施 JVM保证final变量的初始化安全 讲解HashMap扩容 在JDK1.7版本之前，HashMap数据结构是数组和链表，HashMap通过哈希算法将元素的键(Key）映射到数组中的槽位（Bucket）。如果多个键映射到同一个槽位，它们会以链表的形式存储在同一个槽位上，因为链表的查询时间是O(n)，所以冲突很严重，一个索引上的链表非常长，效率就很低了。 所以在JDK1.8版本的时候做了优化，当一个链表的长度超过8的时候就转换数据结构，不再使用链表存储，而是使用红黑树，查找时使用红黑树，时间复杂度O(logn），可以提高查询性能，但是在数量较少时，即数量小于6时，会将红黑树转换回链表。 hashMap默认的负载因子是0.75，即如果hashmap中的元素个数超过了总容量75%，则会触发扩容，扩容 分为两个步骤： 第1步是对哈希表长度的扩展（2倍） 第2步是将旧哈希表中的数据放到新的哈希表中。 垃圾回收策略 标记-清除算法：标记-清除算法分为”标记”和“清除”两个阶段，首先通过可达性分析，标记出所有需要回收的对象，然后统一回收所有被标记的对象。标记-清除算法有两个缺陷，一个是效率问题，标记和清除的过程效率都不高，另外一个就是，清除结束后会造成大量的碎片空间。有可能会造成在申请大块内存的时候因为没有足够的连续空间导致再次GC。 复制算法：为了解决碎片空间的问题，出现了“复制算法”。复制算法的原理是，将内存分成两块，每次申请内存时都使用其中的一块，当内存不够时，将这一块内存中所有存活的复制到另一块上。然后将然后再把已使用的内存整个清理掉。复制算法解决了空间碎片的问题。但是也带来了新的问题。因为每次在申请内存时，都只能使用一半的内存空间。内存利用率严重不足。 标记-整理算法：复制算法在GC之后存活对象较少的情况下效率比较高，但如果存活对象比较多时，会执行较多的复制操作，效率就会下降。而老年代的对象在GC之后的存活率就比较高，所以就有人提出了“标记-整理算法”。标记-整理算法的“标记”过程与”标记-清除算法”的标记过程一致，但标记之后不会直接清理。而是将所有存活对象都移动到内存的一端。移动结束后直接清理掉剩余部分。 分代回收算法：分代收集是将内存划分成了新生代和老年代。分配的依据是对象的生存周期，或者说经历过的GC次数。对象创建时，一般在新生代申请内存，当经历一次GC之后如果对还存活，那么对象的年龄+1。当年龄超过一定值(默认是15，可以通过参数-XX:MaxTenuringThreshold来设定)后，如果对象还存活，那么该对象会进入老年代。 讲讲Spring Spring有两个核心模块：IoC和AOP IoC：控制反转，通过 依赖查找（DL） 和 依赖注入（DI） 实现的。指的是将创建的对象交给Spring进行管理。 应用启动时，Spring会创建所有需要管理的对象（称为Bean）并放入IoC容器 开发者通过注解定义对象的创建规则，而非手动new实例 对象之间的依赖关系由Spring自动处理 AOP：面向切面编程，通过动态代理技术实现，能够在不修改原有代码的情况下，为程序横向添加通用功能（如日志、事务、权限等）。 讲讲线程池原理 在实际项目中，线程池是我最常用的并发编程工具之一。以下是我使用线程池的经验和最佳实践： 1. 线程池的创建 我通常使用ThreadPoolExecutor来创建线程池，而不是直接使用Executors的工厂方法，因为这样可以更灵活地控制参数： // 推荐方式：明确指定所有参数 ThreadPoolExecutor executor = new ThreadPoolExecutor( corePoolSize, // 核心线程数 maximumPoolSize, // 最大线程数 keepAliveTime, // 空闲线程存活时间 TimeUnit.SECONDS, // 时间单位 new LinkedBlockingQueue\u003c\u003e(queueCapacity), // 工作队列 new CustomThreadFactory(), // 自定义线程工厂 new CustomRejectedExecutionHandler() // 自定义拒绝策略 ); 2. 参数配置经验 ‌核心线程数‌：通常设置为CPU核心数的1-2倍（CPU密集型任务）或更多（IO密集型任务） ‌最大线程数‌：IO密集型可设置较高（如核心数的2-4倍），CPU密集型不宜过高 ‌队列容量‌：根据业务特点设置，高吞吐场景用大队列，低延迟场景用小队列 ‌拒绝策略‌：根据业务需求选择或自定义（记录日志、降级处理等） 讲讲讲一下threadlocal的原理，threadlocal存在的问题? 如果两个服务需要传递threadlocal中的值例如用户ID该如何传递 你知道哪些JVM的垃圾回收器 Serial收集器（复制算法): 新生代单线程收集器，标记和清理都是单线程，优点是简单高效； Parallel GC（并行垃圾回收器): G1(Garbage First)收集器 (标记-整理算法) Java的类加载机制是怎么样的 加载（Loading） 通过类的全限定名获取二进制字节流 将字节流转换为方法区的运行时数据结构 在堆中生成代表该类的Class对象 验证（Verification） 文件格式验证（魔数、版本号等） 元数据验证（语义分析） 字节码验证（确保方法不会危害JVM） 符号引用验证（确保解析能正确执行） 准备（Preparation） 为类变量（static变量）分配内存并设置初始值（零值） 注意：final static变量在此阶段直接赋值为代码中的值 解析（Resolution） 将常量池内的符号引用替换为直接引用 初始化（Initialization） 执行类构造器\u003cclinit\u003e()方法（包含static变量赋值和static代码块） 父类的\u003cclinit\u003e先于子类执行 讲讲AQS 可重入锁是指同一个线程在获取了锁之后，可以再次重复获取该锁而不会造成死锁或其他问题。当一个线 程持有锁时，如果再次尝试获取该锁，就会成功获取而不会被阻塞。 ReentrantLock实现可重入锁的机制是基于线程持有锁的计数器。 ·当一个线程第一次获取锁时，计数器会加1，表示该线程持有了锁。在此之后，如果同一个线程再次获 取锁，计数器会再次加1。每次线程成功获取锁时，都会将计数器加1。 ·当线程释放锁时，计数器会相应地减1。只有当计数器减到0时，锁才会完全释放，其他线程才有机会 获取锁。 这种计数器的设计使得同一个线程可以多次获取同一个锁，而不会造成死锁或其他问题。每次获取锁时， 计数器加1；每次释放锁时，计数器减1。只有当计数器减到0时，锁才会完全释放。 ReentrantLock通过这种计数器的方式，实现了可重入锁的机制。它允许同一个线程多次获取同一个锁， 并且能够正确地处理锁的获取和释放，避免了死锁和其他并发问题。 讲讲内存区域 img 静态变量放哪,不同进程压栈在一个共用栈还是私有栈？ 私有栈 ","date":"2026-01-25","objectID":"/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E6%8C%87%E5%8D%97/:9:0","tags":["编程"],"title":"程序员面试指南","uri":"/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E6%8C%87%E5%8D%97/"},{"categories":["编程"],"content":"Redis ","date":"2026-01-25","objectID":"/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E6%8C%87%E5%8D%97/:10:0","tags":["编程"],"title":"程序员面试指南","uri":"/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E6%8C%87%E5%8D%97/"},{"categories":["编程"],"content":"redis了解过吗，有哪些应用？ Redis（Remote Dictionary Server）是一款高性能的‌内存数据库‌，支持多种数据结构，常用于解决高并发、低延迟场景下的数据管理问题。以下是其核心特性及典型应用场景： ‌一、Redis的核心优势‌ ‌内存存储‌：数据读写速度达微秒级（10万+ QPS），远超传统磁盘数据库。 ‌丰富的数据结构‌：支持字符串（String）、哈希（Hash）、列表（List）、集合（Set）、有序集合（ZSet）、流（Stream）等，覆盖多样化场景。 ‌持久化机制‌：通过‌RDB快照‌和‌AOF日志‌实现数据持久化，保障宕机后数据可恢复。 ‌高可用性‌：支持主从复制、哨兵（Sentinel）、集群（Cluster）模式，满足高可用需求。 ‌二、Redis的6大典型应用场景‌ ‌**1. 缓存（Cache）**‌ ‌问题‌：数据库读写速度慢，无法应对高并发请求。 ‌方案‌：将热点数据（如商品详情、用户信息）缓存到Redis，降低数据库负载。 ‌实现‌： bashCopy Code# 设置缓存（带30分钟过期时间） SET product:1001 \"{name: 'Phone', price: 5999}\" EX 1800 # 查询缓存 GET product:1001 ‌优化技巧‌： 缓存穿透：布隆过滤器（Bloom Filter）拦截无效请求。 缓存雪崩：随机化过期时间，避免集中失效。 ‌**2. 会话存储（Session Storage）**‌ ‌问题‌：分布式系统中用户会话需跨服务共享。 ‌方案‌：用Redis集中存储会话数据（如登录状态、购物车）。 ‌实现‌： bashCopy Code# 存储用户会话 HSET session:user123 token \"abc123\" cart \"[{id: 1, count: 2}]\" # 设置30分钟过期 EXPIRE session:user123 1800 ‌3. 排行榜与计数器‌ ‌问题‌：实时更新排名（如游戏积分榜、热搜词）。 ‌方案‌：利用有序集合（ZSet）按分数排序。 ‌实现‌： bashCopy Code# 添加玩家得分 ZADD leaderboard 5000 \"player1\" 4800 \"player2\" # 获取前10名 ZREVRANGE leaderboard 0 9 WITHSCORES ‌4. 消息队列‌ ‌问题‌：服务间异步通信需求（如订单支付后通知物流）。 ‌方案‌：使用列表（List）或Stream实现轻量级队列。 ‌实现（List）‌： bashCopy Code# 生产者推送消息 LPUSH order:queue \"order1001\" # 消费者阻塞获取 BRPOP order:queue 30 ‌高级场景‌：Stream支持消费者组（Consumer Group），类似Kafka的分区消费。 ‌5. 分布式锁‌ ‌问题‌：多实例服务竞争资源时需互斥访问（如秒杀扣库存）。 ‌方案‌：通过SETNX或RedLock实现分布式锁。 ‌实现（SETNX）‌： bashCopy Code# 加锁（设置唯一值防误删） SET lock:stock 1 NX EX 10 # 释放锁（Lua脚本保证原子性） EVAL \"if redis.call('get', KEYS) == ARGV then return redis.call('del', KEYS) else return 0 end\" 1 lock:stock 1 ‌6. 实时数据分析‌ ‌问题‌：高频数据实时统计（如在线人数、UV/PV）。 ‌方案‌：通过HyperLogLog统计基数，Bitmap记录用户行为。 ‌实现： bashCopy Code# HyperLogLog统计UV（误差率0.81%） PFADD uv:20231001 user1 user2 user3 PFCOUNT uv:20231001 # Bitmap记录用户签到 SETBIT sign:user123:202310 5 1 # 第5天签到 BITCOUNT sign:user123:202310 # 当月签到次数 ‌三、Redis vs 其他技术选型对比‌ ‌场景‌ ‌Redis优势‌ ‌替代方案‌ 缓存 数据结构灵活，支持过期时间、持久化 Memcached（纯缓存，无持久化） 消息队列 轻量级，支持Stream的消费者组 Kafka/RabbitMQ（高吞吐） 分布式锁 原子操作简单易用 ZooKeeper（强一致性） 实时统计 HyperLogLog节省内存，适合大数据量 Flink/Spark（复杂计算） ‌四、Redis的局限性‌ ‌内存成本高‌：数据量过大时需权衡成本（如冷数据归档到磁盘库）。 ‌持久化性能损耗‌：AOF的fsync always模式会降低吞吐量。 ‌事务非强一致‌：Redis事务不支持回滚（通过Lua脚本弥补）。 ‌总结‌ Redis凭借‌内存速度‌和‌数据结构多样性‌，成为高并发系统的核心组件，适用于缓存、会话管理、实时排行榜等场景。实际应用中需结合业务特点选择数据结构，并合理设计过期策略、持久化配置及高可用方案（如集群部署）。 ","date":"2026-01-25","objectID":"/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E6%8C%87%E5%8D%97/:10:1","tags":["编程"],"title":"程序员面试指南","uri":"/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E6%8C%87%E5%8D%97/"},{"categories":["编程"],"content":"redis常用数据结构 1. 字符串（String） 底层实现：简单动态字符串（SDS, Simple Dynamic String） 特点： 预分配内存空间，减少修改时的内存重分配次数。 二进制安全（可存储任意二进制数据，如 \\0）。 直接存储长度（O(1) 复杂度获取长度）。 结构体： struct sdshdr { int len; // 已用长度 int free; // 空闲空间 char buf[]; // 字符数组 }; 2. 列表（List） 底层实现：QuickList（Redis 3.2+） 设计：双向链表 + 压缩列表（或 listpack）的混合结构。 特点： 每个节点是一个压缩列表（ziplist）或 listpack，平衡内存连续性和插入性能。 支持双向遍历，适合实现队列、栈等结构。 旧版本：小规模数据使用 ziplist，大规模数据使用 双向链表。 3. 哈希（Hash） 底层实现： 小规模数据：Listpack（Redis 7.0+）或 ziplist（旧版本）。 大规模数据：哈希表（Dict），采用链式冲突解决和渐进式 Rehash。 转换条件： hash-max-listpack-entries（默认 512）：键值对数量阈值。 hash-max-listpack-value（默认 64字节）：单个值的最大字节。 4. 集合（Set） 底层实现： 纯整数且元素少：IntSet（整数数组，有序且紧凑）。 其他情况：哈希表（Dict），键为元素，值为 NULL。 转换条件：由 set-max-intset-entries 控制（默认 $512$）。 5. 有序集合（ZSet） 底层实现： 小规模数据：Listpack（Redis $7.0$+）或 ziplist（旧版本），按分值排序。 大规模数据：跳表（SkipList） + 哈希表（Dict）。 跳表：支持 O(logN) 范围查询（如 ZRANGE）。 哈希表：存储 成员 -\u003e 分值 的映射，实现 O(1) 单元素查询。 转换条件： zset-max-listpack-entries（默认 $128$ ）：元素数量阈值。 zset-max-listpack-value（默认 $64$ 字节）：成员最大长度。 6. 其他结构 Streams：基数树（Rax Tree）实现消息队列，支持多播。 HyperLogLog：稀疏和密集两种编码，用于基数统计。 位图（Bitmap）：基于 SDS 字符串的位操作。 地理空间（GEO）：使用 ZSet 存储 GeoHash 编码的位置。 ","date":"2026-01-25","objectID":"/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E6%8C%87%E5%8D%97/:10:2","tags":["编程"],"title":"程序员面试指南","uri":"/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E6%8C%87%E5%8D%97/"},{"categories":["编程"],"content":"redis的高可用性方案有哪些，具体讲一讲 1. 主从复制（Replication） 原理： 主节点（Master）处理写请求，并将数据异步复制到多个从节点（Slave）。 从节点默认只读，用于负载均衡读请求。 优点： 数据冗余：从节点提供数据备份。 读写分离：分担主节点的读压力。 缺点： 非高可用：主节点宕机后需手动切换到从节点。 异步复制：存在数据丢失风险（主节点宕机时未同步的数据会丢失）。 配置示例： # 在从节点配置文件中指定主节点 replicaof \u003cmaster-ip\u003e \u003cmaster-port\u003e 2. 哨兵模式（Sentinel） 原理： 哨兵（Sentinel） 是一个独立的进程集群，监控主从节点的健康状态。 当主节点不可用时，哨兵通过投票机制自动选举一个从节点升级为新主节点，并通知客户端和从节点更新配置。 核心功能： 监控：定期检测节点状态。 自动故障转移（Failover）。 配置中心：客户端通过哨兵获取当前主节点地址。 工作流程： 主观下线：单个哨兵认为主节点不可用。 客观下线：多个哨兵（满足 quorum 数）确认主节点故障。 选举领导者哨兵：执行故障转移操作。 切换主节点：选择数据最新的从节点成为新主。 优点： 自动故障转移，无需人工干预。 支持多哨兵部署，避免单点故障。 缺点： 写操作单点：主节点仍是性能瓶颈。 扩展性有限：分片需客户端自行实现。 配置示例： # Sentinel 配置文件 sentinel monitor mymaster 127.0.0.1 6379 2 # 监控名为 mymaster 的主节点，2 表示至少 2 个哨兵确认故障 sentinel down-after-milliseconds mymaster 5000 # 5 秒无响应视为下线 3. Redis Cluster（集群模式） 原理： 数据分片：将数据按哈希槽（Hash Slot，共 16384 个）分配到多个主节点。 多主多从：每个主节点有 1 到多个从节点，主节点故障时从节点自动接替。 Gossip 协议：节点间通过 P2P 通信同步状态和拓扑信息。 核心特性： 自动分片：客户端直连任意节点，由节点返回正确路由（MOVED/ASK 重定向）。 高可用：主节点故障时，从节点自动晋升为新主。 线性扩展：支持动态增删节点，哈希槽重新分配。 优点： 去中心化：无单点瓶颈。 高可用与高扩展性：适合大规模分布式场景。 缺点： 客户端兼容性：需支持 Cluster 协议的客户端（如 Jedis Cluster）。 功能限制：跨槽事务、多键操作受限（需使用 Hash Tag 保证 key 在同一槽）。 配置示例： # 启动集群节点 redis-server --cluster-enabled yes --cluster-config-file nodes.conf # 创建集群（3 主 3 从） redis-cli --cluster create 127.0.0.1:7000 127.0.0.1:7001 ... --cluster-replicas 1 ","date":"2026-01-25","objectID":"/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E6%8C%87%E5%8D%97/:10:3","tags":["编程"],"title":"程序员面试指南","uri":"/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E6%8C%87%E5%8D%97/"},{"categories":["编程"],"content":"缓存雪崩、击穿、穿透是什么？怎么解决？ 在分布式系统中，缓存是提升性能和降低数据库压力的重要手段，但缓存使用不当可能导致‌雪崩、击穿、穿透‌三大经典问题。以下是它们的核心定义、原因及解决方案： ‌**1. 缓存雪崩（Cache Avalanche）**‌ ‌定义‌ ‌大量缓存数据在同一时间失效或者Redis故障宕机‌，导致所有请求直接穿透到数据库，引发数据库瞬时高负载甚至崩溃。 ‌类比‌：多个水库同时决堤，洪水直接冲击下游村庄。 ‌原因‌ 缓存数据设置了相同的过期时间（例如批量预热缓存时未添加随机因子）。 缓存服务整体宕机（如 Redis 集群故障）。 ‌解决方案‌ ‌差异化过期时间‌ 在缓存过期时间基础上添加随机值（例如 TTL = 基础时间 + 随机分钟），避免同时失效。 ‌互斥锁重建缓存‌ 当缓存失效时，使用分布式锁（如 Redis 的 SETNX）控制只有一个线程重建缓存，其他线程等待后重试。 ‌熔断降级与限流 在数据库层面设置熔断机制（如 Hystrix），或使用限流工具（如 Sentinel）控制请求流量。 ‌缓存集群高可用 使用 Redis Cluster 或哨兵模式（Sentinel）避免单点故障。 ‌**2. 缓存击穿（Cache Breakdown）**‌ ‌定义‌ ‌某个热点数据过期后，大量并发请求同时穿透缓存，直接访问数据库‌。 ‌类比‌：一颗子弹击穿防弹衣，所有攻击集中在一个点。 ‌原因‌ 热点数据过期（例如明星绯闻、秒杀商品信息）。 高并发请求集中在同一数据上。 ‌解决方案‌ ‌热点数据永不过期 缓存不设置过期时间，通过异步线程定期更新（例如每 10 分钟刷新一次）。 ‌互斥锁重建缓存 类似缓存雪崩的解决方案，使用分布式锁避免多个线程同时重建缓存。 ‌逻辑过期 缓存中存储数据的逻辑过期时间（例如字段 expire_time），业务层判断是否需异步更新。 ‌请求合并 将多个并发请求合并为一个数据加载任务（如本地队列或消息队列）。 ‌**3. 缓存穿透（Cache Penetration）**‌ ‌定义‌ ‌查询不存在的数据（如非法 ID），绕过缓存直接访问数据库‌。 ‌类比‌：攻击者绕过城墙，直接挖掘隧道攻击城内。 ‌原因‌ 恶意攻击或业务逻辑缺陷（例如频繁查询不存在的用户 ID）。 数据库和缓存均未存储该数据，导致每次请求都穿透到数据库。 ‌解决方案‌ ‌缓存空值（Null Cache） 对查询结果为空的请求，缓存一个短时间空值（例如 key: -1, TTL=5 分钟）。 ‌布隆过滤器（Bloom Filter） 在缓存层前添加布隆过滤器，快速判断数据是否存在： 若布隆过滤器判定数据不存在，直接返回空结果。 若判定存在，再查询缓存或数据库。 ‌接口校验与限流 对请求参数进行合法性校验（如 ID 必须为数字），拦截非法请求。 对高频 IP 或用户进行限流或黑名单拦截。 ‌实时监控与防御 监控数据库慢查询日志，识别异常请求模式（如大量 404 请求）。 ‌三者的核心区别‌ ‌问题类型‌ ‌触发条件‌ ‌影响范围‌ ‌典型场景‌ 缓存雪崩 大量缓存同时失效 全局性数据库压力 批量缓存预热、缓存集群宕机 缓存击穿 单个热点数据失效 单点数据库压力 秒杀商品、热点新闻 缓存穿透 查询不存在的数据 无效请求消耗资源 恶意攻击、参数伪造 ‌实战案例‌ ‌电商秒杀场景‌ ‌雪崩‌：秒杀开始时所有商品缓存同时失效 → 使用随机 TTL + 互斥锁。 ‌击穿‌：某热门商品缓存过期 → 逻辑过期 + 请求合并。 ‌穿透‌：恶意刷不存在的商品 ID → 布隆过滤器 + 空值缓存。 ‌社交网络热点事件‌ 明星热搜数据缓存失效 → 永不过期 + 异步更新。 ","date":"2026-01-25","objectID":"/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E6%8C%87%E5%8D%97/:10:4","tags":["编程"],"title":"程序员面试指南","uri":"/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E6%8C%87%E5%8D%97/"},{"categories":["编程"],"content":"大key是什么意思呢？怎么解决 ","date":"2026-01-25","objectID":"/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E6%8C%87%E5%8D%97/:10:5","tags":["编程"],"title":"程序员面试指南","uri":"/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E6%8C%87%E5%8D%97/"},{"categories":["编程"],"content":"Zset的底层数据结构 ","date":"2026-01-25","objectID":"/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E6%8C%87%E5%8D%97/:10:6","tags":["编程"],"title":"程序员面试指南","uri":"/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E6%8C%87%E5%8D%97/"},{"categories":["编程"],"content":"Redis 的 ZSet 为何选择跳表（Skip List）而非红黑树？ Redis 的有序集合（ZSet）底层默认使用 跳表（Skip List） 和 哈希表 的组合实现（当元素较少或成员是长字符串时，可能使用压缩列表）。选择跳表而非红黑树，主要基于以下几点原因： 1. 查询性能的权衡 跳表的查询复杂度：平均 O(log⁡n)O(logn)，最坏 O(n)O(n)（但概率极低，通过合理的随机层数控制可避免）。 红黑树的查询复杂度：严格 O(log⁡n)O(logn)。 虽然两者在理论上都是对数级别，但跳表的实际查询效率接近红黑树，且实现更简单。 2. 插入和删除操作的效率 跳表的插入/删除： 平均 O(log⁡n)O(logn)，仅需局部调整相邻节点的指针。 无需复杂的再平衡（红黑树需要旋转和变色）。 红黑树的插入/删除： 虽然也是 O(log⁡n)O(logn)，但需要处理复杂的平衡逻辑（旋转和变色），代码实现更复杂。 跳表的优势：在高并发场景下，跳表的局部修改特性更容易实现无锁优化（Redis 6.0 的多线程 I/O 对命令处理仍是单线程，但跳表为未来可能的扩展留了余地）。 3. 范围查询的高效性 跳表：天然支持有序遍历，范围查询（如 ZRANGE）只需遍历链表，时间复杂度 O(log⁡n+m)O(logn+m)（mm 为返回的元素数量）。 红黑树：范围查询需要中序遍历，实现较复杂，且缓存局部性不如跳表。 Redis 的场景需求：ZSet 常用于排行榜、区间查询（如分数范围），跳表的顺序访问特性更契合。 4. 实现复杂度 跳表：实现简单，约 200 行代码即可完成核心逻辑，调试和维护成本低。 红黑树：实现复杂，需处理多种旋转和变色情况，容易出错。 Redis 的设计哲学：优先选择简单、高效的数据结构，跳表在性能和实现复杂度之间取得了更好的平衡。 5. 内存占用 跳表：通过随机层数（通常概率为 1/21/2），平均每个节点只需 1.33 个额外指针（相比红黑树的左右子节点指针，内存开销接近）。 红黑树：每个节点需存储颜色标志、左右子节点指针，实际内存占用与跳表差异不大。 6. 并发优化的潜力 跳表：可以通过细粒度的锁或无锁编程（如 CAS）优化并发修改。 红黑树：平衡操作涉及全局结构调整，并发优化难度大。 为什么不是所有场景都用跳表？ 红黑树的优势：严格平衡，查询性能更稳定（跳表的层数依赖随机数）。 其他数据库的选择：如 MySQL 的索引使用 B+ 树（磁盘友好），而内存数据库（如 Redis）优先考虑内存操作效率。 总结 Redis 选择跳表而非红黑树，核心原因是： 插入/删除更高效：无需再平衡，适合高频写操作。 范围查询更优：直接遍历链表即可。 实现简单：降低代码维护成本。 契合场景：ZSet 的典型操作（如排行榜）更依赖顺序访问。 虽然红黑树的查询性能理论上更稳定，但跳表在综合性能、实现复杂度和功能需求上更胜一筹。 ","date":"2026-01-25","objectID":"/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E6%8C%87%E5%8D%97/:10:7","tags":["编程"],"title":"程序员面试指南","uri":"/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E6%8C%87%E5%8D%97/"},{"categories":["编程"],"content":"消息队列 mq了解过吗？解决哪些问题 消息队列（Message Queue, MQ）是分布式系统中广泛使用的中间件技术，主要用于解决系统间的‌异步通信、解耦、流量削峰‌等问题。以下是消息队列的核心作用、典型场景及主流产品对比： ‌一、消息队列解决的4大核心问题‌ 1. ‌系统解耦‌ ‌问题‌：服务间直接调用（如RPC）会导致强耦合，任一服务宕机或变更可能引发连锁故障。 ‌解决方案‌：生产者将消息发送到MQ，消费者独立订阅并处理，双方无需感知彼此的存在。 ‌场景‌： 电商订单系统：订单服务生成订单后，通过MQ通知库存服务扣减库存、支付服务处理支付，各服务独立演进。 用户注册：注册服务完成数据写入后，通过MQ触发发送欢迎邮件、初始化用户画像等操作。 2. ‌异步处理‌ ‌问题‌：同步阻塞调用（如HTTP请求）导致响应延迟，资源利用率低。 ‌解决方案‌：非关键流程异步化，生产者发送消息后立即返回，消费者异步处理。 ‌场景‌： 用户下单后，前端立即返回“订单创建成功”，后台异步处理物流调度、短信通知等耗时操作。 视频上传：用户上传视频后，系统异步进行转码、审核、生成缩略图等操作。 3. ‌流量削峰‌ ‌问题‌：突发流量（如秒杀活动）超过下游系统处理能力，导致服务崩溃。 ‌解决方案‌：MQ作为缓冲区，平滑流量峰值，按下游处理能力消费消息。 ‌场景‌： 秒杀系统：瞬间涌入的10万请求写入MQ，库存服务按每秒1000件的速率消费，避免数据库被击穿。 日志收集：业务高峰期的日志批量写入MQ，下游日志分析服务逐步消费。 4. ‌数据最终一致性‌ ‌问题‌：分布式事务实现复杂，跨服务数据一致性难以保证。 ‌解决方案‌：通过MQ的可靠投递和重试机制，结合本地事务表，实现最终一致性。 ‌场景‌： 跨行转账：A银行扣款成功后，通过MQ通知B银行入账，若失败则重试直到成功。 订单状态同步：订单支付成功后，通过MQ同步状态至物流系统，确保双方数据最终一致。 ‌二、消息队列的典型应用场景‌ ‌场景‌ ‌技术实现‌ ‌代表MQ‌ 实时日志处理 日志采集 -\u003e MQ -\u003e 流式计算（Flink/Spark） Kafka 微服务异步通信 服务间通过MQ解耦，如订单通知库存 RabbitMQ 金融交易消息分发 高可靠事务消息、顺序消息 RocketMQ IoT设备数据采集 海量设备数据汇聚与分发 EMQX（MQTT协议） ‌三、主流消息队列对比‌ ‌产品‌ ‌吞吐量‌ ‌延迟‌ ‌可靠性‌ ‌适用场景‌ ‌核心特性‌ ‌Kafka‌ 超高 毫秒级 高（持久化） 日志收集、大数据流处理 分区顺序性、持久化存储、高吞吐 ‌RabbitMQ‌ 中 微秒级 高 企业级异步通信、复杂路由 灵活的路由规则、ACK机制、死信队列 ‌RocketMQ‌ 高 毫秒级 极高 金融交易、订单处理 事务消息、顺序消息、消息回溯 ‌ActiveMQ‌ 低 毫秒级 中 小型系统、传统JMS应用 支持JMS协议、多语言客户端 ‌Pulsar‌ 高 毫秒级 高 多租户消息平台、云原生场景 分层存储、低延迟、多租户隔离 ","date":"2026-01-25","objectID":"/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E6%8C%87%E5%8D%97/:11:0","tags":["编程"],"title":"程序员面试指南","uri":"/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E6%8C%87%E5%8D%97/"},{"categories":["编程"],"content":"分布式 ","date":"2026-01-25","objectID":"/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E6%8C%87%E5%8D%97/:12:0","tags":["编程"],"title":"程序员面试指南","uri":"/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E6%8C%87%E5%8D%97/"},{"categories":["编程"],"content":"1. CAP为什么只能同时满足两个？ CAP定理指出，在分布式系统中，一致性（Consistency）、可用性（Availability）、分区容错性（Partition Tolerance） 三者无法同时满足，最多只能实现其中两个。其核心原因是 网络分区（Network Partition）是分布式系统的必然风险，而面对分区时，系统必须做出取舍。 通俗解释： 想象一个分布式系统有两个节点A和B，存储同一份数据。 场景1：网络正常 A和B可以通信，系统可以同时保证一致性（数据相同）和可用性（都能响应请求）。 场景2：网络断开（分区） A和B无法通信，此时系统必须选择： 选择一致性（CP）：如果用户写入A，但A无法同步到B，则系统会拒绝写入或阻塞，保证数据一致，但牺牲可用性（用户可能无法得到响应）。 选择可用性（AP）：允许用户继续读写A和B，但可能导致数据不一致（A和B的数据不同）。 技术本质： 分区是客观存在的：网络故障无法完全避免（如光纤被挖断、交换机故障）。 一致性与可用性矛盾： 要保证一致性，必须所有节点达成共识（需通信），但分区时无法通信，只能阻塞或拒绝请求（牺牲可用性）。 要保证可用性，必须允许节点独立响应，但可能返回旧数据（牺牲一致性）。 CAP的常见取舍： 选择 典型系统 场景 CP ZooKeeper、etcd 金融交易、配置管理（强一致性） AP Cassandra、Redis 社交网络、实时统计（高可用） CA 单机数据库（如MySQL） 无分区的单点系统（非分布式） ","date":"2026-01-25","objectID":"/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E6%8C%87%E5%8D%97/:12:1","tags":["编程"],"title":"程序员面试指南","uri":"/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E6%8C%87%E5%8D%97/"},{"categories":["编程"],"content":"设计模式 ","date":"2026-01-25","objectID":"/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E6%8C%87%E5%8D%97/:13:0","tags":["编程"],"title":"程序员面试指南","uri":"/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E6%8C%87%E5%8D%97/"},{"categories":["编程"],"content":"单例模式 在Java中，单例模式确保一个类只有一个实例，并提供一个全局访问点。以下是几种常见的单例模式实现方式及其适用场景： 1. 饿汉式（线程安全） 特点：类加载时立即初始化实例，简单但可能浪费资源。 public class Singleton { private static final Singleton instance = new Singleton(); private Singleton() {} public static Singleton getInstance() { return instance; } } 2. 懒汉式（线程不安全 → 需加锁） 特点：延迟初始化，需解决多线程安全问题。 public class Singleton { private static Singleton instance; private Singleton() {} public static synchronized Singleton getInstance() { if (instance == null) { instance = new Singleton(); } return instance; } } 3. 双重检查锁定（DCL，线程安全） 特点：减少同步开销，需用 volatile 防止指令重排序。 public class Singleton { private static volatile Singleton instance; private Singleton() {} public static Singleton getInstance() { if (instance == null) { // 第一次检查 synchronized (Singleton.class) { // 同步锁 if (instance == null) { // 第二次检查 instance = new Singleton(); } } } return instance; } } 关键点： volatile 防止 new Singleton() 的指令重排序。 双重检查减少同步块执行次数。 单例模式使用场景有哪些呢？举个例子 ","date":"2026-01-25","objectID":"/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E6%8C%87%E5%8D%97/:13:1","tags":["编程"],"title":"程序员面试指南","uri":"/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E6%8C%87%E5%8D%97/"},{"categories":["编程"],"content":"AI Infra 写在 AI Infra 大基建的黄金时代 ","date":"2026-01-25","objectID":"/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E6%8C%87%E5%8D%97/:14:0","tags":["编程"],"title":"程序员面试指南","uri":"/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E6%8C%87%E5%8D%97/"},{"categories":["编程"],"content":"训练 大模型算法和训推框架基础：B站视频@ZOMI酱和@五道口纳什 ","date":"2026-01-25","objectID":"/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E6%8C%87%E5%8D%97/:14:1","tags":["编程"],"title":"程序员面试指南","uri":"/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E6%8C%87%E5%8D%97/"},{"categories":["编程"],"content":"推理 vLLM 大模型推理框架 一篇入门好文，来自百度内网：从PagedAttention到调度器：vLLM高效推理全链路揭秘 ","date":"2026-01-25","objectID":"/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E6%8C%87%E5%8D%97/:14:2","tags":["编程"],"title":"程序员面试指南","uri":"/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E6%8C%87%E5%8D%97/"},{"categories":["编程"],"content":"LLM ","date":"2026-01-25","objectID":"/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E6%8C%87%E5%8D%97/:15:0","tags":["编程"],"title":"程序员面试指南","uri":"/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E6%8C%87%E5%8D%97/"},{"categories":["编程"],"content":"Transformer 讲讲Transformer模型 注意力计算可表示为： $$ \\text{Attention}(Q, K, V) = \\text{softmax}\\left(\\frac{QK^T}{\\sqrt{d_k}}\\right)V $$ What the Single-Head Attention really is? ​ Transformer的第一步是将输入的每一个token通过 embedding 转换成一个高维空间中的嵌入向量 $\\overrightarrow {E_i}$。Transformer的目标是将逐步调整 $\\overrightarrow {E_i}$ 使得它们不单单编码单个token，还能融入更丰富的上下文含义。就比如一个名词会问前面的词中有没有形容词啊，这样的提问就被编码成了所谓的查询向量 $\\overrightarrow {Q_i}$。而前面的词想要回答后面的哪些查询提问，则被编码成了所谓的键向量 $\\overrightarrow {K_i}$。所以这个 $\\overrightarrow {Q_i}$ 和 $\\overrightarrow {K_i}$ 的点积和的大小，就是衡量每个键和每个查询的匹配程度。而前面的一个比如形容词，需要把后面的名词调整到什么程度，就被编码成了所谓的值向量 $\\overrightarrow {V_i}$。所以将上面计算出来的每一个查询的匹配程度，通过softmax函数转换成一个概率分布向量，作为权值再乘以值向量 $\\overrightarrow {V_i}$，将上面的这个结果进行求和，得到的就是嵌入向量的调整值 $\\Delta\\overrightarrow { E_i}$，再将调整值加到原始嵌入向量上，便得到一个编码了更丰富的上下文信息的向量 $\\overrightarrow {E_i} + \\Delta\\overrightarrow { E_i}=\\overrightarrow {E_i^{\\prime}}$。 $\\overrightarrow {E_i}$：嵌入向量。初始嵌入向量只编码了该token的含义以及该词的位置信息，和上下文没有关联。（在GPT3中是 $12288$ 维） $Q$：由查询向量 $\\overrightarrow {Q_i}$ 组成的查询矩阵。通过使用一个查询投影矩阵 $W_Q$ 乘以嵌入向量 $\\overrightarrow {E_i}$ 得到查询向量 $\\overrightarrow {Q_i}$。（注意：$\\overrightarrow {Q_i}$ 的维度要比 $\\overrightarrow {E_i}$ 小的多，例如只有 $128$ 维，所以它会将嵌入向量映射到低维度空间） $K$：由键向量 $\\overrightarrow {K_i}$ 组成的键矩阵。通过使用一个键投影矩阵 $W_K$ 乘以嵌入向量 $\\overrightarrow {E_i}$ 得到键向量 $\\overrightarrow {K_i}$。 $d_k$：查询向量 $\\overrightarrow {Q_i}$ 和键向量 $\\overrightarrow {K_i}$ 的维度。 $\\text{softmax}()$：将数值向量归一化为一个概率分布向量。 $V$：由值向量 $\\overrightarrow {V_i}$ 组成的值矩阵。通过使用一个值投影矩阵 $W_V$ 乘以嵌入向量 $\\overrightarrow {E_i}$ 得到值向量 $\\overrightarrow {V_i}$。 大模型届的Github网站huggingface 通过下一个词如果输出了结束标记符就停止，或者操作模型输出的最大值maxlength也会停。 大模型返回结果不要用JSON，而是使用XML，返回结果出错概率更低。 知识星球：大模型面试宝典（作为学习指南，而不是像小林coding那种八股） agentscope agent开发方向项目： 智能客服 复现一下openmanus的本地部分 Transformer时间复杂度是多少呢 Transformer模型的时间复杂度主要由其核心组件自注意力机制和**前馈网络（FFN）**决定。以下是详细分析： 1. 自注意力机制的时间复杂度 自注意力机制的核心是计算查询（Q）、键（K）、值（V）矩阵的交互： 输入：序列长度 nn，每个 token 的维度 dd。 计算步骤： QKᵀ 矩阵乘法：计算 Q⋅KTQ⋅K**T，时间复杂度为 O(n2d)O(n2d)。 Softmax 和缩放：时间复杂度 O(n2)O(n2)，可忽略。 与 V 矩阵乘法：将注意力权重与 VV 相乘，时间复杂度 O(n2d)O(n2d)。 总时间复杂度：O(n2d)O(n2d)。 多头注意力（Multi-Head Attention）通过将 dd 拆分为 hh 个头（每个头维度 d/hd/h），但总时间复杂度仍保持 O(n2d)O(n2d)，因为每个头的计算量总和与原单头一致。 2. 前馈网络（FFN）的时间复杂度 输入：序列长度 nn，维度 dd。 结构：两个线性层（通常从 dd 扩展到 4d4d 再压缩回 dd）。 时间复杂度：O(nd2)O(n**d2)（每个 token 独立计算）。 3. 整个 Transformer 层的复杂度 每个 Transformer 层包含 1 个自注意力 + 1 个 FFN： 单层时间复杂度：O(n2d+nd2)O(n2d+n**d2)。 L 层模型总复杂度：O(Ln2d+Lnd2)O(L**n2d+Lnd2)。 4. 主导项分析 当 n≫d*n*≫*d*（长文本场景）：主导项为 O(Ln2d)O(L**n2d)。 当 d≫n*d*≫*n*（高维特征场景）：主导项为 O(Lnd2)O(Lnd2)。 5. 与其他模型的对比 模型 时间复杂度 并行性 Transformer O(n2d)O(n2d) 完全并行 RNN O(nd2)O(n**d2) 无法并行 CNN O(knd2)O(kn**d2) 局部并行 Transformer 的劣势：序列长度 nn 的平方增长导致长文本计算代价高。 改进方案：稀疏注意力（如 Longformer）、分块计算（如 Reformer）等优化方法可降低复杂度至 O(nlog⁡n)O(nlogn) 或线性 O(n)O(n)。 总结 Transformer 的时间复杂度为： O(Ln2d+Lnd2)O(L**n2d+Lnd2) 实际应用中，长序列（nn 大）时 O(n2d)O(n2d) 是主要瓶颈，而通过模型优化（如稀疏化）可缓解这一问题。 Transformer的BERT有了解过吗 是的，我对BERT（Bidirectional Encoder Representations from Transformers）非常熟悉。它是基于Transformer架构的预训练模型，由Google在2018年提出，彻底改变了自然语言处理（NLP）领域的多项任务。以下是针对面试可能涉及的BERT核心知识点整理： 1. BERT的核心思想 双向上下文建模： 与传统语言模型（如GPT）不同，BERT通过Masked Language Model (MLM) 同时利用左右两侧的上下文信息，从而捕捉更丰富的语义。 Transformer Encoder： 仅使用Transformer的Encoder堆叠（无Decoder），每一层包含自注意力机制和前馈网络。 2. 关键技术与训练任务 (1) Masked Language Model (MLM) 随机遮盖输入词的15%，模型预测被遮盖的词（如：“I [MASK] a student” → “am”）。 改进：10%替换为随机词，10%保留原词，缓解预训练-微调不一致性。 (2) Next Sentence Prediction (NSP) 二分类任务：判断两个句子是否连续（如：\"[CLS] Sentence A [SEP] Sentence B [SEP]\" → IsNext/NotNext）。 用途：提升模型理解句子间关系的能力（后续研究如RoBERTa发现NSP可能非必要）。 3. 模型结构细节 输入表示： [CLS]：分类任务的特殊标记（其输出用作聚合表示）。 [SEP]：分隔句子对。 Token Embedding + Segment Embedding + Position Embedding（三嵌入求和）。 层数与参数量： BERT-base：12层Transformer，隐藏层维度768，12个头，参数量约110M。 BERT-large：24层，隐藏层1024，16个头，参数量约340M。 4. 微调（Fine-tuning）应用 任务适配：通过添加任务特定输出层，BERT可应用于多种下游任务： 文本分类（如情感分析）：使用[CLS]输出。 序列标注（如NER）：对每个token的输出分类。 问答任务（如SQuAD）：预测答案段的起止位置。 句子对任务（如语义相似度）：联合处理两个句子。 5. BERT的优缺点 优点： 强大的泛化能力：预训练捕捉深层语言特征，微调所需数据少。 多任务统一架构：同一模型可处理分类、标注、生成等任务（需调整输出层）。 缺点： 计算资源消耗大：预训练需要大规模GPU/TPU集群。 长文本处理受限：因自注意力的O(n2)O(n2)复杂度，序列长度通常限制为512。 生成能力弱：无Decoder，不擅长文本生成（需结合GPT或Seq2Seq结构）。 6. 常见面试问题","date":"2026-01-25","objectID":"/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E6%8C%87%E5%8D%97/:15:1","tags":["编程"],"title":"程序员面试指南","uri":"/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E6%8C%87%E5%8D%97/"},{"categories":["编程"],"content":"RAG b41fff7a375b5d4a98f9bc9a5742546b.png (854×479) ","date":"2026-01-25","objectID":"/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E6%8C%87%E5%8D%97/:15:2","tags":["编程"],"title":"程序员面试指南","uri":"/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E6%8C%87%E5%8D%97/"},{"categories":["编程"],"content":"思维题 ","date":"2026-01-25","objectID":"/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E6%8C%87%E5%8D%97/:16:0","tags":["编程"],"title":"程序员面试指南","uri":"/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E6%8C%87%E5%8D%97/"},{"categories":["编程"],"content":"赛马题 ","date":"2026-01-25","objectID":"/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E6%8C%87%E5%8D%97/:16:1","tags":["编程"],"title":"程序员面试指南","uri":"/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E6%8C%87%E5%8D%97/"},{"categories":["编程"],"content":"面试反问 ","date":"2026-01-25","objectID":"/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E6%8C%87%E5%8D%97/:17:0","tags":["编程"],"title":"程序员面试指南","uri":"/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E6%8C%87%E5%8D%97/"},{"categories":["编程"],"content":"前述 针对自己在秋招的面试中，根据自己面试情况中，在后面的面试复盘中，针对于面试官要求最后的反问环节的一些注意细节，从反问的角度对于下面问题： 我们应该如何进行提问？ 应该分别针对不同阶段的面试提问哪些内容？ 提问上应该抱有那些心态？ …… 自己从每次面试，这里做一次简单的总结分享一下，希望能帮助到各位同学。 ","date":"2026-01-25","objectID":"/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E6%8C%87%E5%8D%97/:17:1","tags":["编程"],"title":"程序员面试指南","uri":"/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E6%8C%87%E5%8D%97/"},{"categories":["编程"],"content":"一面：纯技术面 目的 对于技术面来说，一面主要是进行基础的技术面，涉及到你对该方向的基础知识的掌握程度。比如软开：会涉及到对于 计算机的基础知识的掌握情况：让你说说操作系统，网络方面的知识等； 编程能力的熟悉程度：相应手撕几道编程题目； 编程语言的理解程度：比如对于你所熟悉的编程语言，如CPP或者 jave会让你说一些这些语言底层的机制是如何如何等等问题。 反问 技术层面上反问： 比如刚刚面试中有遇到自己不太清楚的问题，或者答的不太好的问题点，自己可以问下：您刚才问的xxx问题，我想问下您的思路？ 比如自己和面试的部门的匹配程度：部门的主营业务和使用的技术栈都是哪些（组里面进去的新人一般做哪些任务）？岗位主要负责的业务？ 当前部门的一个大概分工方向？部门主要的架构？ 能力层面上的反问： 就我的这次面试，您觉得我的能力有哪些地方（比如技术上或者语言表达能力上）需要提升？ 面试一般多久会通知结果？ ","date":"2026-01-25","objectID":"/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E6%8C%87%E5%8D%97/:17:2","tags":["编程"],"title":"程序员面试指南","uri":"/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E6%8C%87%E5%8D%97/"},{"categories":["编程"],"content":"二面：技术综合面/主管面 目的 二面一般是一个部门的小领导或者一个主管来进行面试的（大部分情况是这样的），等顺利进入改公司的时候，也大概率是你的领导或者小组长之类的。二面的出发点，表明你的一面技术基础面是OK的，至少对于该公司来说是基本够用。 二面综合面，会相应对的技术综合实力来进行考量的， 一搬会根据你的项目经历，结合你的技术来深入项目细节展开交流，所以你一定得对的项目所涉及的知识网非常熟悉方可。 同时，会结合你的项目，穿插一些情景类的技术问题，让你说一下自己的解决思路和想法。我认为这也是一个和面试官进行交互想法的过程，不懂的也可以问，互相讨论感觉效果更好（不乏有的面试官总向咄咄逼人😅） 反问 从综合层面上的反问： 面试的候选人，特别是对于我们这样的校招生，企业一般最看重什么？ 您对进入您团队的成员的要求是什么？或者说，我们需要具备哪些能力才能胜任这个岗位？ 团队工作氛围？ ","date":"2026-01-25","objectID":"/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E6%8C%87%E5%8D%97/:17:3","tags":["编程"],"title":"程序员面试指南","uri":"/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E6%8C%87%E5%8D%97/"},{"categories":["编程"],"content":"三面：HR面 目的 如果能顺利进入HR面，也意味着你是较大可能的能顺利拿到该家公司的offer了👏。 HR也仅仅是考一下的个人软能力方面的问题。 反问 公司对新人的培养模式是什么样的？ 公司氛围？ 一般情况大概多久可以出结果？（这时候，应该去想HR确认最终什么时候出结果，后续的还有那些流程等） ","date":"2026-01-25","objectID":"/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E6%8C%87%E5%8D%97/:17:4","tags":["编程"],"title":"程序员面试指南","uri":"/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E6%8C%87%E5%8D%97/"},{"categories":["编程"],"content":"面试历程时间表 1面 2面 3面 hr面 评价 日常实习 wxg-微信支付-后台开发 2025.4.7 一面秒挂 处子面，hot100没做出来 IEG-游戏安全-后台开发 2025.4.15 2025.4.17 2025.4.18 技术三面挂（周一挂） 百度-医疗健康业务部-算法 2025.4.30一面秒挂 IEG-游戏营销技术服务-运营开发 想蹲一个后台开发,拒面了 美团-大模型数据开发实习生 2025.4.29 2025.5.6 （一周后挂） （感觉做爬虫没意思+北京租房无补贴）和面试官表示不想来 字节-今日头条-用户增长业务-后端 2025.5.9(一周挂） wxg-技术架构-后台开发 2025.5.28 2025.6.5 （面完秒挂） 流程奇慢无比，每次面试四道算法题90min+… 美团-大模型应用系统开发实习生（智能分析方向） 2025.5.29 2025.5.30（默挂） 快手-直播-Java开发 2025.6.6 2025.6.10（默挂） 淘天-客户端开发-ai agent方向 2025.6.20电话面（默挂） 美团-大模应用平台研发项目实习生 2025.6.30（一周挂） 百度-搜索架构-基础召回 2025.7.8 2025.7.9 2025.7.10晚hr电话 接offer了，也算转c++了 高德-大模型应用开发实习生（工程效率方向） 2025.7.8（默挂） 美团-软件开发实习生 2025.7.8（一周挂） 苏州微软-Bing-intern developer 2025.7.10 2025.7.11（默挂） 第一次遇到早上九点和十点面试的… IEG-游戏营销技术服务-运营开发 2025.7.10（一周挂） 米哈游-研发效能-后端 2025.7.17 已拿到百度offer已拒面 暑期实习 wxg-基础微信团队 2026.1.16（当晚挂） 做agent的，用的c++，好奇怪的组合，不感兴趣 小红书-引擎架构部-大模型架构基础训练 2026.1.26（当晚挂） 想试试ai infra，但是这个真的是我面试以来问的最难的了，好崩溃基本上一题都没答出来 美团-MLP-推理 2026.2.2（面试一小时后约二面） 2026.2.3 2026.2.3加微信沟通 快手-AI Infra 2026.2.5 自我介绍完发现被hr推错了团队，推到了agent团队了，面试官说我适合训推，直接5min结束等待hr下面约面 字节-AML-训练 2026.2.9 由于美团在2.9上午发了offer，所以为了不影响面评，直接和hr取消了面试，等待秋招有缘再面 ​ ​ ​ ​ ​ ​ ​ ​ ​ ​ ​ ​ ​ ​ ​ ​ ","date":"2026-01-25","objectID":"/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E6%8C%87%E5%8D%97/:18:0","tags":["编程"],"title":"程序员面试指南","uri":"/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E6%8C%87%E5%8D%97/"},{"categories":["编程"],"content":"首先我们来谈一谈源码编译安装的好处，这边我们引用我一同在百度实习的朋友ywm的话： 安全啊。默认如果用 sudo 去安装，所有的东西都会默认写入系统目录下，也就是会不安全而且需要sudo,如果你没有管理员密码，或者你想要只安装在用户目录下，做安全隔离，那就得自己下载源码进行编译安装，他每次都这样，这样就不会影响到实验室整个服务器的安全了 ","date":"2025-12-11","objectID":"/%E5%BC%80%E5%8F%91%E6%9C%BA%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE/:0:0","tags":["编程"],"title":"开发机常用配置","uri":"/%E5%BC%80%E5%8F%91%E6%9C%BA%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE/"},{"categories":["编程"],"content":"zsh 一个极为强大的强化版bash，拥有后可以有更多的插件去增强功能 在外网机器下载源码 wget https://sourceforge.net/projects/zsh/files/zsh/5.9/zsh-5.9.tar.xz 传到内网机： scp zsh-5.9.tar.xz dev:/tmp/ 在内网机编译 tar xf zsh-5.9.tar.xz cd zsh-5.9 ./configure --prefix=/usr/local/zsh make -j$(nproc) sudo make install 安装后： echo /usr/local/zsh/bin/zsh | sudo tee -a /etc/shells chsh -s /usr/local/zsh/bin/zsh zsh-autosuggest（自动灰色提示） 如果你想要那种： 输入几个字符 → 自动浮现灰色历史提示文本 那么用 zsh 的自带能力不够，但你可以： 不下载 直接把插件源码 copy 过去 只需要一个文件 下载后你会发现：新开的 zsh 终端无法看到前一个终端执行过的命令历史 如何配置 zsh 历史持久化配置 这是 zsh 默认行为的坑：zsh 不会自动把命令立即写入 ~/.zsh_history，而是只在退出时写入。 所以多个终端之间互相看不到对方的历史命令。 ✅ 解决方法（标准 zsh 历史持久化配置） 编辑你的 ~/.zshrc： 加入下面这段（这是 zsh 最正确 \u0026 最通用的历史配置）： # --- Zsh History Settings --- HISTSIZE=500000 SAVEHIST=500000 HISTFILE=~/.zsh_history # 每条命令执行后立即写入历史文件（非常关键！） setopt INC_APPEND_HISTORY # 在多个 zsh 之间共享历史（你现在的问题就是缺这个） setopt SHARE_HISTORY # 避免重复命令 setopt HIST_IGNORE_ALL_DUPS setopt HIST_REDUCE_BLANKS # 追加历史，而不是覆盖 setopt APPEND_HISTORY # 高级共享策略（推荐） setopt EXTENDED_HISTORY 保存后： source ~/.zshrc 如何直接执行 zsh-autosuggestions 的提示命令 方式：按 →（右方向键）接受建议 + 回车 这是插件默认行为： 光标右键（→）→ 立刻把灰色建议补全到命令行 再按回车执行 这是最标准、最常用的方式。 fzf 当然上面的 zsh-autosuggest 提供的提示不支持模糊匹配，比如如果我们有多个同样前缀的命令时就很苦恼了，这时候就得使用我们更强大的插件 fzf 了。 ","date":"2025-12-11","objectID":"/%E5%BC%80%E5%8F%91%E6%9C%BA%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE/:0:1","tags":["编程"],"title":"开发机常用配置","uri":"/%E5%BC%80%E5%8F%91%E6%9C%BA%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE/"},{"categories":["编程"],"content":"设置 ","date":"2025-12-10","objectID":"/vscode%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE/:1:0","tags":["编程"],"title":"vscode常用配置","uri":"/vscode%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE/"},{"categories":["编程"],"content":"代码缩略窗 搜索minimap，找到“Editor: Minimap”选项，并勾选“Enabled”复选框。 image-20251210192552152 在缩略图中只需要双击右边的文件，即可跳转到对应的位置： image-20251210193253900 ","date":"2025-12-10","objectID":"/vscode%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE/:1:1","tags":["编程"],"title":"vscode常用配置","uri":"/vscode%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE/"},{"categories":["编程"],"content":"插件 ","date":"2025-12-10","objectID":"/vscode%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE/:2:0","tags":["编程"],"title":"vscode常用配置","uri":"/vscode%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE/"},{"categories":["编程"],"content":"GitLens 神！可以看到每行代码的提交人，只需要将鼠标放在每一行的提示文字上即可： image-20251210192810252 ","date":"2025-12-10","objectID":"/vscode%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE/:2:1","tags":["编程"],"title":"vscode常用配置","uri":"/vscode%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE/"},{"categories":["编程"],"content":"Doxygen Documentation Generator 安装后就可以和 IDEA 一样，通过输入 /** 然后按下回车键，自动生成注释模板 生成注释模板（两种方式，任选其一）： 方式 1：把光标定位到函数上方，按下快捷键 Ctrl+Shift+D（Windows/Linux）/ Cmd+Shift+D（Mac），直接生成完整模板。 方式 2（推荐）：和 IDEA 一样，输入 /** 然后按下回车键，自动补全模板。 填充内容：IDE 会自动识别函数的参数、返回值，生成对应的 @param、@return 标签，你只需要填写具体含义即可。 ","date":"2025-12-10","objectID":"/vscode%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE/:2:2","tags":["编程"],"title":"vscode常用配置","uri":"/vscode%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE/"},{"categories":["编程"],"content":"Material Icon Theme 很漂亮的文件格式 ","date":"2025-12-10","objectID":"/vscode%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE/:2:3","tags":["编程"],"title":"vscode常用配置","uri":"/vscode%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE/"},{"categories":["编程"],"content":"Dracula Theme Official 很喜欢的vscode主题，吸血鬼 ","date":"2025-12-10","objectID":"/vscode%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE/:2:4","tags":["编程"],"title":"vscode常用配置","uri":"/vscode%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE/"},{"categories":["编程"],"content":"Chinese (Simplified) 汉化包，yyds! ","date":"2025-12-10","objectID":"/vscode%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE/:2:5","tags":["编程"],"title":"vscode常用配置","uri":"/vscode%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE/"},{"categories":["阅读"],"content":"《原子习惯》 习惯为什么重要呢，就在于它的复利特征，这个太重要了，最简单的就是 $1.01^{365} \\approx 37.78$，也就是每天提升 $1%$，坚持一年提升的不是我们下意识认为的 $3.65$ 倍的提升，而是低估了整整 $10$ 倍的提升了。 当然很多人会有疑惑，明明我每天的精力都差不多，学的进度也差不多，这明明只是 $1.01 \\times 365 \\approx 3.65 $，那为什么书中却说是复利呢？那是因为我们就先拿知识来说：知识会复合增益，也就是说学习新观念会增加你原有观念的价值。比如本来如果只是看了书本A，你只吸收得到了 $40%$，而如果你继续学习，看了书本B，不但你对书本B的知识掌握了，而且还加深了你对书本A的认知，比如从$20% \\to 60%$，所以最终的收益是复利 $1.01^{365} \\approx 37.78$，这是恐怖的 $10$ 倍错误估计啊！！两条曲线的差异可以看下面这张图： image-20251104145644852 至于为什么我们感觉我们付出了努力去谋求改变，为什么非常的不明显？答案也藏在了上面这个指数函数的图像中，你可知道增长一倍的函数坐标吗？是恐怖的 $(69.66, 1.99999)$,意思是我们努力了整整 $70$ 天，只带来了一倍的提升，这怎么不让现在这个快节奏的社会中的人们感到无比的伤心，但是复利的本质是后期的快速飞跃，我们把目标瞄向第二个 $70$ 天，数据上是 $(140,4.0271)$，第三个 $70$ 天则是 $(210,8.08144)$，增长的越来越快，这就是为什么高手都是专注一个领域的，因为复利效应来看坚持的越久，作用也提升的越快。我们直接来看函数 $1.01^{x+1} - 1.01^x$ 就会更加的明显： image-20251104151739399 就像你自己是一个水池，你应当关注你的流量，也就是进水量和出水量，而不是存量。因为只要流量对了，那么你的存量自然会日积月累地增加。 你得到的结果是衡量你习惯的滞后指标。 忘记目标，专注于体系。目标是关于你想要达到的结果，而体系是涉及导致这些结果的过程。因为如果目标是最重要的话，那么世界上就不会有赢家和输家了，因为他们都心怀相同的目标。这里我们强调“体系”，而非“过程”，是因为“过程”是行为，“体系”是让这些行为长期运作的生态系统，解决如何让这件事持续有效地发生。专注于目标会有以下几个问题： 问题1：赢家和输家心怀相同的目标 问题2：实现一个目标只是短暂的改变 问题3：目标束缚了你的幸福感 ","date":"2025-10-31","objectID":"/%E5%8E%9F%E5%AD%90%E4%B9%A0%E6%83%AF/:1:0","tags":["读书笔记"],"title":"《原子习惯》","uri":"/%E5%8E%9F%E5%AD%90%E4%B9%A0%E6%83%AF/"},{"categories":["编程"],"content":"如何提交一个优雅的pr 暑假参加了2025OSPP的活动，有幸参与了apache/fory的开源项目的开发活动，也因此在实践中学习到了如何在GitHub上参与一个开源项目 在GitHub上你想要给开源项目提交你的代码，就需要提交pr，也就是所谓的 pull request。 ","date":"2025-09-23","objectID":"/%E5%A6%82%E4%BD%95%E6%8F%90%E4%BA%A4%E4%B8%80%E4%B8%AA%E4%BC%98%E9%9B%85%E7%9A%84pr/:1:0","tags":["编程"],"title":"如何提交一个优雅的pr","uri":"/%E5%A6%82%E4%BD%95%E6%8F%90%E4%BA%A4%E4%B8%80%E4%B8%AA%E4%BC%98%E9%9B%85%E7%9A%84pr/"},{"categories":["编程"],"content":"1. fork 仓库 首先需要将这个项目fork到你的主页，注意：后续所有的操作都是基于你仓库内的这个派生的代码库展开的。 image-20250923145650118 拉取的项目的main分支不要动，因为我们要靠这个分支与原仓库做同步。 从优雅简洁的角度来看，每次你想要提交一个pr，都请先在你的这个派生的代码库中新建一个分支： image-20250923150223563 分支名最好和本次提交的主题相关，这样方便分辨哪个分支是干什么的，比如我这次需要提交一个新特性：让go语言的代码生成部分支持slice，那么我就可以新建一个叫做feat-slice的分支。 GitHub里的派生的代码库不会默认进行同步，如果你派生的代码库落后于最新的原始仓库，那么这里就会有提示，点击 Sync fork 按钮即可 Update branch。（注意我们每次只要更新main分支就好，保持main分支是最新的就行） image-20250923150446976 ","date":"2025-09-23","objectID":"/%E5%A6%82%E4%BD%95%E6%8F%90%E4%BA%A4%E4%B8%80%E4%B8%AA%E4%BC%98%E9%9B%85%E7%9A%84pr/:1:1","tags":["编程"],"title":"如何提交一个优雅的pr","uri":"/%E5%A6%82%E4%BD%95%E6%8F%90%E4%BA%A4%E4%B8%80%E4%B8%AA%E4%BC%98%E9%9B%85%E7%9A%84pr/"},{"categories":["编程"],"content":"2. 本地开发 本地开发始终记住：永远不要在main分支上修改提交commit！！！每次开发都请和远程派生的代码库一样，各自新建一个分支来开发，pr提交合并结束记得删除本地相关分支和派生代码库的相关分支。 这里的好处是非常非常大的，也是我本地踩过很多次坑发现的：因为GitHub提交pr的特点是，pr中可能有10个commit，最终如果owner approve 你的合并，那也只会将这个pr的内容作为一个整体commit提交上去。所以如果你在main分支上直接开发，就会出现你的本地commit多于远程代码库的main分支，这显然是有问题的，两边git历史对不上。所以这就是为什么我说的永远不要在main分支上直接修改提交，新建新的分支开发完提交pr之后就可以删掉了，然后本地main分支重新git pull就可以保持完全一致！ 首先先查看git历史： git log --graph --oneline --decorate --all 然后切换到main分支： git checkout main 新建并切换分支： git checkout -b \u003c新分支名\u003e 下面就可以在这个新的分支上进行愉快的开发了！ ","date":"2025-09-23","objectID":"/%E5%A6%82%E4%BD%95%E6%8F%90%E4%BA%A4%E4%B8%80%E4%B8%AA%E4%BC%98%E9%9B%85%E7%9A%84pr/:1:2","tags":["编程"],"title":"如何提交一个优雅的pr","uri":"/%E5%A6%82%E4%BD%95%E6%8F%90%E4%BA%A4%E4%B8%80%E4%B8%AA%E4%BC%98%E9%9B%85%E7%9A%84pr/"},{"categories":["编程"],"content":"3. 创建合并请求 只要你将本地的修改push到你远程的派生代码库的相关分支上，回到线上派生项目的工作区，会看到新分支和修改的合并提交信息，点击Compare \u0026 pull request: image-20250923183009698 选择你想并入的原项目分支，标题和描述信息。如果有对应的 issue，就通过键入 # 添加(Github 会自动展示 issues 列表) 然后点击Create pull request即可创建合并请求成功，之后就等待cr就行。 ","date":"2025-09-23","objectID":"/%E5%A6%82%E4%BD%95%E6%8F%90%E4%BA%A4%E4%B8%80%E4%B8%AA%E4%BC%98%E9%9B%85%E7%9A%84pr/:1:3","tags":["编程"],"title":"如何提交一个优雅的pr","uri":"/%E5%A6%82%E4%BD%95%E6%8F%90%E4%BA%A4%E4%B8%80%E4%B8%AA%E4%BC%98%E9%9B%85%E7%9A%84pr/"},{"categories":["编程"],"content":"4. 根据评论修改你的代码 你提交的pr是需要 code owner 进行 review 的，他们认为你的代码有问题就会在cr的时候提出评论，此时你需要根据评论去修改你本地的内容，然后再提交到之前的那个远程分支上就可以自动更新pr中的commit了。 但是很多情况下会有很复杂的情况，比如给你的评论很复杂改了几天，回头发现有人先提交了一些新的pr并且合入了怎么办？ 我们可以把这种情况抽象为下面的模型： 初始情况: 远程 main: A feat-slice: A 本地 feat_slice: A 你在本地提交了 C 本地 feat_slice: A–C 然后你 push 到远程 feat-slice： main: A feat-slice: A–C 远程 main 更新为 A–B 远程： main: A–B feat-slice: A–C 本地： feat_slice: A–C （还没 git pull --rebase） 本地 git pull --rebase 到 main 执行：git pull --rebase 结果： 本地 feat_slice: A–B–C （C 被“挪”到 B 后面） 远程还是： main: A–B feat-slice: A–C 此时 git push origin master:feat_slice 到远程 feat-slice Git 会检查： 远程 feat-slice 目前是 A–C 你要推的是 A–B–C 👉 这两条历史分叉了： 远程的 C 在 A 后直接接， 本地的 C 在 A–B 后接。 所以，Git 默认会认为这是「非快进 (non-fast-forward) 更新」，直接 push 会报错： ! [rejected] master -\u003e feat_slice (non-fast-forward) 强制推送 怎么办？ 如果你确认要让远程 feat-slice 变成 A–B–C，需要强制推送： git push -f origin master:feat_slice 这样远程 feat-slice 就会被改写成 A–B–C。pr上也会出现force-pushed的相关显示： image-20250923170353243 ","date":"2025-09-23","objectID":"/%E5%A6%82%E4%BD%95%E6%8F%90%E4%BA%A4%E4%B8%80%E4%B8%AA%E4%BC%98%E9%9B%85%E7%9A%84pr/:1:4","tags":["编程"],"title":"如何提交一个优雅的pr","uri":"/%E5%A6%82%E4%BD%95%E6%8F%90%E4%BA%A4%E4%B8%80%E4%B8%AA%E4%BC%98%E9%9B%85%E7%9A%84pr/"},{"categories":["编程"],"content":"5. 删除你的分支 请记住：每次提交的pr合并进去，都请删除本地和派生代码库的相关分支，然后在本地的main分支重新git pull即可，如果还需要继续开发，请回到 步骤2. 本地开发 ","date":"2025-09-23","objectID":"/%E5%A6%82%E4%BD%95%E6%8F%90%E4%BA%A4%E4%B8%80%E4%B8%AA%E4%BC%98%E9%9B%85%E7%9A%84pr/:1:5","tags":["编程"],"title":"如何提交一个优雅的pr","uri":"/%E5%A6%82%E4%BD%95%E6%8F%90%E4%BA%A4%E4%B8%80%E4%B8%AA%E4%BC%98%E9%9B%85%E7%9A%84pr/"},{"categories":["编程"],"content":"c++学习笔记 ","date":"2025-08-29","objectID":"/c-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:0:0","tags":["编程"],"title":"c++学习笔记","uri":"/c-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["编程"],"content":"学习资源 视频地址：C++教程-油管大佬 The Cherno C++教程 ","date":"2025-08-29","objectID":"/c-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:1:0","tags":["编程"],"title":"c++学习笔记","uri":"/c-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["编程"],"content":"1. c++语法 ","date":"2025-08-29","objectID":"/c-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:2:0","tags":["编程"],"title":"c++学习笔记","uri":"/c-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["编程"],"content":"1.1 基本结构 下面有一个简单的c++程序，我们来看看： #include \u003ciostream\u003e #include \u003cstring\u003e #include \"b.h\" int main() { std::string a = \"Hello World!\"; std::cout \u003c\u003c a \u003c\u003c std::endl; } 由于c++兼容着c，因此基本语法并没有很明显的区别，这里需要注意的是c++的头文件和c语言的标准库文件确实是有区别的，c语言的头文件一般是#include \u003cstdio.h\u003e，而c++的标准库文件一般没有.h作为结尾，这是为了和c语言有所区分。 这时候又会有人问了，那为什么c++中又有\u003c\u003e又有\"\"这两种include写法呢？其实就是为了让编译器知道，哪些头文件需要从用户的仓库目录里面找，哪些从gcc的库函数里面去找。 ","date":"2025-08-29","objectID":"/c-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:2:1","tags":["编程"],"title":"c++学习笔记","uri":"/c-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["编程"],"content":"1.2 编译、链接、头文件 刚刚给的例子太简单了，这次我们给一个稍微复杂一点的,涉及到调用另一个文件中的方法的代码： main.cc: #include \u003ciostream\u003e int main() { funcB(); // 调用b.cc中的方法funcB(); } 如果设计到一个项目中有两个文件，而且main函数需要调用另一个文件中的funcA方法，编译器到底怎么样才能将这个main函数成功运行呢？ 那么我们就得了解编译器到底干了什么事情。简单来说主要就是两件事：编译和链接 编译其实就是编译器（如 g++）把 源代码（.c++）转化为 目标文件（.o/.obj），这个过程中包含几个子阶段： 预处理 (Preprocessing) 处理 #include、#define、#if 等预处理指令。 例如：#include \"b.h\" 会直接把 b.h 的内容拷贝进来。 预处理后的文件其实是一个纯 C++ 源文件。 词法/语法分析 检查语法是否正确，比如 int x = \"abc\"; 就会报错。 把代码拆成语法树（AST）。 语义分析 + 生成中间表示 确认类型是否匹配，作用域是否正确。 例如：声明了函数 void f(); 但是在同一个 .c++ 文件里没有定义，不会报错，只会标记“这个符号需要外部解析”。 生成目标文件 (.o) 每个 .c++ 编译后，都会生成对应的 .o。 .o 文件里包含了 机器指令 + 符号表（符号表记录了函数和变量的名字、是否已经实现、还是等待外部提供）。 看了上面的介绍，你认为上面的代码使用g++ -c main.c++ -o a.o能成功编译吗？ 答案当然是 No，根据上面编译过程的分析可以知道，想要使用一个当前文件没有实现的方法，我们需要声明这个函数，我们把代码更新为： #include \u003ciostream\u003e void funcB(); int main() { funcB(); } 现在我们重新编译：g++ -c main.c++ -o a.o 这次果然成功了，生成了a.o这个目标文件，but oh no, b.cc我甚至还没写啊，what crazy! 这样居然编译都没报错，因此你应该理解了下面这句话了： 👉 这个阶段 不会报“未定义引用（undefined reference）”错误，因为编译器只管当前 .c++ 文件，不管别的文件到底有没有funcB()的具体实现。 至于funcB()到底实现在哪了，那就是接下来链接阶段需要关心的。 链接阶段其实就是链接器（ld）把所有 .o 文件和库文件 .a / .so 组合在一起，生成一个可执行文件。 符号解析 每个 .o 文件都有符号表（symbol table）。 如果某个 .o 里声明了 extern void foo();，但是没有实现，链接器会在别的 .o 或库里找 foo 的定义。 符号重定位 不同目标文件中的函数、变量可能会分布在不同内存区域，链接器会把调用地址改成实际的地址。 比如：在 main.o 里有 call foo，但是不知道 foo 在哪，链接器会把它改成 call 0x400123 这种真实地址。 生成可执行文件 所有引用都能匹配 → 链接成功，得到 ELF（Linux）或 PE（Windows）格式的可执行文件。 如果找不到 → 报错 undefined reference to 'foo'。 注：what isextern? 👉 它告诉编译器： “这个变量/函数的定义在别的地方，我这里只是声明一下。” 换句话说，extern 只做 声明 (declaration)，不做 定义 (definition)。 最终在链接阶段，链接器会去别的翻译单元（别的 .o 文件、库）里找到真正的实现。 （1）全局变量跨文件使用 // a.c++ int g_value = 42; // 定义（真正分配内存） // b.c++ extern int g_value; // 声明（不分配内存） void print() { std::cout \u003c\u003c g_value \u003c\u003c std::endl; } 编译时 b.c++ 看到 extern int g_value;，知道有个 int 变量存在，但不生成内存。 链接时，它去 a.o 找到 g_value 的定义，拼在一起 ✅。 （2）函数默认就是 extern // a.c++ void foo() {} // 定义 // b.c++ void foo(); // 声明（其实相当于 extern void foo();） 函数声明本质上都带 extern，所以你不写也行 这时候如果我们没有实现b.c++直接去把g++ main.cc -o main 我们会发现报错： (TraeAI-4) ~/Downloads/c++ [126] $ g++ main.cc -o main Undefined symbols for architecture arm64: \"funcB()\", referenced from: _main in main-331bbe.o ld: symbol(s) not found for architecture arm64 clang: error: linker command failed with exit code 1 (use -v to see invocation) 这说明虽然上面的编译阶段成功了，但是链接阶段却有问题，提示找不到funcB()的具体实现 这时候我们就需要实际去实现我们的b.cc文件了： #include \u003ciostream\u003e void funcB() { std::cout \u003c\u003c \"B\" \u003c\u003c std::endl; } 现在我们再次运行g++ main.cc b.cc -o main，构建成功了! 聪明的同学肯定还有疑问啊，那c以及c++文件中随处可见的.h文件，在项目构建时会发生什么呢？ 包括还有人有疑问，每次写我们都得将函数声明void funcB();写在文件的上面吗，那不是非常的丑陋，如果调用的函数非常多的话？ 其实头文件.h就是为了解决这个问题的，也就是我们上面提到的编译过程中的预处理阶段。在预处理阶段，编译器看到了#include等预处理指令，就会 copy 这个文件中的内容到这个位置，对就是这么朴实无华的复制粘贴，因此一个大胆的想法就是，我们为什么不吧函数声明专门放在一个.h文件中呢，那么我们只需要在文件前面使用#include \"b.h\"，就可以实现函数声明的作用，是不是很天才！ 另外要注意的是，.h文件并没有被实际编译，因此我们依旧运行g++ main.cc b.cc -o main便可以构建成功了。以及b.cc的头文件不一定是b.h，也可以命名为c.h，因为本质上b.h的内容只是被 copy 进了main.cc中了，他的使命在编译阶段便结束了，至于怎么找到funcB()的实际实现，就是靠链接阶段的符号表了。 以及头文件中可能会造成重复声明的问题，这里只需要在头文件的开头加上一行#pragma once就可以解决问题了。至于古老的项目中，你可能还会见到下面这种写法，只是不太推荐： #ifndef C_H #define C_H void funcB(); #endif ","date":"2025-08-29","objectID":"/c-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:2:2","tags":["编程"],"title":"c++学习笔记","uri":"/c-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["编程"],"content":"1.3 pointer 首先我们来下一个定义：指针只是存储内存地址的整数。 int main() { int var = 8; int* ptr = \u0026var; } 因此本质上来看，为什么变量要指定类型呢？答案是需要知道实际用几个字节来存储该变量的值。那么指针指定的变量难道也是为了告诉编译器需要用几个字节来存储吗？No，No，No，如果真这么简单我也不会在这里花一段话来讲了，本质上来看指针存的只是内存中某一个位置的地址值，难道地址大小还不一样吗计算机哈哈哈，所以比如如果是64位的机器，那么默认指针都需要用8B来存啊，这都不用用户去说编译器就能自动知道。但是拿到这个地址值之后，你知道要读多少位吗？是读8位的char，还是32位的int呢？这就需要事先告诉编译器了，因此指针的类型是告诉编译器如果*ptr，编译器需要去读多少字节。 ","date":"2025-08-29","objectID":"/c-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:2:3","tags":["编程"],"title":"c++学习笔记","uri":"/c-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["编程"],"content":"1.4 reference 首先我们来下一个定义：引用只是指针的语法糖。 可以简单理解为引用是一种别名，引用只能引用已经存在的变量，引用本身不是创建变量，因此它并不占用内存。他们并没有真正的存储空间。 要注意的是，c语言中常见的\u0026a的是意思是变量a的地址，引用是跟在类型后面的，实际是类型的一部分，我们会看到int\u0026 ref = a，这里就是引用类型了。 而至于什么时候是引用，什么时候是地址，那就看上下文了，跟在类型后面就是引用，在变量前面就是地址。 这里的ref变量实际不存在，他只存在于我们的源代码中。如果你现在编译这段代码，不会得到两个变量a和ref，你只会得到a，我们只是把所有对ref的操作都加到a上。 因此之前我们如果想传入一个值，并且在函数内部修改这个值，需要用到指针，并且看着有点乱.现在我们就可以优雅的用引用传递了（Java中对对象默认自动支持引用传递）： int add(int* a) { return (*a) ++; } int add(int\u0026 a) { return a ++; } 最后要说的一点是，引用只能绑定一次，不能中途更换引用的变量，要想更换只能使用功能更强大，但是也更复杂的指针了。 ","date":"2025-08-29","objectID":"/c-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:2:4","tags":["编程"],"title":"c++学习笔记","uri":"/c-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["编程"],"content":"1.5 class 很多人看到c++中的class，经常会想到c语言中大名鼎鼎的struct，所以他们之间有什么区别呢？ #include \u003ciostream\u003e // 和下面的class写法等价 // struct Player { // int x, y; // int speed; // }; class Player { public: int x, y; int speed; }; int main() { Player player; player.x = 10; player.y = 20; player.speed = 100; std::cout \u003c\u003c player.x \u003c\u003c std::endl; std::cout \u003c\u003c player.y \u003c\u003c std::endl; std::cout \u003c\u003c player.speed \u003c\u003c std::endl; } 上面代码中的Player的结构体和类的作用是一摸一样的，我们就能看到一个最明显的区别：class默认内部都是private的，如果想要public需要声明；而struct则恰好相反。 所以说对于是用class还是struct，如果不是为了类的继承多态等高级特性，那这两个基本没有区别了。那就看个人的编程风格了，如果他只是一种只表示变量的简单组织结构，比如基本的数据结构，就可以考虑只使用简单的struct。 下面未来介绍类的其他特性，我们先给出一个简单的log类，它将会随着我们新的语法特性的介绍而逐渐被优化，现在代码如下： class Log { private: int log_level; public: const int LogLevelError = 0; const int LogLevelWarning = 1; const int LogLevelInfo = 2; void SetLevel(int level) { log_level = level; } void Error(const std::string\u0026 message) { if (log_level \u003e= LogLevelError) std::cout \u003c\u003c \"[ERROR]: \" \u003c\u003c message \u003c\u003c std::endl; } void Warn(const std::string\u0026 message) { if (log_level \u003e= LogLevelWarning) std::cout \u003c\u003c \"[WARNING]: \" \u003c\u003c message \u003c\u003c std::endl; } void Info(const std::string\u0026 message) { if (log_level \u003e= LogLevelInfo) std::cout \u003c\u003c \"[INFO]: \" \u003c\u003c message \u003c\u003c std::endl; } }; int main() { Log log; log.SetLevel(log.LogLevelInfo); log.Error(\"called object type 'int' is not a function or function pointer\"); log.Warn(\"default member initializer for non-static data member is a C++11 extension [-Wc++11-extensions]\"); log.Info(\"1 warnings and 1 errors generated.\"); } ","date":"2025-08-29","objectID":"/c-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:2:5","tags":["编程"],"title":"c++学习笔记","uri":"/c-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["编程"],"content":"1.6 static 和引用一样，static在不同的语境下的含义也是不一样的。 1.6.1 在类和结构体之外 对于在类和结构体之外使用static，它的作用就是将你声明的该符号不对外链接，这意味着它只在你定义他的这个文件中起作用。 这种情况的好处是对于c++，如果你链接的两个文件中，有一个同名的变量，就会报错，在链接阶段，这时候只需要将一个变量声明为static就行。 因此一个编程建议是：除非你想要将一个文件跨文件链接，否则尽量将你的函数和变量声明为静态。 1.6.2 在类和结构体里 这种情况就分为静态变量和静态方法两种了。 类和结构体中的静态变量是所有实例共有的，每个实例有的是一个副本，访问静态变量需要通过类名::静态变量来访问。 静态方法的访问方式和上面一样，静态方法中不能访问类中的非静态变量。这个很好理解吧，因为静态方法同样不需要绑定实例，但是非静态变量是和实例有关的，显然是冲突的。 1.6.3 局部静态变量 这里的局部静态变量和我们在 1.6 static 中的有点不一样，这是指的是在函数内部定义的static变量。 我们可以看下面这段代码： int\u0026 getCounter() { static int count = 0; // 局部静态变量 count++; return count; } int main() { cout \u003c\u003c getCounter() \u003c\u003c endl; cout \u003c\u003c getCounter() \u003c\u003c endl; cout \u003c\u003c getCounter() \u003c\u003c endl; } 最后输出的是123。 这说明局部静态变量只会被初始化一次，之后调用函数会直接使用已经存在的变量。并且和普通局部变量一样，只能在函数内部访问。 有时候这个是非常有用的，对于简化代码写法的角度，例如如果我们需要写一个单例模式，我们使用之前的类的静态成员的写法，代码就得写成这样： class Singleton { public: static Singleton\u0026 getInstance() { return *instance; } private: static Singleton* instance; // 声明 }; Singleton* Singleton::instance = nullptr; // 类外初始化 但是如果我们使用局部静态变量，代码就可以直接简化为： class Singleton { public: static Singleton\u0026 getInstance() { static Singleton instance; // 局部静态变量，自动销毁 return instance; } }; 我们可以画一张两种方式的对比表： 特性 类的静态成员变量 局部静态变量 定义位置 类内声明，类外定义 函数内部 初始化时机 程序启动时 第一次执行到定义语句时 是否需要手动初始化 必须（类外） 不需要，自动初始化 作用域 类作用域（可全局访问） 函数内部 生命周期 整个程序运行期间 整个程序运行期间 ","date":"2025-08-29","objectID":"/c-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:2:6","tags":["编程"],"title":"c++学习笔记","uri":"/c-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["编程"],"content":"1.7 enum 这里我们先讲普通的enum： enum 的作用就是可以统一管理一些变量，将他们映射为整数（注意只能映射为整数），同时这个值都是如果未指定，默认是从0开始递增。 同时我们还可以通过:类型来指定值的实际存储类型，当然float不行。这样可以使用char来省空间有时候。就像下面写法这样： enum Status : unsigned char { Pending = 65, Success, Failed, // Success=66,默认递增 }; int main() { Status e = Success; if (e == Success) { std::cout \u003c\u003c e \u003c\u003c std::endl; } } 这样我们声明出来的Status e也不怕别人往里面写错误的值了，如果不用enum，直接通过int e，那么用户可以随意写不在enum范围内的值，比如1000，这样也不用写范围判断了。 有了这个工具，我们也就可以把之前写的简陋的log类来更新了： class Log { public: enum Level { LevelError, LevelWarn, LevelInfo }; void SetLevel(Level level) { log_level = level; } void Error(const std::string\u0026 message) { if (log_level \u003e= LevelError) std::cout \u003c\u003c \"[ERROR]: \" \u003c\u003c message \u003c\u003c std::endl; } void Warn(const std::string\u0026 message) { if (log_level \u003e= LevelWarn) std::cout \u003c\u003c \"[WARNING]: \" \u003c\u003c message \u003c\u003c std::endl; } void Info(const std::string\u0026 message) { if (log_level \u003e= LevelInfo) std::cout \u003c\u003c \"[INFO]: \" \u003c\u003c message \u003c\u003c std::endl; } private: Level log_level = LevelInfo; }; int main() { Log log; log.SetLevel(Log::LevelInfo); log.Error(\"called object type 'int' is not a function or function pointer\"); log.Warn(\"default member initializer for non-static data member is a C++11 extension [-Wc++11-extensions]\"); log.Info(\"1 warnings and 1 errors generated.\"); } TODO：补充一下 enum class ","date":"2025-08-29","objectID":"/c-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:2:7","tags":["编程"],"title":"c++学习笔记","uri":"/c-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["编程"],"content":"1.8 constructor 构造函数就是在创建对象的时候默认执行的方法，如果没有指定构造函数，就会默认一个空的publib类型的构造函数。 ","date":"2025-08-29","objectID":"/c-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:2:8","tags":["编程"],"title":"c++学习笔记","uri":"/c-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["编程"],"content":"1.9 destructor 构造函数的evil twin：析构函数 当销毁对象时，会自动运行析构函数。 析构函数和构造函数在声明和定义的唯一区别就是析构函数前面加上了~。一般用来在对象销毁时，主动释放一些堆上申请的空间。 ","date":"2025-08-29","objectID":"/c-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:2:9","tags":["编程"],"title":"c++学习笔记","uri":"/c-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["编程"],"content":"1.10 inheritance 可以近似理解为：子类 $ \\subseteq $ 父类（子类拥有父类中包含的所有内容（private除外））。 可以通过这样写来让子类继承某个父类class Child : public Parent 。这意味着此时的Child不但具有类型Child，而且具有类型Parent。 绝大多数情况下我们都使用的public继承 当然继承方式其实有两种，区别如下： 继承方式 父类 public 成员变成 父类 protected 成员变成 父类 private 成员 能否被孙类继承？ public 继承 子类的 public 成员 子类的 protected 成员 不可见 可以 private 继承 子类的 private 成员 子类的 private 成员 不可见 不可以 ","date":"2025-08-29","objectID":"/c-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:2:10","tags":["编程"],"title":"c++学习笔记","uri":"/c-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["编程"],"content":"1.11 virtual function 虚函数是为了实现多态，来让子类重写父类方法。（对应于Java语言中的@override注解） 如果我们直接这么写： class Parent { public: void say() { std::cout \u003c\u003c \"I am a parent\" \u003c\u003c std::endl; } }; class Child : public Parent { public: void say() { std::cout \u003c\u003c \"I am a child\" \u003c\u003c std::endl; } }; int main() { Parent* person = new Child(); person-\u003esay(); } // 运行结果：I am a parent 这说明虽然person对象有Child和Parent两个类型，但是编译器默认直接去声明的Parent类型中去找同名的方法。那么如何才能让编译器意识到，我们传入的其实是个Child，我们想调用的是Child中的方法呢？ 这就得靠虚函数了，虚函数引入了动态分配的概念，编译器通常通过一个VTABLE来实现它。VTABLE是一个包含我们父类中的虚函数的所有子类重写函数的映射的一张表，这样我们就能在运行时将他们映射到正确的重写函数。 使用虚函数很简单，我们只需要在父类的方法前面加上virtual，方法就会变成一个虚函数。而c++11中引入了override关键词，我们还可以在子类的重写方法后门加上override关键词（当然不是必须的，但是推荐加上，因为可以让编译器去帮我们检查子类的方法名有没有写错，是不是和父类中的某个方法一样等等）。 #include \u003ciostream\u003e #include \u003cstring\u003e class Parent { public: virtual void say() { std::cout \u003c\u003c \"I am a parent\" \u003c\u003c std::endl; } }; class Child : public Parent { public: void say() override { std::cout \u003c\u003c \"I am a child\" \u003c\u003c std::endl; } }; int main() { Parent* person = new Child(); person-\u003esay(); } // 运行结果：I am a child 当然我们需要承认的是，虚函数肯定不是free的，它有两种运行时成本：VTABLE的存储开消，以及查看VTABLE来确定具体映射到哪个重写函数的时间开销。 但是，绝大部分情况下，我们还没有到无法容忍虚函数开销的地步。 ","date":"2025-08-29","objectID":"/c-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:2:11","tags":["编程"],"title":"c++学习笔记","uri":"/c-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["编程"],"content":"1.12 pure virtual function c++中的接口是通过纯虚函数实现的。 纯虚函数的写法就像这样：virtual void say() = 0;，方法体不需要实现，留给子类去实现。并且父类由于并未实现这个方法，就无法直接创建父类对象。 ","date":"2025-08-29","objectID":"/c-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:2:12","tags":["编程"],"title":"c++学习笔记","uri":"/c-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["编程"],"content":"1.13 visibility c++中的可见性有三种:public、protected和private。 protected是指可以在父类和子类中访问，但是对象中不可见。 其实可见性最主要的作用其实是一种 code style。用户可以通过比如private立马知道这个不是暴露给用户的，这样看很多代码时可以忽略掉很多细节，主要看暴露给用户的API的public即可。 ","date":"2025-08-29","objectID":"/c-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:2:13","tags":["编程"],"title":"c++学习笔记","uri":"/c-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["编程"],"content":"1.14 string std::string name = \"thisingl\" c++中直接\"xxx\"默认是一个const char*类型，本身是在栈上分配空间，但是string又是一个引用类型，空间分配在堆上，于是默认会将const char*的内容复制到堆上分配的空间。 ","date":"2025-08-29","objectID":"/c-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:2:14","tags":["编程"],"title":"c++学习笔记","uri":"/c-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["编程"],"content":"1.15 const 你可以简单理解为：c++中的const，只是一种编译器级别的保护，对于最后产生生成的机器码完全没有影响。(编译优化除外) 大家肯定都知道const int a代表着变量a不可被修改，那const int* a、int const* a以及int* const a呢？ 分析 含义 const int* a 可以看作const (*a) 可以改变a指针，但是不能改变a指向的内容 int const* a 同const (*a) 同const int* a int* const a 可以看作const (a) 可以改变a指向的内容，但是不能改变a指针 const int* const a 可以看做const (*a) \u0026\u0026 const (a) 既不能改变a指针，也不能改变a指向的内容 int const* const a 同const (*a) \u0026\u0026 const (a) 同const int* const a 上面我们讨论的都是在变量中的使用，那你肯定不经想问，在类中有什么使用场景吗？ 有的兄弟，有的，例如下面： class Person { private: int age = 10; public: int GetAge() const { // age = 1; // 编译错误 return age; } }; void printPerson(const Person\u0026 p) { std::cout \u003c\u003c p.GetAge() \u003c\u003c std::endl; } 如果const放在方法后面，就代表我们的方法不会影响到对象本身。而const Person\u0026 p，意味着我们承诺我们不会修改对象p，那么此时我们只能访问p中被const修饰的方法，因为没有被const修饰的方法我们无法保证不会修改对象p。 但是有些时候，我们有一些用于调试的变量比如int var，我们的const修饰的方法可能也想修改他，但是我们能确保他不会影响到程序，这时候就很不方便了，我们又不想放弃将方法定义为const，这时候我们就可以使用下一次要讲到的mutable来完成他了！ ","date":"2025-08-29","objectID":"/c-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:2:15","tags":["编程"],"title":"c++学习笔记","uri":"/c-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["编程"],"content":"1.16 mutable mutable修饰的变量意味着可以修改，const方法中可以修改这种变量： class Person { private: mutable int age = 10; public: int GetAge() const { age = 1; return age; } }; void printPerson(const Person\u0026 p) { std::cout \u003c\u003c p.GetAge() \u003c\u003c std::endl; } 还有一种使用场景是在lambda表达式中修改按值传递的变量（非常非常少见，因为可以直接将这些变量设置为引用传递），所以我们就直接略过了。 ","date":"2025-08-29","objectID":"/c-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:2:16","tags":["编程"],"title":"c++学习笔记","uri":"/c-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["编程"],"content":"1.17 member initializer list 我们首先来看下面这段代码： class Entity { public: Entity() { std::cout \u003c\u003c \"Entity default constructor\" \u003c\u003c std::endl; } Entity(int a) { std::cout \u003c\u003c \"Entity int constructor\" \u003c\u003c std::endl; } }; class Person { private: Entity entity; public: Person() { entity = Entity(100); } }; int main() { Person p; } 问题来了，你认为最后打印输出的是什么呢？是Entity int constructor吗？ 答案是No，输出的是\"Entity default constructor\"和Entity int constructor。 是不是很疑惑，为什么我明明只调用了Entity(int a)这个构造函数，怎么还自动先调用了Entity()构造函数？？？ 答案是：c++中的成员变量在进入构造函数体时，会先被复制进来执行，也就是可以理解为上面的构造函数其实长这样： Person() { Entity entity; // 把private中内容移动到了这里（调用了构造器） entity = Entity(100); // 赋值操作 } 所以其实Entity的两个构造器都被调用了，很明显这个是一种资源的浪费，那么有没有办法解决了？ 聪明的c++创建者肯定考虑到了，所以提供了成员初始化列表这个语法。 当你在成员初始化列表中指定了如何构造成员变量，编译器就会使用你指定的方法，而不会默认执行一遍成员变量的默认构造函数了，这个的优先级最高。 使用方法如下： class Person { private: Entity entity; public: Person() : entity(Entity(100)){ // 成员初始化列表 } }; 此时运行就会发现，只会打印输出:Entity int constructor。 当然这个写法还涉及到一种代码风格，如果构造函数中的代码逻辑很复杂的话，那么简单的初始化复制逻辑就可以直接放在成员初始化列表中，这样就分离开来了。 ","date":"2025-08-29","objectID":"/c-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:2:17","tags":["编程"],"title":"c++学习笔记","uri":"/c-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["编程"],"content":"1.18 instantiate object c++中由于有栈和堆两个地址空间，所以实例化对象也有两种，对应的是一种在栈上申请空间，一种在堆上申请空间。 在栈上申请空间就是通过直接ClassName A(初始化参数)或者ClassName A = ClassName(初始化参数)。这时分配的空间在栈上，大家都知道进行方法调用时会伴随着压栈和出栈，当出栈时栈中的空间也就都释放了，所以很显然，栈上申请的空间只能存活在变量存在的生命周期中（这个变量前面的第一个{到后面的第一个}之间），一旦超过就会自动释放。所以适合空间小，而且不需要长期存在的变量，更推荐使用栈。 而堆上申请的空间上通过new和delete关键字进行管理，需要用户主动去释放空间，所以容易出现忘记释放空间导致内存泄漏的问题。通过直接ClassName* B = new ClassName(初始化参数)在堆上申请空间。这里指针上因为使用new申请空间会返回申请到的空间的初始地址。使用完毕后就需要使用delete(B)进行主动的释放。 对于Java中，由于有gg的存在，所以不需要主动释放，而且也不提供栈和堆两种空间申请方式，统一使用堆，所以和c++中有点不一样。而c++中后面提到的智能指针可以在一定程度上完成像Java中这种在堆上申请空间并且主动释放的功能。 ","date":"2025-08-29","objectID":"/c-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:2:18","tags":["编程"],"title":"c++学习笔记","uri":"/c-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["编程"],"content":"1.19 implicit conversion c++中有一个独特的特性：隐式转换。这是Java中没有的。 我们先看一段代码： class Person { private: std::string name; int age; public: Person(const std::string\u0026 name) : name(name), age(-1) { } Person(int age) : name(\"Unknown\"), age(age) { } }; 我们知道Person p = Person(100)肯定是正确的，那如果偷个懒，直接写成Person p = 100，请问这个写法对吗？ 如果从Java等其他语言的角度来看，这肯定错啊，100怎么可能能赋值给一个对象，但是先别急，我们刚刚提到的隐式转换说的就是这个，当给对象赋值的时候，如果直接传入一个值，就会自动尝试去调用他的构造函数，也就是Person(int age){}了，也就是说这两种写法其实是等价的。 那么理解到这里，我再问你一个问题，Person p = \"thisingl\"对吗？先别急着下结论噢，我们先来看看这个情况和我们刚刚Person p = 100的情况一样吗？聪明的你肯定发现了一个语法细节了，\"thisingl\"其实是const char[]类型的，这里就已经有一次默认的隐式抓换了，从const char[]-\u003estring，然后再进行一次隐式转换，从string-\u003ePerson(const std::string\u0026 )，而c++中规定：最多只能进行一次隐式转换，所以这个写法是错误的，我们可以写成：Person p = std::string(\"thisingl\")，就可以避免第一次隐式转换。 当然直接这么写其实很多时候很奇怪给人，就是会增加人的理解成本，所以其实用的还是比较少的，感觉可能在一些数学场景下用的比较多 ","date":"2025-08-29","objectID":"/c-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:2:19","tags":["编程"],"title":"c++学习笔记","uri":"/c-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["编程"],"content":"1.20 explicit explicit上显示关键词，他可以支持让用户不允许某些情况下的隐式调用，比如如果上面改成： class Person { private: std::string name; int age; public: explicit Person(const std::string\u0026 name) : name(name), age(-1) { } Person(int age) : name(\"Unknown\"), age(age) { } }; 那么这时候这样写就会报错：Person p = std::string(\"thisingl\") ","date":"2025-08-29","objectID":"/c-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:2:20","tags":["编程"],"title":"c++学习笔记","uri":"/c-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["编程"],"content":"1.21 operator overload c++中提供了一个很强大的，其他语言基本上没有的功能：操作符重载。 也就是说在c++中，我们可以赋予像+、*或者\u003e\u003e等操作符另外的含义，这样有时候会简化很多特别繁琐的情况，特别是数学计算等领域。 假设我们有下面这样一个二维向量类： class Vector { public: float x, y; Vector(float x, float y) : x(x), y(y) {} Vector Add(const Vector\u0026 other) const { return Vector(x + other.x, y + other.y); } Vector Multiply(const Vector\u0026 other) const { return Vector(x * other.x, y * other.y); } }; 我们有下面这三个向量： Vector position(4.0f, 4.0f); Vector speed(0.5f, 1.5f); Vector powerup(1.1f, 1.1f); 如果我们想要计算一个position + speed * powerup的结果，在Java等语言中只能写成这样：Vector result1 = position.Add(speed.Multiply(powerup))，这个写法看看就不知道到底在做啥数学运算了，很容易看晕如果更复杂的话，我们只想要直观的计算，而不想看到这样的方法调用。好消息是，C++中的操作符重载在这种场景下就非常方便了，我们改写一下二维向量类： class Vector { public: float x, y; Vector(float x, float y) : x(x), y(y) {} Vector Add(const Vector\u0026 other) const { return *this + other; } Vector operator +(const Vector\u0026 other) const { return Vector(x + other.x, y + other.y); } Vector Multiply(const Vector\u0026 other) const { return *this * other; } Vector operator *(const Vector\u0026 other) const { return Vector(x * other.x, y * other.y); } }; 这时候我们只需要这样调用即可：Vector result2 = position + speed * powerup 是不是简单太多了。当然我们还可以改写std::cout \u003c\u003c 中的\u003c\u003c操作符来达到直接输出这个二维向量的功能，以及重写==操作符来达到比较两个二维向量的功能。 ","date":"2025-08-29","objectID":"/c-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:2:21","tags":["编程"],"title":"c++学习笔记","uri":"/c-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["编程"],"content":"1.22 this c++中的this的用法和Java中有点不同，c++中的this本质上是ClassName * const this类型的，所以它访问类中变量是用this-\u003ex，Java中一般是this.x。 ","date":"2025-08-29","objectID":"/c-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:2:22","tags":["编程"],"title":"c++学习笔记","uri":"/c-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["编程"],"content":"1.23 object lifetime 之前在1.18 instantiate object中我们就已经讨论过了栈和堆两种申请空间方式的区别。 但是之前讲的对栈的使用太浅了，因为那只是将对象的空间申请到栈上，但是也提到了栈的空间比较小，那么有没有办法和堆结合起来呢？我们又想要堆的大空间，又想要栈这种超过使用范围就自动销毁的能力？ 聪明的你一定想到了，我们可以用栈上的指针指向堆中的空间呀，一旦出栈就调用析构函数去释放掉堆上空间。 比如我们可以设计一个这样的作用域指针： class Entity { public: Entity() { std::cout \u003c\u003c \"Entity created\" \u003c\u003c std::endl; } ~Entity() { std::cout \u003c\u003c \"Entity destroyed\" \u003c\u003c std::endl; } }; class ScopedPtr { public: ScopedPtr(Entity* entity) : e_ptr(entity) {} ~ScopedPtr() { delete e_ptr; } private: Entity* e_ptr; }; 我们就可以直接创建这样一个作用域指针ScopedPtr e = new Entity()，自动在作用域结束后就会释放掉Entity变量所占的空间。 当然智能指针的功能更加强大，我们这里只是简单的演示它的一个小功能。 ","date":"2025-08-29","objectID":"/c-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:2:23","tags":["编程"],"title":"c++学习笔记","uri":"/c-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["编程"],"content":"1.24 smart pointer c++中的智能指针主要有：unique_ptr、shared_ptr和weak_ptr。 我们首先来聊一聊unique_ptr，这个就是我们刚刚演示过的一个简单的作用域指针，自动会在作用域结束后就会释放掉堆上空间，看看下面这段代码： class Entity { public: Entity() { std::cout \u003c\u003c \"Entity created\" \u003c\u003c std::endl; } ~Entity() { std::cout \u003c\u003c \"Entity destroyed\" \u003c\u003c std::endl; } }; int main() { // std::unique_ptr\u003cEntity\u003e entity(new Entity()); // 不推荐写法 std::unique_ptr\u003cEntity\u003e entity = std::make_unique\u003cEntity\u003e(); // 推荐写法 } 这里申请unique_ptr指向的空间时推荐使用make_unique申请空间，因为会更加安全。一开始 C++11 只有 make_shared，没有 make_unique，是因为 make_unique 没有性能优势（不像 make_shared 可以少分配一次内存），但后来大家发现安全性问题太多，于是 C++14 才正式引入。 原因就是如果直接std::unique_ptr\u003cEntity\u003e entity(new Entity())，那么假设在堆上申请完new Entity()空间后，还没来得及构造std::unique_ptr\u003cEntity\u003e entity指向刚刚申请的空间，就出现异常，那么申请的空间就忘记自动释放了，造成了内存泄漏。而如果使用 std::make_unique\u003cEntity\u003e()来申请内存，那么就能保证不会出现刚刚的问题。 同时一个对象只能被一个unique_ptr拥有，那么你肯定好奇c++是怎么做到这么确保的呢？其实很简单，unique_ptr的实现中删除了=运算符，也就导致了不能被拷贝了，自然也就可以做到这个独占所有权，这也是名字中的unique的由来。 下面我们再看看shared_ptr，这种智能指针就能够让多个指针指向同一个对象，他的具体实现和编译器有关，但是大部分都是使用了所谓的引用计数，也就是当最后一个指向这个对象的shared_ptr被销毁时，才会释放内存。 用法如下： int main() { std::shared_ptr\u003cEntity\u003e entity1; { std::shared_ptr\u003cEntity\u003e entity2 = std::make_shared\u003cEntity\u003e(); entity1 = entity2; } // 执行到这里不会释放空间 } // 执行到这里才会释放空间 这里使用std::make_shared来申请空间不但是为了安全，同时还有性能差异： std::make_shared\u003cT\u003e(...) 会一次性分配一块内存，同时存放对象和引用计数控制块。 std::shared_ptr\u003cT\u003e(new T(...)) 会分配两次： new T(...) 分配对象 内部再分配一块内存存放引用计数控制块 weak_ptr一般和shared_ptr一块使用，他的特点是不会增加引用计数，同时通过使用lock()方法可以知道对象是否还存活，不存活就会返回空指针。 ","date":"2025-08-29","objectID":"/c-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:2:24","tags":["编程"],"title":"c++学习笔记","uri":"/c-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["编程"],"content":"1.25 copy constructor 要想搞清楚什么是拷贝构造函数，我们就得先看看为什么需要它。 我们先来看下面一个类： class String { private: char* buffer; unsigned int b_Size; public: String(const char* string) { // 构造函数 b_Size = strlen(string); buffer = new char[b_Size + 1]; memcpy(buffer, string, b_Size + 1); } ~String() { // 析构函数：释放空间 delete[] buffer; } void getBuffer() { // 打印 buffer 内容 std::cout \u003c\u003c buffer \u003c\u003c std::endl; } }; 如果我们这样调用，程序会发生什么： int main() { String first = \"thising\"; String second = first; first.getBuffer(); second.getBuffer(); } 答案是：在打印完两次\"thising\"之后，程序出现了未知的错误，程序崩溃了！ 是不是非常的Interesting? 要想知道这里为什么报错了，我们就得先了解程序中两个非常重要的概念：浅拷贝和深拷贝 浅拷贝（Shallow Copy） ​ 浅拷贝就是只复制对象的成员变量的值，而不复制指针所指向的实际数据。也就是说，如果对象中有指针成员，浅拷贝只会复制指针的值（地址），而不会新建一块内存来存放数据。 深拷贝（Deep Copy） ​ 深拷贝不仅复制成员变量的值，还会为指针成员分配新的内存空间，并将原指针指向的数据复制到新的内存中。 而我们刚刚进行的String second = first，其实就是一次浅拷贝，这是因为在所有的类中，有一个特殊的构造函数，叫做拷贝构造函数的存在，函数具体就长这样： class A { public: A(const A\u0026 other) { // 这里写如何从 other 复制成员 } }; 这里如果说我们没有显示去重写这个拷贝构造函数，编译器就会默认帮我们生成一个默认的浅拷贝构造函数。 那么根据浅拷贝的定义，就很容易知道first.buffer和second.buffer其实指向同一片内存区域，因此在函数运行结束后，会调用2次析构函数，对同一块内存区域释放两次！因此出现了未定义行为，导致了程序崩溃。 那么这里我们的本意肯定是希望使用的是深拷贝，因此我们就得重写拷贝构造函数了，代码如下： class String { private: char* buffer; unsigned int b_Size; public: String(const char* string) { b_Size = strlen(string); buffer = new char[b_Size + 1]; memcpy(buffer, string, b_Size + 1); } String(const String\u0026 other) // 拷贝构造函数 :b_Size(other.b_Size) { buffer = new char[b_Size + 1]; // 申请新的空间 memcpy(buffer, other.buffer, b_Size + 1); } ~String() { delete[] buffer; } void getBuffer() { std::cout \u003c\u003c buffer \u003c\u003c std::endl; } }; 此时再次运行之前的main函数，便不会报错了，由此大功告成 ","date":"2025-08-29","objectID":"/c-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:2:25","tags":["编程"],"title":"c++学习笔记","uri":"/c-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["编程"],"content":"1.26 vector std::vector是c++中的标准库中的动态数组，但是却叫向量这个名字属实有点奇怪啊哈哈哈 基本用法我们就不说了，废话不多说，我们先看一段新手的经常写法： class Vertex { public: int x, y, z; Vertex(int x, int y, int z) : x(x), y(y), z(z) { } Vertex(const Vertex\u0026 other) // 改造拷贝构造函数来看看复制了几次 : x(other.x), y(other.y), z(other.z) { std::cout \u003c\u003c \"do a copy\" \u003c\u003c std::endl; } }; int main() { std::vector\u003cVertex\u003e vertices; vertices.push_back(Vertex(1, 2, 3)); vertices.push_back(Vertex(4, 5, 6)); vertices.push_back(Vertex(7, 8, 9)); } Q. 请问do a copy会被打印多少次呢？ A. 6次！是不是很神奇，卧槽为啥会被复制了6次呢？这不得非常的废时间，因为对象的复制操作其实挺慢的。 首先我们得先明白std::vector的扩容策略，当然这和编译器有关，我这台win电脑上是默认一开始是没有空间的，每次扩容是按照2的倍速递增。当执行第一次push_back时，由于一开始没有空间，会分配 capacity=1 的空间，当然这次扩容并没有用到复制操作。当执行第二次push_back时，由于空间只有1，所以又会扩容，分配 capacity=2 的空间，这时候会将之前的Vertex(1, 2, 3)复制到新的空间里，复制操作**+1**。当执行第三次push_back时，由于空间只有2，所以又会扩容，分配 capacity=4 的空间，这时候会将之前的Vertex(1, 2, 3)和Vertex(4, 5, 6)复制到新的空间里，复制操作**+2**。 所以上诉扩容策略导致了3次复制操作，有没有办法能优化一下这个性能呢？ 有的兄弟有的，那就是试用reserve(3)去预分配用户想要的空间啊，注意不是使用的resize()，因为会影响到size，我们只想要空间，不想改变目前的节点数。 因此当我们使用下面的写法： int main() { std::vector\u003cVertex\u003e vertices; vertices.reserve(3); vertices.push_back(Vertex(1, 2, 3)); vertices.push_back(Vertex(4, 5, 6)); vertices.push_back(Vertex(7, 8, 9)); } 运行后果然，只打印了3次了！ 那么这3次又是哪里来的呢？这是由于当我们使用push_back(Vertex(1, 2, 3))时，Vertex(1, 2, 3)分配的空间是在main中的，而std::vector的空间是独有的，那么就会出现一次复制，将Vertex(1, 2, 3)从外面拷贝到std::vector的空间中。push_back总共执行了3次，所以这里也就打印了3次啊！ 那么这里的复制是不是也是没必要的，聪明的你一定想要了，为什么不直接在std::vector的空间中创建对象呢？所以emplace_back()方法就应运而生了，你不需要传递一个对象进来，因为std::vector在声明的时候就已经绑定了类型了，因此知道类型只需要传入构造函数的参数就可以依靠emplace_back(1, 2, 3)在内部空间中直接创建了，也就少掉了1次没有必要的复制操作。 因此优化的代码如下： int main() { std::vector\u003cVertex\u003e vertices; vertices.reserve(3); vertices.emplace_back(1, 2, 3); vertices.emplace_back(4, 5, 6); vertices.emplace_back(7, 8, 9); } 非常完美！现在什么都不打印了，说明一次都没有复制了。 ","date":"2025-08-29","objectID":"/c-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:2:26","tags":["编程"],"title":"c++学习笔记","uri":"/c-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["编程"],"content":"1.27 pair \u0026\u0026 tuple std::pair\u003cint, std::string\u003e p = (0, \"thising\")可以用来保存两个不同类型的值 std::tuple\u003cint, std::string, double\u003e t(1, \"pi\", 3.1415)可以用来包含任意数量和类型的值 ","date":"2025-08-29","objectID":"/c-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:2:27","tags":["编程"],"title":"c++学习笔记","uri":"/c-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["编程"],"content":"1.28 template 模版是一个高级主题，非常的复杂，这里我们只是简单的使用。 我们首先考虑下面这种实际编程的场景： void print(int value) { std::cout \u003c\u003c value \u003c\u003c std::endl; } void print(std::string value) { std::cout \u003c\u003c value \u003c\u003c std::endl; } int main() { print(100); print(\"thising\"); } 如果还需要支持更多的类型，就需要一直去重载，但是此时我们观察这些重载的方法，其实有区别的地方只有变量类型呀，这时候你不经好奇，能不能有这样一种功能：我们写好一个类似于模版的东西，大家只需要根据自己的实际使用，去微调一下这个模版中的个别关键的地方，比如把名字换掉，不就成自己的方法了？ 恭喜你！你发明了模版template。 上面的代码如果我们使用模版来写，就会很简洁： template\u003ctypename T\u003e void print(T value) { std::cout \u003c\u003c value \u003c\u003c std::endl; } int main() { print\u003cint\u003e(100); print\u003cstd::string\u003e(\"thising\"); } 模版只有在被实际调用的时候，才会生成相应的方法代码。当然现在的编译器检查变多了，也会检查模版的语法问题了，之前如果你写一个有语法错误的模版代码，只要不调用，编译运行就不会报错。 当然模版不仅只能生成我们想要的方法，还可以生成我们想要的类，比如下面这样： template\u003ctypename T, int N\u003e class Array { private: T m_Array[N]; }; 同时我们要明白：模版不应该被滥用，当发现错误的时候，模版调试时是比较困难的，同时可读性也不如重载，但是它足够简洁 ","date":"2025-08-29","objectID":"/c-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:2:28","tags":["编程"],"title":"c++学习笔记","uri":"/c-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["编程"],"content":"1.29 function pointer c++中有函数指针的概念，也就是我们的指针不仅可以指向一个变量，也可以指向一个函数，如下所示： void PrintValue(int value) { std::cout \u003c\u003c value \u003c\u003c std::endl; } int main() { auto func = PrintValue; // PrintValue代表函数本身，PrintValue()代表函数调用 func(10); } 这里的auto其实是void(*function)类型的，因此其实本质上是： void PrintValue(int value) { std::cout \u003c\u003c value \u003c\u003c std::endl; } int main() { void(*func)(int) = PrintValue; func(10); } 知道了上面这个语法，我们就可以更进一步了，让函数变得更加的灵活！将函数的参数设置为另一个函数，这样用户在使用的时候就可以对一套大的函数逻辑进行个性化修改了使用了，不得不佩服c++的灵活性。 下面是一段简单的代码示范： void PrintValue(int value) { std::cout \u003c\u003c value \u003c\u003c std::endl; } void ForEach(const std::vector\u003cint\u003e\u0026 values, void(*func)(int)) { for (int value : values) { func(value); } } int main() { std::vector\u003cint\u003e values = {1, 2, 3, 4, 5}; ForEach(values, PrintValue); } ","date":"2025-08-29","objectID":"/c-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:2:29","tags":["编程"],"title":"c++学习笔记","uri":"/c-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["编程"],"content":"1.30 lambda 想要了解lambda表达式，首先得了解1.29 函数指针，知道一个函数的参数还可以是另一个函数。 lambda表达式就是为了简化之前的语法，当我们将函数的参数设置为另一个函数时，这个工具函数的名字似乎并没有什么意义，因此可以在用户使用时进行简化。 C++中的lambda表达式语法是这样的： [capture](parameter_list) -\u003e return_type { function_body }; 这里的捕获列表（capture）有下面几种类型： 写法 含义 [] 不捕获，不访问外部变量 [x] 按值捕获，只捕获变量x [\u0026x] 按引用捕获,只捕获变量x [=] 按值捕获所有外部变量 [\u0026] 按引用捕获所有外部变量 那么上面我们在 1.29 函数指针 中的代码就可以简化为： void ForEach(const std::vector\u003cint\u003e\u0026 values, void(*func)(int)) { for (int value : values) { func(value); } } int main() { std::vector\u003cint\u003e values = {1, 2, 3, 4, 5}; auto lambda = [](int value) { std::cout \u003c\u003c value \u003c\u003c std::endl; }; ForEach(values, lambda); } 那么有时候我们会写一种更特殊的 lambda 表达式：涉及到递归调用的函数 这时候就有一个问题，比如下面代码： struct TreeNode { int val; TreeNode *left; TreeNode *right; TreeNode() : val(0), left(nullptr), right(nullptr) {} TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} }; int main() { // 构造一棵树 // 2 // / \\ // 1 3 TreeNode* root = new TreeNode(2, new TreeNode(1), new TreeNode(2)); auto dfs = [\u0026](TreeNode* root) -\u003e void { if (root == nullptr) return; dfs(root-\u003eleft); std::cout \u003c\u003c root-\u003eval; dfs(root-\u003eright); } return 0; } 你感觉上面的代码会有问题吗？ 你们看，其实 dfs 作为一个函数名，lambda表达式内部是感知不到的呀！所以会报错： main.cc:24:9: error: variable 'dfs' declared with deduced type 'auto' cannot appear in its own initializer 24 | dfs(root-\u003eleft); | ^ 这时候我们得将它作为参数传递进来，才能让函数感知到它本身的存在 c++23之前，我们需要写成下面这样： struct TreeNode { int val; TreeNode *left; TreeNode *right; TreeNode() : val(0), left(nullptr), right(nullptr) {} TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} }; int main() { // 构造一棵树 // 2 // / \\ // 1 3 TreeNode* root = new TreeNode(2, new TreeNode(1), new TreeNode(3)); auto dfs = [\u0026](auto\u0026\u0026 dfs, TreeNode* root) -\u003e void { if (root == nullptr) return; dfs(dfs, root-\u003eleft); std::cout \u003c\u003c root-\u003eval \u003c\u003c \" \"; dfs(dfs, root-\u003eright); }; dfs(dfs, root); return 0; } 每次都得把函数本身传递进来，很不优雅，于是 C++23 引入了新语法：显式对象参数（deducing this），现在我们可以写成： struct TreeNode { int val; TreeNode *left; TreeNode *right; TreeNode() : val(0), left(nullptr), right(nullptr) {} TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} }; int main() { // 构造一棵树 // 2 // / \\ // 1 3 TreeNode* root = new TreeNode(2, new TreeNode(1), new TreeNode(3)); auto dfs = [\u0026](this auto\u0026\u0026 dfs, TreeNode* root) -\u003e void { if (root == nullptr) return; dfs(root-\u003eleft); std::cout \u003c\u003c root-\u003eval \u003c\u003c \" \"; dfs(root-\u003eright); }; dfs(root); return 0; } ","date":"2025-08-29","objectID":"/c-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:2:30","tags":["编程"],"title":"c++学习笔记","uri":"/c-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["编程"],"content":"1.31 namespace 命名空间是c++中有的而c中没有的，这个特性确实是大型软件开发时必备的特性。 对于c中没有命名空间，那么就得自己去保证自己写的代码中的方法名或者变量名等不能有重复，有些项目比如 GL，就会把它的每一个库函数的方法名写成GL_XXX，来保证大概率不会发生重复，但是这样其实是很难受不优雅的做法，因此c++中增加了命名空间的功能来隔绝同名函数。 比如下面这段代码： namespace apple { void print() { std::cout \u003c\u003c \"apple\" \u003c\u003c std::endl; } } namespace orange { void print() { std::cout \u003c\u003c \"orange\" \u003c\u003c std::endl; } } int main() { apple::print(); orange::print(); } 我们就可以在apple和orange两个不同的命名空间中去定义同名函数了，是不是非常的方便！ 甚至我们可以更灵活的进行使用嵌套的命名空间（当然非常的少见，仅作功能演示）： namespace fruit { namespace apple { void print() { std::cout \u003c\u003c \"apple\" \u003c\u003c std::endl; } } namespace orange { void print() { std::cout \u003c\u003c \"orange\" \u003c\u003c std::endl; } } } int main() { fruit::apple::print(); fruit::orange::print(); } 甚至可以把命名空间赋给一个变量使用（更少见了）： int main() { namespace a = fruit::apple; namespace o = fruit::orange; a::print(); o::print(); } 另外我们这里需要讨论一个重要的事情，为什么尽量不要使用using namespace XXX？ 一个重要的原因是这样会把整个命名空间中的所有内容引入进来，那不又出现和一开始一样的问题吗：重名问题？ 同时就算不重名，那有可能引入更可怕的问题了：编译没问题，但是运行结果和想要的不一样？ 我们看看下面这个例子就知道这种问题有多么难排查了： namespace a { // 直接打印 void print(const std::string\u0026 str) { std::cout \u003c\u003c str \u003c\u003c std::endl; } } namespace b { // 反转并打印 void print(const char* str) { std::string tmp = str; std::reverse(tmp.begin(), tmp.end()); std::cout \u003c\u003c tmp \u003c\u003c std::endl; } } using namespace a; using namespace b; int main() { print(\"hello\"); } Q: 大家猜猜最后打印输出的是什么呢？ A: olleh。哈哈哈为什么明明先引入的命名空间是a,我们却调用了b中的函数呢？那是因为\"hello\"本质上是const char[]，而a中想调用print(\"hello\")，需要进行一次我们在 1.19 隐式转换 中提到的隐式转换，那么编译器就会认为b中的print(const char*)更匹配，那么你看是不是非常容易出错呢？纠错又极其的困难。 因此我们建议：如果使用using namespace，也请在足够小的范围内使用，这样不会影响其他的部分。 ","date":"2025-08-29","objectID":"/c-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:2:31","tags":["编程"],"title":"c++学习笔记","uri":"/c-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["编程"],"content":"1.32 thread 终于进入到多线程的情况了，实际编程遇到这种的时候，已经是比较复杂的情况了，我们首先来看看std::thread的语法： std::thread t(func, args...) 我们需要传入一个函数func，后面的args是这个函数的传参。 当然这个传参有两种情况: func args func(int x) x func(int* x) \u0026x func(int\u0026 x) std::ref(x) 这里为什么是std::ref(x)?我们可以讲一讲：std::thread 默认会把参数拷贝一份给新线程，std::ref(x) 的意思就是“请当成引用传进去”。 所以直接使用可以如下： void func(int\u0026 a) { for (int i = a; i \u003c 10; i ++) { std::cout \u003c\u003c i \u003c\u003c std::endl; } } int main() { int begin = 1; std::thread worker(func, std::ref(begin)); worker.join(); } 当然如果用上我们 1.30 lambda 中讲到的，就可以更简单了： int main() { int begin = 1; std::thread worker([](int\u0026 a) { for (int i = a; i \u003c 10; i ++) { std::cout \u003c\u003c i \u003c\u003c std::endl; } }, std::ref(begin)); worker.join(); } ","date":"2025-08-29","objectID":"/c-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:2:32","tags":["编程"],"title":"c++学习笔记","uri":"/c-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["编程"],"content":"1.33 type punning 在 C++ 中，type punning（类型双关） 指的是通过不同的数据类型来访问同一块内存的操作。 我们先来看一下下面这段代码： int main() { int a = 50; double\u0026 value = *(double*)\u0026a; value = 0.0; } 我们先来分析一下上面的代码。首先变量a的类型是int，系统会分配 4 个字节的地址。然后这里的(double*)\u0026a是说把地址a上的空间按照double类型去读取，也就是读取 8 个字节的内容并解读成double类型。这里的value = 0.0也就是向a所在的地址写入 8 字节数据。显然这是一种类型欺骗（type punning）+ 内存越界的组合，导致未定义行为。 当然上面的写法在编译器眼中，等价于下面的写法： int main() { int a =50; double\u0026 value =*reinterpret_cast\u003cdouble*\u003e(\u0026a); // 等价于*(double*)\u0026a，语义更加清晰 value = 0.0; } 直接使用reinterpret_cast\u003c\u003e()的语义更加清晰，一眼就能知道这里是在做类型转换，之前那个又是*又是\u0026，得费很大功夫才能知道这是在做类型转换。 当然类型转换更主要的作用是把一串连续的二进制或者申请到的空间类型，用某种我们指定的类型去解读，比如下面这种： struct MessageHeader { uint32_t len; uint16_t type; uint16_t flags; }; const char* buf = receive_from_socket(); // 接收到一块原始二进制数据 // reinterpret_cast直接把buffer解释成结构体指针 auto header = reinterpret_cast\u003cconst MessageHeader*\u003e(buf); ","date":"2025-08-29","objectID":"/c-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:2:33","tags":["编程"],"title":"c++学习笔记","uri":"/c-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["编程"],"content":"1.34 union union（联合体）是一种特殊的类类型（类似于 struct），它的所有成员 共用同一段内存空间（union 所占的内存大小 == 其最大成员的大小）。也就是说，一个 union 在任意时刻只能“存”一个成员的值。 我们先来看一段简单的代码： union UnionName { int i; float f; char c; }; int main() { UnionName u; u.i = 100; std::cout \u003c\u003c u.i \u003c\u003c std::endl; // 100 std::cout \u003c\u003c u.f \u003c\u003c std::endl; // 1.4013e-43 std::cout \u003c\u003c u.c \u003c\u003c std::endl; // d } 按照我们上面的定义来看，此时 u 的空间大小应该是 4 个字节。然后我们将 u 中的变量 i 赋值为 100，100 在内存中的二进制表示是:00000000 00000000 00000000 01100100，然后由于是小端序，因此我们的内存空间的十六进制形式应该长这样：64 00 00 00。如果我们访问 u.i，就是将这段内存空间从头，按照 int 的格式去解读，那么显然就是 100。而如果我们访问 u.f，那就是按照 float 的格式去解读，那么按照浮点数的格式来读，就是上面输出的令我们疑惑的 1.4013e-43。以及我们访问 u.c，那其实就是只读取了一开头的一个字节内容，按照 ASCII 去解读下来就是 d。 当然啊，看到这里，很多同学就会有疑惑，这不就和我们在 1.33 type punning 中提到的 reinterpret_cast\u003c\u003e() 干的事情一样吗？都是把一块内存用不同的类型去解读。确实你的疑惑是正确的，在编译器看来，这两者翻译成的汇编代码都一样，也就是性能也完全一样。当然本质上我们上面提到过：reinterpret_cast\u003cdouble\u003e(\u0026a) 的语义比起 (double*)\u0026a 更加清晰，也就是多了一层抽象，而我们在这里引入 union，其实也是一种抽象啊只是，union 中这段内存空间可以解读成的类型都被我们规定好了，一眼就知道了，是不是更加清晰！ 以及在实际使用中，我们经常的一种使用方法是: 假如我们读取了一段网络包，网络包可以有不同的内容解读方式，就可以使用这种 union 的方式去简化，这样就不用怕整条链路上可能有不同类型的变量在传输了。具体代码如下： struct Packet { enum Type { INT = 1, FLOAT = 2, STR = 3 } type; union Data { int i; float f; char s[8]; } data; }; int main() { Packet p; // 使用时： p.type = Packet::FLOAT; p.data.f = 3.14f; // 读取时： if (p.type == Packet::FLOAT) { std::cout \u003c\u003c p.data.f \u003c\u003c std::endl; } } ","date":"2025-08-29","objectID":"/c-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:2:34","tags":["编程"],"title":"c++学习笔记","uri":"/c-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["编程"],"content":"1.35 virtual destructor 前面我们介绍过虚函数，这里我们要介绍的是一个很像，但是不一样的特性：虚析构函数 我们先来看一段代码： class Base { public: Base() { std::cout \u003c\u003c \"Base: constructor\" \u003c\u003c std::endl; } ~Base() { std::cout \u003c\u003c \"Base: destructor\" \u003c\u003c std::endl; } }; class Derived : public Base { public: Derived() { std::cout \u003c\u003c \"Derived: constructor\" \u003c\u003c std::endl; } ~Derived() { delete[] m_data; std::cout \u003c\u003c \"Derived: destructor\" \u003c\u003c std::endl; } private: int* m_data = new int[1000]; }; int main() { Base* base = new Base(); delete base; std::cout \u003c\u003c \"----------------\" \u003c\u003c std::endl; Derived* derived = new Derived(); delete derived; std::cout \u003c\u003c \"----------------\" \u003c\u003c std::endl; Base* poly = new Derived(); delete poly; } Q. 你认为输出的结果是什么？ 答案是： [thisingl@MacBook-Pro cpp] % g++ -std=c++17 main.cc -o main \u0026\u0026 ./main Base: constructor Base: destructor ---------------- Base: constructor Derived: constructor Derived: destructor Base: destructor ---------------- Base: constructor Derived: constructor Base: destructor 从输出中我们可以看出来，如果我们这样申明：Derived* derived = new Derived();，那么当结束生命周期的时候，就是我们想要的结果：同时调用子类和父类的析构函数。而如果我们是使用多态的方式来生命：Base* poly = new Derived();，此时当结束生命周期时，很神奇的是，编译器似乎不智能了，只调用声明的类型（父类）的析构函数，此时实际类型（子类）的析构函数给遗漏掉了，直接造成了内存泄漏！ 聪明的你很快发现了，这种情况和我们之前使用虚函数方法的场景很像，但是这里有一点不一样，虚函数方法是通过子类重写函数的映射表VTABLE来进行动态分配，但是这里不是重写方法，而是同时执行这两个析构函数。 所以此时我们在父类方法上加上virtual，其他地方保持不变，此时再次运行下面代码： class Base { public: Base() { std::cout \u003c\u003c \"Base: constructor\" \u003c\u003c std::endl; } virtual ~Base() { // 加上虚析构函数 std::cout \u003c\u003c \"Base: destructor\" \u003c\u003c std::endl; } }; class Derived : public Base { public: Derived() { std::cout \u003c\u003c \"Derived: constructor\" \u003c\u003c std::endl; } ~Derived() { delete[] m_data; std::cout \u003c\u003c \"Derived: destructor\" \u003c\u003c std::endl; } private: int* m_data = new int[1000]; }; int main() { Base* base = new Base(); delete base; std::cout \u003c\u003c \"----------------\" \u003c\u003c std::endl; Derived* derived = new Derived(); delete derived; std::cout \u003c\u003c \"----------------\" \u003c\u003c std::endl; Base* poly = new Derived(); delete poly; } 此时输出的就是我们想要的了： [thisingl@MacBook-Pro cpp] % g++ -std=c++17 main.cc -o main \u0026\u0026 ./main Base: constructor Base: destructor ---------------- Base: constructor Derived: constructor Derived: destructor Base: destructor ---------------- Base: constructor Derived: constructor Derived: destructor Base: destructor 因此，如果我们想要一个类允许被继承，一定要将父类的虚函数申明为虚函数，否则就没有人可以安全的拓展继承这个类，甚至包括你自己！ ","date":"2025-08-29","objectID":"/c-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:2:35","tags":["编程"],"title":"c++学习笔记","uri":"/c-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["编程"],"content":"1.36 casting 下面我们来讲讲 C++ 的所有类型转换（casting） 首先我们先来看看 C 语言风格的类型转换： int main() { double x = 3.14; int n = (int)x; std::cout \u003c\u003c n \u003c\u003c std::endl; } 多么的优雅、简单、暴力美学（不是） 它的问题其实非常多： ❌ 它太强了 ❌ 它隐藏太多行为 ❌ 它可能执行 static_cast / reinterpret_cast / const_cast 的任意组合 ❌ 不安全、难排查 bug 所以不适合现代化的 C++ 了 C++ 提供了 四种更安全、语义更明确的转换： cast 是否安全 用途 static_cast ✔相对安全 普通类型转换、隐式转换显式化 reinterpret_cast ❌极危险 仅做“比特级重新解释” const_cast ⚠局部危险 移除 const/volatile dynamic_cast ✔最安全 RTTI：运行时判断是否能转成某个类型 我们按照推荐的使用顺序来介绍吧： 首先我们先看看 static_cast，这是编译期能判断的安全转换。 它常用于简单的数字类型转换： 比如刚刚上面的代码就可以写成更安全的： int main() { double x = 3.14; int n = static_cast\u003cint\u003e(x); std::cout \u003c\u003c n \u003c\u003c std::endl; } 也可以将 void* 转为具体类型： void* p = ...; int* ip = static_cast\u003cint*\u003e(p); 但是 static_cast 对于基类指针 → 派生类指针的情况，是不安全的，需要使用下面的 dynamic_cast 下面我们来看看 dynamic_cast，这是运行时安全检查（用于继承） 这是唯一带 运行时检查 的 cast。 用途：基类指针转换为派生类指针，并检查是否真的属于那个子类，如果类型不匹配，会返回 nullptr。 比如下面的代码： Base* b = new Derived(); Derived* d = dynamic_cast\u003cDerived*\u003e(b); if (d) { // 转换成功 } 接下来我们要了解的是const_cast，它的作用是移除 const const_cast 只负责“移除 const 修饰”，如果原变量是 const → 改它 = 未定义行为（UB） 它的使用场景是，比如有些接口写死了不要 const 修饰的传参，如 void legacy_api(char* buf)，但是你外面变量拿到的恰好是 const char* s = \"hello\"，同时你还知道： legacy_api 不会修改这个字符串，它只是想读它，这时候就派上用场了。 最后要介绍的就是最危险，但是功能也最天马行空，什么都能干的 reinterpret_cast 这个可以看我们之前介绍过的 1.33 type punning ","date":"2025-08-29","objectID":"/c-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:2:36","tags":["编程"],"title":"c++学习笔记","uri":"/c-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["编程"],"content":"2. 高级特性 ","date":"2025-08-29","objectID":"/c-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:3:0","tags":["编程"],"title":"c++学习笔记","uri":"/c-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["编程"],"content":"Linux ","date":"2025-08-29","objectID":"/c-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:3:1","tags":["编程"],"title":"c++学习笔记","uri":"/c-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["编程"],"content":"概率算法 首先我们需要区分一下概率算法和确定性算法的区别：在同一个输入实例上，每次执行的结果不尽相同。 ","date":"2025-07-04","objectID":"/%E7%AE%97%E6%B3%95%E7%90%86%E8%AE%BA/:1:0","tags":["编程"],"title":"算法理论","uri":"/%E7%AE%97%E6%B3%95%E7%90%86%E8%AE%BA/"},{"categories":["编程"],"content":"数字概率算法 特点： 主要用于找到一个数字问题的近似解 $\\pi$ 值计算 ","date":"2025-07-04","objectID":"/%E7%AE%97%E6%B3%95%E7%90%86%E8%AE%BA/:1:1","tags":["编程"],"title":"算法理论","uri":"/%E7%AE%97%E6%B3%95%E7%90%86%E8%AE%BA/"},{"categories":["编程"],"content":"Sherwood算法 特点： 当某些确定算法解决一个特殊问题时的平均时间比最坏时间快得多时，我们可以使用Sherwood算法来减少，甚至是消除好的和坏的实例之间的差别。 对于一个确定性算法，它的平均时间很容易计算： T（确定性算法平均时间）= （每次执行的时间之和）/ （执行总次数） 但是会存在这样一个不好的情况：某次执行的时间远远大于平均执行时间，比如最坏情况。 设A是一个确定算法，$t_A(x)$是解某个实例x的执行时间，设$n$是一整数，$X_n$是大小为n的实例的集合。假定$X_n$中每一个实例是等可能出现的，则算法A解一个大小为$n$的实例的平均执行时间为：$\\bar{t}A(n) = \\sum{x \\in X_n} t_A(x) / |X_n|$ 这里无法消除存在一个size为n的实例，使得：$t_A(x) » \\bar{t}_A(n)$ 这时候我们就可以考虑设计一个概率算法B，对每个size为n的实例x，使得： $$ t_B(x) \\approx \\bar{t}_A(n) + s(n) $$ 这里$t_B(x)$是算法B在实例x上的期望值，s(n)是概率算法B为了取得均匀性所付出的成本。 虽然算法B的执行时间也可能偶然地在某一个实例x上$»\\bar{t}_A(n) + s(n)$，但这种偶然性行为只是由于算法所做的概率选择引起的，与实例x本身没有关系。因此，不再有最坏情况的实例，但有最坏的执行时间。 Sherwood 一般方法是： 1. 将被解的实例变换到一个随机实例。// 预处理 2. 用确定算法解此随机实例，得到一个解。 3. 将此解变换为对原实例的解。 // 后处理 ","date":"2025-07-04","objectID":"/%E7%AE%97%E6%B3%95%E7%90%86%E8%AE%BA/:1:2","tags":["编程"],"title":"算法理论","uri":"/%E7%AE%97%E6%B3%95%E7%90%86%E8%AE%BA/"},{"categories":["编程"],"content":"Las Vegas算法 特点： 可能不时地要冒着找不到解的风险，算法要么返回正确的解，要么随机决策导致一个僵局。若算法陷入僵局，则使用同一实例运行同一算法，有独立的机会求出解。成功的概率随着执行时间的增加而增加。 首先我们来看看LV算法与Sherwood算法的比较： Sherwood算法不算很优，因为它只改进确定性算法的最坏情况，所以平均执行时间与确定性算法相差无几。为了提高平均执行时间，就采用Las Vegas算法。 Sherwood算法能够计算出一个给定实例的执行时间上界，因为它总是能够正确运行，所以每次都有一定的执行时间，取最大值就是上界。Las Vegas的时间上界可能不存在，因为它可能找不到解陷入死循环。 算法的一般形式： LV(x, y, success) —— x 是输入的实例，y 是返回的参数，success是布尔值， true 表示成功，false 表示失败 $p(x)$ —— 对于实例x，算法成功的概率 $s(x)$ —— 算法成功时的期望时间 $e(x)$ —— 算法失败时的期望时间 设$t(x)$是算法找到一个正确解的期望时间，易得 $t(x)=p(x)s(x)+(1-p(x))(e(x)+t(x))$ 解得 $t(x) = s(x) + \\frac{1 - p(x)}{p(x)} e(x)$ ","date":"2025-07-04","objectID":"/%E7%AE%97%E6%B3%95%E7%90%86%E8%AE%BA/:1:3","tags":["编程"],"title":"算法理论","uri":"/%E7%AE%97%E6%B3%95%E7%90%86%E8%AE%BA/"},{"categories":["编程"],"content":"Monte Carlo算法 特点： MC算法偶然会犯错，但它无论对何实例均能以高概率找到正确解。当算法出错时，没有警告信息。 定义1：设p是一个实数，且1/2\u003cp\u003c1，若一个MC算法以不小于p的概率返回一个正确的解，则该MC算法称为p-正确，算法的优势（advantage）是 p-1/2. 定义2：若一个MC算法对同一实例决不给出两个不同的正确解，则该算法称是相容的（consistent）或一致的。 定义3：(偏真算法)为简单起见，设MC(x)是解某个判定问题，对任何x，若当MC(x)返回true时解总是正确的，仅当它返回false时才有可能产生错误的解，则称此算法为偏真的(true-biased)。 定义4：(偏$y_0$算法)更一般的情况不再限定是判定问题，一个MC是偏$y_0$的($y_0$是某个特定解)，如果存在问题实例的子集$X$使得： 若被解实例$x\\notin X$，则算法MC(x)返回的解总是正确的(无论返回$y_0$还是非$y_0$)；若$\\forall x \\in X$，正确解是$y_0$ ，但MC并非对所有这样的实例$x$都返回正确解。 $\\implies$ 若返回$y_0$，解一定正确。 设MC是一个一致的、$p$-correct和偏 $y_0$ 的蒙特卡洛算法，$x$ 是一个实例，$y$ 是MC(x)返回的解，可分为如下2种情形讨论： case1: $y=y_0$ 若$x\\notin X$，则算法MC总是返回正确解，因此 $y_0$ 确实是正确的。 若$x\\in X$，算法返回的正确解必定是 $y_0$。这两种情况均可得到结论：$y_0$ 是一个正确解。 case2: $y \\ne y_0$ 若$x\\notin X$，则 $y$ 是正确解。 若$x\\in X$，因为正确解是 $y_0$，故 $y$ 是错误解，此出错概率不超过 $1-p$。 例： 重复调用一个一致的，$p$-正确的，偏真的MC算法$k$次，可以得到一个出错概率是多少的算法？ 由单个算法出错概率为$(1-p)$得， 得出全错概率为全错：$(1-p)^k$ ","date":"2025-07-04","objectID":"/%E7%AE%97%E6%B3%95%E7%90%86%E8%AE%BA/:1:4","tags":["编程"],"title":"算法理论","uri":"/%E7%AE%97%E6%B3%95%E7%90%86%E8%AE%BA/"},{"categories":["编程"],"content":"分布式算法 分布式计算和并行计算区别： 分布式计算的任务通常是相互独立的且实时性要求不高，这样哪怕一台机器出故障，也不影响其他机器，只需要重新启动一个机器去执行； 并行计算是实时性高，且任务之间相关性强。 分布式系统的难点在于： 缺乏全局时间（无法保证所有机器的绝对时间和相对时间都确定） 缺乏全局状态信息（不存在全知全能的上帝） 缺乏统一模式 输入不同 消息顺序不同 执行速率不同 故障不同 分布式模型： 异步共享存储模型：用于紧耦合机器，通常情况下各处理机的时钟信号不是来源于同一信号源 异步msg传递模型：用于松散耦合机器及广域网 同步msg传递模型：这是一个理想的msg传递系统。该系统中，某些计时信息（如msg延迟上界)是已知的，系统的执行划分为轮执行，是异步系统的一种特例。 异步共享存储模型主要是同步计算考虑的模型，我们主要需要考虑的是异步msg传递模型，因为这是现实中最最常见的一种情况。 至于同步msg传递模型，显示中是不可能存在的，因为时钟是漂移的，没有全局时间，同步是不可能在现实中完美存在的。但是这种理想模型是有价值的，由于存在延迟上届，因此超过这个时间我们可以认为一定会接受到消息，因此我们就可以在超过这个时间再做下一件事情，也就是把系统变成按轮来同步执行了。而这个特性就会非常方便我们先在这个简单的环境条件下设计算法，然后再将其推广到实际情况中。以及这种标准的简单环境条件，方便我们去定量评价一个系统的好坏。 错误的种类： 初始死进程：指在局部算法中没有执行过一步 崩溃错误(损毁模型)：指处理机没有任何警告而在某点上停止操作 拜占庭错误：一个出错可引起任意的动作,即执行了与局部算法不一致的任意步。拜占庭错误的进程发送的消息可能包含任意内容 拜占庭错误是恶性故障，因为他会影响到系统的其他。前两种属于良性故障。 ","date":"2025-07-04","objectID":"/%E7%AE%97%E6%B3%95%E7%90%86%E8%AE%BA/:2:0","tags":["编程"],"title":"算法理论","uri":"/%E7%AE%97%E6%B3%95%E7%90%86%E8%AE%BA/"},{"categories":["编程"],"content":"消息传递系统中的基本算法 形式化模型 首先我们给出msg传递系统这样一个形式化模型定义： 我们给出 $G(V,E)$ 这样一个无向图的概念，处理机节点集合 $V= \\lbrace p_0,p_1,\\dots,p_{n-1} \\rbrace$，$\\exists p_ip_j$表示在处理机$P_i$和$p_j$之间存在一条双向信道$E_k$（这里我们统一假设信道都是双向了，下面遵循这个约定） 分布式算法是由所有处理机节点上的分布式程序统一构成的，是一个总和的概念。 由于是同步msg传递模型，所以处理机会在理论上的msg延迟上界时候后才会去取消息，因此每个处理机都需要有buf缓冲区来预存提前到的消息，因此我们在每条双向信道 $E_k$ 的处理机 $p_i$ 处都设计一个 $outbuf_i$ 和 $inbuf_i$，分别用来缓存接受到的消息和发送的消息。 因此对于每个处理机 $p_i$ 来说，都会有两个msg集合，$outbuf_i$[] 和 $inbuf_i$[] $outbuf_i[l]$： $p_i$ 经第$l$条关联的信道发送给邻居，但尚未传到邻居的msg。 $inbuf_i[l]$： 在 $p_i$ 的第$l$条关联的信道上已传递到 $p_i$，但尚未经过 $p_i$ 内部计算步骤处理的msg。 我们假设有一个上帝，在第0秒给 $outbuf_i$[] 和 $inbuf_i$[] 照了个相，内容就是两个msg集合里的内容，我们记为状态 $q_{i0}$,同理，第1秒状态为 $q_{i1}$，第j秒状态就为 $q_{ij}$,这一连串的状态所构成的状态集我们就叫做 $Q_i$，因此每个处理器 $p_i$ 可以模型化为一个具有状态集 $Q_i$ 的状态机。 进一步，在第0秒时，状态机 $q_i$ 的状态为 $q_{i0}$, 状态机 $q_j$ 的状态为 $q_{j0}$,这时候我们已经不满足于只对单个状态机进行照相了，我们在第 $t$ 秒时，对所有状态机的状态 $q_{0t}，q_{1t},\\dots,q_{it}$,统一照了张相，我们把它叫做配置。 初始配置就是所有初始状态组成的配置。 而状态的变化我们就可以叫做状态转移，我们将其抽象为一个转移系统，下面我们介绍这个转移系统的形式化定义：状态按离散步骤（事件/转移）变化的系统。 定义1. 转移系统是一个三元组 $S=\\lbrace C,\\to,I \\rbrace$ 其中$C$是配置集（所有配置的集合），$I$是初始配置的一个子集（表示转移系统的开始位置，如果不是子集就不合法了），$\\to$是$C$上的一个二元转移关系，$\\gamma \\to \\delta$ 代表从配置 $\\gamma$ 转移到配置 $\\delta$。 定义2. 我们记转移系统 $S$ 的一次执行的最大序列 $E=(r_0,r_1,\\dots)$,其中 $r_0 \\in I$ 且对 $\\forall i \\ge 0$,都有 $r_i \\to r_{i+1}$。我们定义终止配置 $\\gamma$ 为不存在 $\\delta$，使得 $\\gamma \\to \\delta$。那么对于序列 $E$,如果他是无限的，或者以终止配置 $\\gamma$ 结束的，我们就称这样的序列为最大的。 这里的 $r_0 \\in I$ 很好理解，因为都是从初始配置开始出发的。 定义3. 如果存在序列 $\\gamma \\to \\gamma _1 \\to \\gamma _2 \\dots \\to \\gamma _k = \\delta$，那么我们称 $\\delta$ 是由 $\\gamma$ 可达的。 如果$\\delta$ 是由初始配置可达的，则称 $\\delta$ 是可达的。 系统里所发生的事情均被模型化为事件，对于msg传递系统，有两种： comp(i)——————计算事件，代表处理器 $p_i$ 的一个计算步骤。其中，$p_i$ 的转换函数被用于当前可访问状态 del(i,j,m)—————传递事件，表示msg $m$ 从 $p_i$ 传送到 $p_j$ 系统在时间上的行为被模型化为一个执行。它是一个由配置和事件交错的序列。该序列须满足各种条件，主要分为两类： safety条件（安全性）：表示某个性质在每次执行中每个可到达的配置里都必须成立 liveness条件(活跃性)：表示某个性质在每次执行中的某些可达配置里必须成立。 对特定系统，满足所有要求的安全性条件的序列称为一个执行；若一个执行也满足所有要求的活跃性条件，则成为容许执行（合法的执行）。 下面我们介绍三个衡量模型性能的方式： Msg复杂度：算法在所有容许的执行上发送msg总数的最大值(同步和异步系统) 时间复杂度： 同步系统：最大轮数，即算法的任何容许执行直到终止的最大轮数。 异步系统：假设：1.节点计算任意有限数目事件的时间为0；2.一条消息发送和接收之间的时间至多为1个时间单位。在这两条假设的前提之下，时间复杂度就是所有计时容许执行中直到终止的最大时间。（也就是说有限计算不花时间，然后如果接受和发送时间太长，我们就不让他参与这次执行中） 消息复杂度：消息总数/消息中总的位数长度。请注意和Msg复杂度的不同。 生成树上的广播和敛播 在一个分布式系统中，广播和敛播是最重要的两个算法，因为msg的传递都需要靠这两个算法。 广播（Broadcast）：在分布式系统中，一个节点向所有其他节点发送同一条消息的过程。目标是让系统中所有节点（或指定组）接收消息 敛播（Gather，也称为收集、汇聚）：与广播相反，是所有节点向一个中心节点（或根）发送消息的过程，最终中心节点收集所有节点的信息。比如，子节点向根汇报状态，根汇总数据。 由于广播的特性，如果是普通图的结构，就会发生广播风暴问题，以及广播/敛播在树结构下才能达到消息复杂度最优，因此我们需要将分布式系统设计成**最小生成树(MST)**的结构。 广播算法： 根节点发送Msg给孩子。收到Msg的节点转发Msg给孩子。 Msg复杂度：$O(n-1)$，因为生成树每条边有一个Msg 时间复杂度：$O(D)$，$D$为生成树直径 敛播算法： 汇集是从所有节点收集信息至根 Msg复杂度：$O(n-1)$，因为生成树每条边有一个Msg 时间复杂度：$O(D)$，$D$为生成树直径 构造生成树 上节讨论的广播和敛播都是建立在已知生成树的拓扑结构，因此我们还需要思考如何来构造生成树 指定根构造生成树 flooding（洪泛）算法 算法思想：设 $p_r$ 是特殊处理器。从 $p_r$ 开始，发送M到其所有邻居。当处理器 $p_i$ 第$1$次收到消息M（不妨设此msg来自于邻居$p_j$）时，$p_i$ 发送M到除 $p_j$ 外的所有邻居。 Msg复杂度：$O(2m-(n-1))$,$m$是信道总数。我们考虑一些延迟误差，比如有3个处理器 $p_0、p_1、p_2$,$p_0$分别向$p_1$和$p_2$转发ms,然后$p_1$和$p_2$同时收到ms，那么此时$p_1$和$p_2$又会同时相互转发，所以一条信道 $E_k$ 就可能有两条ms，但是注意对于每个$p_i$，它是肯定不会对它收到的第1条M来自的邻居$p_j$发送M,因此需要减掉 $n-1$。 时间复杂度：$O(D)$，$D$为生成树直径。 我们可以通过改造flooding算法来设计一种构造生成树的算法： 算法思想： 首先，$p_r$发送M给所有邻居，$p_r$为根 当$p_i$从某邻居$p_j$收到的M是第1个来自邻居的msg时，$p_j$是$p_i$的双亲；若$p_i$首次收到的M同时来自多个邻居，则用一个comp事件处理自上一comp事件以来的所有已收到的msgs，故此时，$p_i$可在这些邻居中任选一个邻居$p_j$做双亲。 双亲一旦选定就绝不更改。当$p_i$确定双亲是$p_j$时，发送给$p_j$，并向此后收到发来M的处理器发送msg。 $p_i$向那些尚未发M给$p_i$(或已发M但尚未到达$p_i$)的邻居转发M之后，等待这些邻居发回响应msg：或。那些回应的邻居是$p_i$的孩子。 当$p_i$发出M的所有接收者均已回应（或)，则$p_i$终止。将parent和children边保留即为生成树。 Msg复杂度：由于算法只是在flooding算法上增加了回应（或)，因此也就是2倍关系，所以也是$O(m)$ 时间复杂度：$O(D)$，$D$为生成树直径。 上述讨论的算法在同步模型下，也可以工作，同时所构造的生成树一定是一棵BFS树 但是在异步模型下，构造的树就不一定是一棵BFS树了 那么自然而然我们会好奇：如何构造DFS生成树呢？ 算法思想： * Msg复杂度：$O(m)$ 时间复杂度：$O(m)$ 不指定根时构造生成树 已知条件：个具有m条边和n个节点的网络，自发启动的节点共有p个，其中ID 值最大者的启动时间为t Msg 复杂度：$O(pn^2)$。最坏情况下，每个处理器均试图以自己为根构造一棵DFS树。 因此，Alg2.4 的msg复杂性至多是Alg2.3的n倍：O(m*n) 时间复杂度： 时间复杂度：$O(t+m)$ ","date":"2025-07-04","objectID":"/%E7%AE%97%E6%B3%95%E7%90%86%E8%AE%BA/:2:1","tags":["编程"],"title":"算法理论","uri":"/%E7%AE%97%E6%B3%95%E7%90%86%E8%AE%BA/"},{"categories":["编程"],"content":"环上选举算法 Leader选举问题 异步环：下界$O(nlgn)$ 同步环：上界$O(n)$和下界$O(nlgn)$ 非均匀： Msg 复杂度：$n·(i+1)$，i为最终Leader的id 时间复杂度：$n·(i+1) $ 均匀： Msg 复杂度：$O(4n)$， 时间复杂度：$O(n· 2^i)$ i为最终Leader的id ","date":"2025-07-04","objectID":"/%E7%AE%97%E6%B3%95%E7%90%86%E8%AE%BA/:2:2","tags":["编程"],"title":"算法理论","uri":"/%E7%AE%97%E6%B3%95%E7%90%86%E8%AE%BA/"},{"categories":["编程"],"content":"近似算法 对于一些NP hard问题，我们只能使用$2^n$数量级的时间来求取最优解，但是近似算法给了我们一条新的思路，我们可以牺牲结果的部分准确性，比如只用$n^k$次方的时间，来求得问题的次优解。这个对于很多情况来说都是非常重要的。 以及对于次优解和最优解之间的误差，我们该如何去控制，如果我们能有效控制误差，那么对于很多优化问题都非常有效。 由于课程安排，近似算法这学期并没有讲，因此只做简单了解。 ","date":"2025-07-04","objectID":"/%E7%AE%97%E6%B3%95%E7%90%86%E8%AE%BA/:3:0","tags":["编程"],"title":"算法理论","uri":"/%E7%AE%97%E6%B3%95%E7%90%86%E8%AE%BA/"},{"categories":["数学"],"content":"同余 首先我们给出两个数同余的定义： $$ a \\equiv b \\pmod{p} \\iff a - b = pk $$ 对某两个整数 $a,b$,若它们除以**正整数** $p$ 所得的余数相等,则称 $a,b$ 对模 $p$ 同余，一般记作： $a \\equiv b \\pmod{p}$ 下面我们思考一个问题： Q. 请问 $2362837 \\times 1419853$ 的个位数字应该是多少？ 显然，大部分人本能想法就是，根据人类的乘法规则，列出两个数字列项相乘，那么最后结果的个位数只会由这两个乘数的个位数的乘积决定，比如这道题明显就是 $(7\\times 3) \\mod 10=1$。 仔细品味这个例子，其实蕴含着一个深刻的道理： $$ x \\equiv r \\pmod{10},\\ y \\equiv s \\pmod{10} \\\\ \\implies xy \\equiv rs \\pmod{10} $$ 证明其实也很简单： $$ \\begin{align*} x \u0026= 10x' + r,\\ y = 10y' + s \\\\ xy \u0026= (10x' + r)(10y' + s) \\\\ \u0026= 10^2 x'y' + 10x's + 10y'r + rs \\end{align*} $$ 当然了，这里的$10$也没有特殊性，我们可以推广到任意的 $p$ ： $$ \\begin{align*} x \u0026\\equiv r \\pmod{p},\\ y \\equiv s \\pmod{p} \\\\ \u0026\\implies xy \\equiv rs \\pmod{p} \\\\ \\\\ x \u0026= px' + r,\\ y = py' + s \\\\ xy \u0026= (px' + r)(py' + s) \\\\ \u0026= p^2 x'y' + px's + py'r + rs \\end{align*} $$ 除了乘法，加法其实也是类似的，最后的结论我们可以写为： $$ x \\equiv r \\pmod{p},\\ y \\equiv s \\pmod{p} \\\\ \\implies xy \\equiv rs \\pmod{p} \\quad \\quad \\quad \\quad \\implies x+y \\equiv r+s \\pmod{p} $$ $$ x = px' + r,\\ y = py' + s \\\\ \\begin{alignat*}{2} xy \u0026= (px' + r)(py' + s) \u0026 x + y \u0026= (px' + r) + (py' + s) \\\\ \u0026= p^2 x'y' + px's + py'r + rs \u0026 \u0026= px' + py' + r + s \\end{alignat*} $$ 所以同余有一个很好的性质： 如果你关心的不是一个数字绝对的大小，而只关心他除以$p$的余数，那么任何时候，你都可以放心地扔掉这个具体的数字，而只保留它的余数进行运算就够了。 ","date":"2025-07-01","objectID":"/%E6%95%B0%E8%AE%BA/:1:0","tags":["数学"],"title":"数论","uri":"/%E6%95%B0%E8%AE%BA/"},{"categories":["数学"],"content":"费马小定理 首先我们来看一个非常有意思的现象，假设我们有一个圆，上面有11个点，然后你可以从任何一个位置出发,且第一次出发后到达的点不能是原来的位置，每次移动相同的距离$a$，那么你会惊奇的发现，你会完美无瑕的走过每一个顶点之后，再回到原来的位置，期间不会走过重复的位置。 你肯定会好奇这到底是为什么呢？以及这个11是随便取的数吗？ 答案当然不是的。这里的11是一个质数。 我们不妨先思考下面这个问题： Q. 对于一个质数$p$来说，我们假设$a$不是$p$的倍数，也就是$a \\ne p k_0$。 那么对于 $a、2a、3a、\\dots、(p-2)a、(p-1)a$，是否存在两个数，这两个数对模 $p$ 同余吗？ 答案显然是不存在。 我们需要证明的是 $xa \\equiv ya \\pmod{p}$,其中 $1\\le y \u003c x \\le p-1$,也即证明 $(x-y)a=pk$,又由乘法分配律可知，左边式子中的 $x-y$ 和 $a$ 需要找到至少一个数，有因数 $p$,但是显然由定义 $a$ 不是，而 $x-y\u003cp$，显然也做不到，因此永远无法找到这样的两个数。 于是上面这个很有意思的现象似乎就可以解释了。 这里圆上点的数量其实就是 $p$,每次我们出发移动的距离其实就是 $a$，比如我们从 $0$ 出发，第一次走到 $a$,第二次走到 $2a$,其实就是我们上面讨论的 $a、2a、3a、\\dots、(p-2)a、(p-1)a$ 这些数，而这些数对 $p$ 取余的结果就是他们每次到达的位置，确实不存在一样的，这就是上面神奇现象的数学原理。 解释完上面这个有意思的现象，我们再继续在刚刚的例子中挖掘一些有意思的东西，比如说： Q. 你知道 $a、2a、3a、\\dots、(p-2)a、(p-1)a$ 除以 $p$ 的余数的集合里有哪些数吗？ 显然正好是 $1、2、3、\\dots、 p-1$。这些数也恰好和 $a、2a、3a、\\dots、(p-2)a、(p-1)a$ 中的某个数同余，因此由上面的乘法性质可得： $$ \\begin{align*} \u0026a^{p-1}(p-1)! \\equiv (p-1)! \\pmod {p} \\\\ \u0026\\implies (a^{p-1}-1)(p-1)!=pk \\end{align*} $$ 又由乘法分配律可知，左边式子中的 $a^{p-1}-1$ 和 $(p-1)!$ 需要找到至少一个数，有因子 $p$,但是显然 $(p-1)!$ 不存在因子 $p$，因此只能是 $a^{p-1}-1=pk'$，也即： $$ a^{p-1} \\equiv 1 \\pmod{p} \\quad\\quad(a \\ne pk_0) $$ 至此你便自己探索出了鼎鼎大名的费马小定理(^_^) Good Boy! ","date":"2025-07-01","objectID":"/%E6%95%B0%E8%AE%BA/:2:0","tags":["数学"],"title":"数论","uri":"/%E6%95%B0%E8%AE%BA/"},{"categories":["养生"],"content":"晴天需要保证每天至少10min光照，调节褪黑素分泌。 BMI需要小于22 ","date":"2025-06-28","objectID":"/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%BB%B6%E5%AF%BF%E6%8C%87%E5%8D%97/:0:0","tags":["有趣","养生"],"title":"程序员延寿指南","uri":"/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%BB%B6%E5%AF%BF%E6%8C%87%E5%8D%97/"},{"categories":["养生"],"content":"1.术语 ACM: All-Cause Mortality / 全因死亡率 ","date":"2025-06-28","objectID":"/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%BB%B6%E5%AF%BF%E6%8C%87%E5%8D%97/:1:0","tags":["有趣","养生"],"title":"程序员延寿指南","uri":"/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%BB%B6%E5%AF%BF%E6%8C%87%E5%8D%97/"},{"categories":["养生"],"content":"2.目标 稳健的活得更久 ","date":"2025-06-28","objectID":"/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%BB%B6%E5%AF%BF%E6%8C%87%E5%8D%97/:2:0","tags":["有趣","养生"],"title":"程序员延寿指南","uri":"/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%BB%B6%E5%AF%BF%E6%8C%87%E5%8D%97/"},{"categories":["养生"],"content":"3.分析 主要参考：对ACM的学术文献相对较多，可以作为主要参考 增加寿命与ACM关系非线性：显然增加寿命与ACM关系是非线性函数，这里假设 ΔLifeSpan=(1/(1+ΔACM)-1)*10（ΔACM为ACM变化值；公式欢迎优化） 变量无法简单叠加：显然各个变量之间并不符合独立同分布假设，变量之间的实际影响也并不明确 存在矛盾观点：所有的证据都有文献/研究对应，但注意到：有些文献之间有显著矛盾的观点（如对于碳水摄入比例的矛盾）；有些文献存在较大争议（如认为22点前睡觉会提升43%全因死亡率） 研究仅表达相关：所有文献表明的更多是相关而非因果，在阅读时要考虑文献是否充分证明了因果 —— 如某文献表明了日均\u003e=7000步的人有显著低的全因死亡率。但步数少的人可能包含更多长期病患，如果没有合理的排除这块数据，那此文献调查失真 ","date":"2025-06-28","objectID":"/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%BB%B6%E5%AF%BF%E6%8C%87%E5%8D%97/:3:0","tags":["有趣","养生"],"title":"程序员延寿指南","uri":"/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%BB%B6%E5%AF%BF%E6%8C%87%E5%8D%97/"},{"categories":["养生"],"content":"4.理论 输入 固体：吃白肉（-11%～-3% ACM）、蔬果为主（-26%～-17% ACM），多吃辣（-23% ACM），多吃坚果（-27%～-4% ACM），中量碳水、多吃植物蛋白（-10% ACM），少吃超加工食物（-62%～-18%） 液体：喝咖啡（-22%～-12% ACM），喝牛奶（-17%～-10% ACM），喝茶（-15%～-8% ACM），少喝或不喝甜味饮料（否则每天一杯+7% ACM，+多巴胺），戒酒（否则+～50% ACM，无上限） 气体：不吸烟（否则+～50% ACM，-12～-11年寿命） 光照：晒太阳（-～40% ACM） 药物：二甲双胍（糖尿病人相比正常人可以+3年）、复合维生素（-8%癌症风险）、亚精胺（-60%～-30% ACM）、葡萄糖胺（-39% ACM） 输出 运动：每周3次45分钟挥拍运动（-47% ACM） 日常：刷牙（-25% ACM） 睡眠：每天睡7小时全因死亡率最低；且22-24点间最好，早睡+43% ACM，晚睡+15% ACM（存在争议） 上下文 体重：减肥（-54% ACM） ","date":"2025-06-28","objectID":"/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%BB%B6%E5%AF%BF%E6%8C%87%E5%8D%97/:4:0","tags":["有趣","养生"],"title":"程序员延寿指南","uri":"/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%BB%B6%E5%AF%BF%E6%8C%87%E5%8D%97/"},{"categories":["养生"],"content":"5.实战 ","date":"2025-06-28","objectID":"/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%BB%B6%E5%AF%BF%E6%8C%87%E5%8D%97/:5:0","tags":["有趣","养生"],"title":"程序员延寿指南","uri":"/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%BB%B6%E5%AF%BF%E6%8C%87%E5%8D%97/"},{"categories":["养生"],"content":"减肥： 对体重减轻的死亡率风险评估发现，体重从肥胖减轻到超重的成年人与稳定肥胖人群相比，全因死亡率降低了54％（危险比为0.46），然而从成年初期的超 重减轻到中年以前的正常体重的人群的死亡率风险并未降低（风险比为1.12）。 BMI建议： 18.5～24 （梨型身材 22～24，苹果型身材20～22） 杜绝腹部脂肪 ","date":"2025-06-28","objectID":"/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%BB%B6%E5%AF%BF%E6%8C%87%E5%8D%97/:5:1","tags":["有趣","养生"],"title":"程序员延寿指南","uri":"/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%BB%B6%E5%AF%BF%E6%8C%87%E5%8D%97/"},{"categories":["养生"],"content":"运动： 每周 $\\ge150$ min中等强度有氧运动（心率130～150次/min） ","date":"2025-06-28","objectID":"/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%BB%B6%E5%AF%BF%E6%8C%87%E5%8D%97/:5:2","tags":["有趣","养生"],"title":"程序员延寿指南","uri":"/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%BB%B6%E5%AF%BF%E6%8C%87%E5%8D%97/"},{"categories":["养生"],"content":"走路 分析结果表明，每日步数每增加 2000 步，过早死亡的风险就会随之降低 8%～11%，直到每天走 10000 步时达到基本饱和。 ","date":"2025-06-28","objectID":"/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%BB%B6%E5%AF%BF%E6%8C%87%E5%8D%97/:5:3","tags":["有趣","养生"],"title":"程序员延寿指南","uri":"/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%BB%B6%E5%AF%BF%E6%8C%87%E5%8D%97/"},{"categories":["养生"],"content":"晒太阳 上午6:00到10:00之间，下午14:00-18:00之间，UVA的量比UVB要多。 当你的影子是你身高的2倍，甚至更多的时候，紫外线指数最安全，可以不需要任何防护，好好晒一晒。 当你的影子处于身高和身高的2倍之间长度时，安全晒太阳的时长可以控制在20分钟左右。 ","date":"2025-06-28","objectID":"/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%BB%B6%E5%AF%BF%E6%8C%87%E5%8D%97/:5:4","tags":["有趣","养生"],"title":"程序员延寿指南","uri":"/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%BB%B6%E5%AF%BF%E6%8C%87%E5%8D%97/"},{"categories":["养生"],"content":"刷牙 经常不刷牙的人：癌症、慢性阻塞性肺病及肝硬化风险分别增加了9%、12%和25%，过早死亡风险增加25%。 ","date":"2025-06-28","objectID":"/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%BB%B6%E5%AF%BF%E6%8C%87%E5%8D%97/:5:5","tags":["有趣","养生"],"title":"程序员延寿指南","uri":"/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%BB%B6%E5%AF%BF%E6%8C%87%E5%8D%97/"},{"categories":["养生"],"content":"睡眠 在男性中，最佳睡眠实际为7小时，睡眠持续时间≥10小时与全因死亡风险增加34%相关； 且22-24点间最好，早睡+43% ACM，晚睡+15% ACM（存在争议） ","date":"2025-06-28","objectID":"/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%BB%B6%E5%AF%BF%E6%8C%87%E5%8D%97/:5:6","tags":["有趣","养生"],"title":"程序员延寿指南","uri":"/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%BB%B6%E5%AF%BF%E6%8C%87%E5%8D%97/"},{"categories":["编程"],"content":" 由于一直想创建一个属于自己的博客，但是一直没有找到合适的平台，所以最近开始尝试利用 Hugo 和 Github Pages 创建一个静态博客。Hugo 可以很大程度上解决我的一个个人需求：我不希望直接将我的.md文件上传到 Github 上，这样别人就会直接拿到我的笔记和代码，而我希望的是别人只能看到我写的博客。 期间也踩坑了很多次，看了非常多的经验帖，最后花费了两天时间终于大功告成！ 看到这么好看的主页，一切都是值得的(^_^)。 ","date":"2025-06-25","objectID":"/%E5%88%A9%E7%94%A8-hugo-%E5%92%8C-github-pages-%E5%88%9B%E5%BB%BA%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E5%B9%B6%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2/:0:0","tags":["编程"],"title":"利用 Hugo 和 Github Pages 创建静态博客并实现自动部署","uri":"/%E5%88%A9%E7%94%A8-hugo-%E5%92%8C-github-pages-%E5%88%9B%E5%BB%BA%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E5%B9%B6%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2/"},{"categories":["编程"],"content":"1. 环境准备 1.1 下载Go Hugo 是用 go 写的，所以速度很快，因此在下载Hugo 之前还得本地配置 go 环境 1.2 下载Hugo 官官网址：Hugo官网 ","date":"2025-06-25","objectID":"/%E5%88%A9%E7%94%A8-hugo-%E5%92%8C-github-pages-%E5%88%9B%E5%BB%BA%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E5%B9%B6%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2/:0:1","tags":["编程"],"title":"利用 Hugo 和 Github Pages 创建静态博客并实现自动部署","uri":"/%E5%88%A9%E7%94%A8-hugo-%E5%92%8C-github-pages-%E5%88%9B%E5%BB%BA%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E5%B9%B6%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2/"},{"categories":["编程"],"content":"2. 创建博客 2.1 初始化博客 通过hugo new site Blog命令初始化一个 Blog/目录，里面会自动生成一些框架代码 └─Blog ├─archetypes ├─assets ├─content ├─data ├─i18n ├─layouts ├─static └─themes 2.2 下载主题 打开 hugo theme 的网站，选择合适的主题，以LoveIt 举例。 Hugo Themes: https://themes.gohugo.io LoveIt 主题的仓库是: https://github.com/dillonzq/LoveIt. 你可以下载主题的 发布版本 .zip 文件 并且解压放到 themes 目录. 另外, 也可以直接把这个主题克隆到 themes 目录: git clone https://github.com/dillonzq/LoveIt.git themes/LoveIt 或者, 初始化你的项目目录为 git 仓库, 并且把主题仓库作为你的网站目录的子模块: git init git submodule add https://github.com/dillonzq/LoveIt.git themes/LoveIt 主题的兼容性 LoveIt 分支或版本 支持的 Hugo 版本 master(不稳定) ≥ 0.128.0 0.3.X(推荐) 0.128.0 - 0.145.0 0.2.X(过时) 0.68.0 - 0.127.0 ","date":"2025-06-25","objectID":"/%E5%88%A9%E7%94%A8-hugo-%E5%92%8C-github-pages-%E5%88%9B%E5%BB%BA%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E5%B9%B6%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2/:0:2","tags":["编程"],"title":"利用 Hugo 和 Github Pages 创建静态博客并实现自动部署","uri":"/%E5%88%A9%E7%94%A8-hugo-%E5%92%8C-github-pages-%E5%88%9B%E5%BB%BA%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E5%B9%B6%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2/"},{"categories":["编程"],"content":"3. 配置 这里是关键步骤，虽然有点不求甚解，但是真的能够省很多功夫，问题就是后期修改需要经常去翻LoveIt的官方文档。 3.1 文件替换 将myblog/themes/LoveIt/exampleSite路径下的所有文件直接复制到myblog/下覆盖掉。 其中： assets存放全局资源 content存放md文件，即你的文章 static存放静态资源 config.toml为博客配置文件 注：这里我踩坑了非常多的时间，标签和分类功能一直显示找不到这个pages，其实最后发现就是content/目录下不是只有posts/就够了，还需要有about/，categories/,tags/文件夹，才能让标签、分类功能生效，这里最好的方法其实就是把myblog/themes/LoveIt/exampleSite/content里面的所有内容都复制到myblog/content/里 完成上面这步应该就能实现跟LoveIt官网一模一样的效果了。 使用hugo serve命令启动网站来看看效果吧。 3.2 参数修改 下面就是把config.toml配置文件里面的一些参数改成自己想要的了 自己看着改就行 ","date":"2025-06-25","objectID":"/%E5%88%A9%E7%94%A8-hugo-%E5%92%8C-github-pages-%E5%88%9B%E5%BB%BA%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E5%B9%B6%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2/:0:3","tags":["编程"],"title":"利用 Hugo 和 Github Pages 创建静态博客并实现自动部署","uri":"/%E5%88%A9%E7%94%A8-hugo-%E5%92%8C-github-pages-%E5%88%9B%E5%BB%BA%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E5%B9%B6%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2/"},{"categories":["编程"],"content":"4. 部署到 Github 4.1 手动部署 在 Hugo 网站文件夹的根目录（\\Blog）下执行 hugo 命令构建 Hugo 会将构建的网站内容默认保存至网站根目录下的 public/ 文件夹下 你只需要每次将 public/ 文件夹里的内容推送到 Github 仓库即可部署成功 4.2 使用Github Actions自动发布网站 手动部署策略每次都得自己生成静态网站然后推送到仓库，有点太麻烦了。 相较于手动发布网站，用Github Actions自动发布网站达成的效果是，每次需更新网站时，只需将Blog文件夹上传到hugo-blog仓库中，之后Github自动就会更新\u003cusername\u003e.github.io仓库中的内容，无需手动将public文件夹上传到\u003cusername\u003e.github.io仓库中。 这里的 hugo-blog 仓库可以配置成 private，因为你的 .md 文件都在这里 4.2.1 创建access tokens 打开Github网页，点击右上角个人头像，进入Settings界面，点击设置列表中的Developer settings 点击Personal access tokens下的Tokens(classic)，然后点击Generate new token下的Generate new token(classic) image-20250626001837636 生成access token时，勾选workflow，同时把 Expiration 的时间设置为永不过期 image-20250626002003275 最后点击页面下方的Generate token按钮即可。生成完成后如下图，将生成的access token复制下来，以后这个aceess token将不可见。 4.2.2 创建Actions Secret 进入到上面提到的hugo-blog仓库，依次点击Settings、Secrets and Variables、Actions、New repository secret 如下图，输入Name和Secret，Name可自定义，这里取名为HUGO_TOKEN，Secret即为上面生成的access token。 最后点击Add secret完成。 4.2.3 创建Github Action 在.github/workflows文件夹下创建一个yaml文件，比如.github/workflows/hugo_deploy.yaml，文件的内容如下： name: GitHub Pages on: push: branches: - master pull_request: jobs: deploy: # 这里指定ubuntu为指定版本, 比如 ubuntu-22.04 runs-on: ubuntu-22.04 concurrency: group: ${{ github.workflow }}-${{ github.ref }} steps: - uses: actions/checkout@v4 with: submodules: true fetch-depth: 0 - name: Setup Hugo uses: peaceiris/actions-hugo@v3 with: # 运行hugo version可以查看本地hugo版本 # 这里使用最新版本的hugo, 也可写具体的版本号, 与本地hugo版本保持一致, 比如 0.138.0 hugo-version: 0.145.0 # 查看hugo version的结果，如果本地是extended版本，就设置成true，反之设置成false extended: false - name: Build run: cd Blog \u0026\u0026 hugo -D # 命令可以修改，比如草稿文章也想发表可改成hugo -D - name: Deploy uses: peaceiris/actions-gh-pages@v3 if: github.ref == 'refs/heads/master' with: # HUGO_TOKEN就是上面Actions Secret取的名字，要与自己取的名字保持一致 personal_token: ${{ secrets.HUGO_TOKEN }} # \u003cusername\u003e替换成自己的用户名 external_repository: ThisingL/thisingl.github.io # 现在默认分支都用main，比如用的是master分支，则改为master publish_branch: master publish_dir: ./Blog/public # 可选配置, 每次博客更新后, 本仓库会自动往\u003cusername\u003e.github.io仓库提交一次更新后的网站内容 # 添加该项配置后, \u003cusername\u003e.github.io仓库的提交信息就会使用本仓库的提交信息 commit_message: ${{ github.event.head_commit.message }} # cname: https://huxinme.top # 填写自己的自定义域名, 如果没有自定义域名, 删除该项配置 4.2.4 发布网站 public和resources文件夹都是Hugo生成静态网站时创建的，因此在.gitignore文件中可以添加以下内容 .hugo_build.lock /public/* /resources/ # hugo生成的文件，也可忽略 最后，将Blog文件夹提交到hugo-blog仓库中即可。 提交到Github上后，稍等一会儿，打开\u003cusername\u003e.github.io就可以看到更新后的网站了。 ","date":"2025-06-25","objectID":"/%E5%88%A9%E7%94%A8-hugo-%E5%92%8C-github-pages-%E5%88%9B%E5%BB%BA%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E5%B9%B6%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2/:0:4","tags":["编程"],"title":"利用 Hugo 和 Github Pages 创建静态博客并实现自动部署","uri":"/%E5%88%A9%E7%94%A8-hugo-%E5%92%8C-github-pages-%E5%88%9B%E5%BB%BA%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E5%B9%B6%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2/"},{"categories":["编程"],"content":"5. 日常使用流程 使用命令hugo new posts/新笔记/新笔记.md, 在 content\\posts\\目录下新建文件夹 新笔记，文件夹下新建 新笔记.md文件，文件图片放在 新笔记\\images\\ 文件夹下，这样在typora中设置图片位置为 ./images即可。这里还需要创建一个新笔记posts/新笔记/新笔记.md，由于 Hugo 在渲染 Markdown 文档时会根据 _/*/\u003e\u003e 之类的语法生成 HTML 文档, 并且有些转义字符形式的文本内容 (如 \\(/\\)/\\[/\\]/\\\\) 会自动进行转义处理, 因此需要对这些地方进行额外的转义字符表达来实现自动渲染。所以一个好的解决方法是：多行公式前使用\u003cdiv\u003e标签，但是这个就会带来一个新问题：Typora中不好看公式了。因此就可以每次在posts/新笔记/新笔记.md中进行笔记书写，然后使用我下面提供的shell脚本来将新笔记.md复制到posts/新笔记/index.md中将行间公式前统一加上 \u003cdiv\u003e标签。 这里我写了一个单行shell脚本,可以一件把将新笔记.md生成符合hugo要求的index.md,直接复制到bash里运行就可以了 find . -maxdepth 1 -name \"*.md\" ! -name \"index.md\" -print \u003e tmp_list \u0026\u0026 \\ file_count=$(wc -l \u003c tmp_list) \u0026\u0026 \\ if [ \"$file_count\" -eq 0 ]; then echo \"错误：未找到任何非index.md的.md文件\" \u0026\u0026 rm tmp_list; \\ elif [ \"$file_count\" -gt 1 ]; then echo \"错误：找到多个非index.md的.md文件：\" \u0026\u0026 cat tmp_list \u0026\u0026 rm tmp_list; \\ else target_file=$(head -n1 tmp_list) \u0026\u0026 echo \"正在处理文件: $target_file\" \u0026\u0026 \\ awk 'BEGIN {in_math=0} {line=$0; output=\"\"; while(match(line, /\\$\\$/)) {pre=substr(line,1,RSTART-1); rest=substr(line,RSTART); if(in_math==0) {output=output pre \"\u003cdiv\u003e$$\"; in_math=1} else {output=output pre \"$$\"; in_math=0} line=substr(rest,3)} output=output line; print output}' \"$target_file\" \u003e index.md \u0026\u0026 \\ echo \"已将处理后的内容写入 index.md\" \u0026\u0026 rm tmp_list; fi 将更新 git push 到hugo-blog仓库中，网站便更新完毕。 注：这里还有一个坑，参考了Hugo 博客插入图片的方法 | Cassius’s Blog 由于 Hugo 生成的是静态博客，因此插入图片是一件相对比较麻烦的事情。当然，一个简单的方法就是采用图床，不过大部分图床都需要收费，免费的也不能保证稳定性，而我们的博客所用的图片数量也并不算多，所以我们可以采取随 markdown 源文件一起存储的方法。 Hugo 普遍的新建博文的方式是 hugo new posts/new-post.md，这样我们可以将图片都存放在 Blog/static/ 目录下，这样经过编译之后图片会存放到网站的根目录。不过如果这样，那么在编写博客的时候编辑器就没办法显示图片，只能凭感觉了。而放到其他目录时，编译后的网站又不能识别。 一个较为优雅的方式就是 hugo new posts/new-post/index.md 将新的博文创建成一个文件夹，将 markdown 源文件命名为 index.md，再在文件夹内创建 pics 文件夹，将图片放入该文件夹，在编写博文插入图片时使用相对路径，即 pics/1.png，这样在编辑器中就可以看到图片了。 而当网站编译完成之后，文件夹的格式就会如下所示 first-post pics 1.png index.html index.html 文件与 pics 文件夹同级，网站同样也可以识别 html 文件中的图片路径。 这里一定要命名为index.md，不可以命名为 新笔记.md，不然你会发现编译后网站图片位置就不再同级网站文件夹下了，上面操作也就会失效(这里花了我起码2小时来发现这个bug所在) ","date":"2025-06-25","objectID":"/%E5%88%A9%E7%94%A8-hugo-%E5%92%8C-github-pages-%E5%88%9B%E5%BB%BA%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E5%B9%B6%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2/:0:5","tags":["编程"],"title":"利用 Hugo 和 Github Pages 创建静态博客并实现自动部署","uri":"/%E5%88%A9%E7%94%A8-hugo-%E5%92%8C-github-pages-%E5%88%9B%E5%BB%BA%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E5%B9%B6%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2/"},{"categories":["数学"],"content":"MAB/多臂老虎机模型（Multi-armed Bandit） 数学家将做我们生活中面临的选择困境抽象为了一个数学模型：MAB/多臂老虎机模型（Multi-armed Bandit） 假如你进入了一个赌场，面前有一台有 $K$ 根拉杆的老虎机，拉动每一根拉杆都对应一个关于奖励的概率分布。我们在各根拉杆的奖励概率分布未知的情况下，操作 $T$ 次拉杆，目标是获得尽可能高的累计奖励。由于奖励的概率分布是未知的，因此我们需要在“探索”和“利用”中进行权衡 探索：尝试其他拉杆，由大数定理可得频率会稳定于概率，所以可以更新其他拉杆的期望奖励估计。可能会牺牲短期收益，但长期可能发现更高奖励的拉杆。 利用：贪心的选择当前期望奖励估计最大的拉杆来最大化短期收益。 多臂老虎机问题可以表示为一个元组 $\\langle \\mathcal{A}, \\mathcal{R} \\rangle$, 其中： $\\mathcal{A}$为动作集合，其中一个动作表示拉动一根拉杆。若多臂老虎机有 $K$ 根拉杆，那么动作空间就是集合 ${a_1, \\ldots, a_K}$ ，我们用$a_t \\in \\mathcal{A}$表示任意一个动作 $a_t$ 。 $\\mathcal{R}$ 为奖励概率分布，拉动每一根杠杆的动作 $a_t$ 都对应一个奖励概率分布 $\\mathcal{R}(r \\mid a_t)$，不同拉杆的奖励概率分布通常是不同的。 假设每个时间步只能拉动一根拉杆，多臂老虎机的目标为最大化一段时间步 $T$ 内累积的奖励：$\\max \\sum_{t=1}^T r_t, r_t \\sim \\mathcal{R}(\\cdot \\mid a_t)$，其中 $a_t$ 代表在第 $t$ 时间步拉动某一拉杆这一动作， $r_t$ 代表动作 $a_t$ 获得的奖励。 在2002年，由Peter Auer等三人提出了一个简单到出人意料的算法：上置信界算法（UCB，Upper Confidence Bound）。 从概率论中我们可以知道：假设我们定义 $\\Delta \\mu$ 为样本均值 $\\bar{X}$ 的标准误差（可以理解为样本均值与总体均值的平均差异程度），那么 $\\Delta \\mu = \\frac{\\sigma}{\\sqrt{n}}$，其中 $\\sigma$ 为标准差， $n$ 为样本容量。这里由于我们对老虎机拉杆的奖励概率分布是未知的，所以这个里 $\\sigma$ 是无法精确计算得到的，所以我们将这个标准误差改写成 $\\Delta \\mu = \\frac{c}{\\sqrt{n}}$，这里的 $c$ 的取值就需要根据具体情况来进行初始化了。 对于 $\\forall a_t \\in \\mathcal{A}$，期望奖励估计更新为 $\\hat{Q}(a_t) = \\hat{Q}(a_t) + \\frac{1}{N(a_t)} \\left[ r_t - \\hat{Q}(a_t) \\right]$，由 Hoeffding 不等式（霍夫丁不等式）$\\mathbb{P} \\lbrace \\mathbb{E}[X] \\geq \\bar{x}_t + u \\rbrace \\leq e^{-2nu^2}$，我们可以很大概率得出：期望奖励 $Q(a_t)$满足 $\\hat{Q}(a_t) - \\Delta \\mu \\le Q(a_t) \\le \\hat{Q}(a_t) + \\Delta \\mu$，因此上置信界 $\\text{UCB}(a_t)=\\hat{Q}(a_t) + \\Delta \\mu=\\hat{Q}(a_t) + \\frac{c}{\\sqrt{n}}$ 这个UCB算法可以被概括为：在乐观中选择最好，在交互中降低乐观。 上面的数学定义形式下的标准误差被叫做乐观加分，在一次次选择中，乐观加分会因为 $n$ 的增大而不断减小，而算法每次会选择拉动上置信界 $\\text{UCB}(a_t)$ 最大的，也就是乐观中选择最好。 这也给了我们一个深刻的人生启示：在乐观中选择最好的那个去尝试，在尝试的交互中逐步降低你的乐观。不要害怕犯错，不要担心时间来不及，这个算法是数学中接近理论最优的做法，只要肯尝试、体验、感受、比较和提升，你一定能找到属于自己最好的选择，就怕你畏首畏尾，在固定型思维中焦虑恐惧畏缩不前，选择了一个随大流的稳妥选择了事。 ","date":"2025-06-18","objectID":"/%E4%BB%8E%E6%95%B0%E5%AD%A6%E8%A7%92%E5%BA%A6%E6%9D%A5%E7%9C%8B%E5%81%9A%E9%80%89%E6%8B%A9/:0:0","tags":["数学","RL"],"title":"从数学角度来看做选择","uri":"/%E4%BB%8E%E6%95%B0%E5%AD%A6%E8%A7%92%E5%BA%A6%E6%9D%A5%E7%9C%8B%E5%81%9A%E9%80%89%E6%8B%A9/"},{"categories":["数学"],"content":"注： 1.通用符号约定 花体字母的使用习惯：在数学中，花体字母（如 $\\mathcal{A},\\mathcal{B},\\mathcal{C}$）通常用于表示 “高级” 或 “结构化” 的对象，例如集合的集合、代数结构、拓扑空间等，以区别于普通的集合或元素（如 A,B,C 或 a,b,c）。 2.强化学习中的符号 $\\mathcal{R}(r \\mid a_t)$ 强化学习直接借用了概率论的表示方法，但有以下特点： 符号习惯： 强化学习文献中常用 $\\mathcal{R}$ 或 $R$ 表示奖励分布，以强调其与“奖励（Reward）”的关联。 例如：$\\mathcal{R}(r \\mid a_t)$ 是MDP中状态-动作对的奖励分布。 本质仍是条件概率分布，只是变量名 $(r,a_t)$ 具有领域含义。 与传统概率论的区别： 变量含义：$a_t$ 是智能体的动作（Action），属于强化学习的专用术语。 建模对象：奖励分布 $\\mathcal{R}$ 通常是问题设定的核心部分（如MAB中拉杆的奖励分布）。 数学一致性： 如果替换符号 $\\mathcal{R}(r \\mid a_t)$ 为 $P(r \\mid a_t)$，其数学定义完全不变。 ","date":"2025-06-18","objectID":"/%E4%BB%8E%E6%95%B0%E5%AD%A6%E8%A7%92%E5%BA%A6%E6%9D%A5%E7%9C%8B%E5%81%9A%E9%80%89%E6%8B%A9/:0:1","tags":["数学","RL"],"title":"从数学角度来看做选择","uri":"/%E4%BB%8E%E6%95%B0%E5%AD%A6%E8%A7%92%E5%BA%A6%E6%9D%A5%E7%9C%8B%E5%81%9A%E9%80%89%E6%8B%A9/"},{"categories":["课程"],"content":" 研一选修课程 形式化方法 ","date":"2025-06-12","objectID":"/%E5%BD%A2%E5%BC%8F%E5%8C%96%E6%96%B9%E6%B3%95/:0:0","tags":["cs课程"],"title":"形式化方法","uri":"/%E5%BD%A2%E5%BC%8F%E5%8C%96%E6%96%B9%E6%B3%95/"},{"categories":["课程"],"content":"课程大纲 image-20250628023843877 image-20250628024411057 ","date":"2025-06-12","objectID":"/%E5%BD%A2%E5%BC%8F%E5%8C%96%E6%96%B9%E6%B3%95/:1:0","tags":["cs课程"],"title":"形式化方法","uri":"/%E5%BD%A2%E5%BC%8F%E5%8C%96%E6%96%B9%E6%B3%95/"},{"categories":["课程"],"content":"数学基础 ","date":"2025-06-12","objectID":"/%E5%BD%A2%E5%BC%8F%E5%8C%96%E6%96%B9%E6%B3%95/:2:0","tags":["cs课程"],"title":"形式化方法","uri":"/%E5%BD%A2%E5%BC%8F%E5%8C%96%E6%96%B9%E6%B3%95/"},{"categories":["课程"],"content":"计算复杂性理论 研究的是哪些问题是可以被计算机计算的： P问题：存在多项式时间复杂度解法的问题（比如大家常刷的LeetCode算法题） NP问题：不确定能否找到多项式时间复杂度解法，但是有多项式时间复杂度的方法来验证答案是否正确的问题(就比如Q:打印出集合$A$的所有子集，现有方法似乎只有穷举法，$2^n$ 的时间复杂度，但是验证某个集合是否是集合$A$的子集可以很快判定出来，因此人们不禁乐观的想(^_^)是否只是人们没有发现多项式的解法，而非数学意义上完全不存在这样的多项式时间算法来求解这样的NP问题) NPC问题：NPC完全问题。NPC问题 $\\subseteq$ NP问题,而且对于任何 $\\forall x \\in $ NP问题,都可以在多项式时间内转换或归约成某一个NPC问题。 NPC问题是最近几十年对P?=NP问题比较大的理论突破。人们乐观的认为，只需要解决一个NPC问题，也就可以解决所有的NP问题。但是可惜的是，直到现在，人们还是没有解决出一个NPC问题。所以慢慢的更多的人感觉用永远也无法找到了。 以及证明任意一个NPC问题都可以解决所有的NP问题，但是NPC问题也有难度的区别，因此将目光聚焦于那些更简单的NPC问题会更简单。 ","date":"2025-06-12","objectID":"/%E5%BD%A2%E5%BC%8F%E5%8C%96%E6%96%B9%E6%B3%95/:2:1","tags":["cs课程"],"title":"形式化方法","uri":"/%E5%BD%A2%E5%BC%8F%E5%8C%96%E6%96%B9%E6%B3%95/"},{"categories":["课程"],"content":"上下文无关文法 是一套通过四元组来描述形式系统的符号工具。 四元组： G = {N、 T、 S、 P} N是非终结符的有限集合。 T是终结符的有限集合，且 $\\text{N} \\cap \\text{T} = \\varnothing$。 S是开始符号，且 $\\text{S} \\in \\text{N}$。 P是产生式的有限集合，每个产生式具有的形式如：$\\text{N} \\to \\alpha, \\alpha \\in (\\text{N} \\cup \\text{T})^*$ 下面我们来分析什么是上下文无关： 假设我们有产生式 $\\text{S} \\to \\text{a} \\mid \\text{b}$,那么如果我们遇到式子 $\\text{aS}$,那么可以替换为 $\\text{aS} \\to \\text{aa} \\mid \\text{ab}$,同理当我们遇到式子 $Sb$ 时，可以替换为 $\\text{Sb}\\to\\text{ab}\\mid\\text{bb}$。所以在上下文无关文法中，我们遇到 $\\text{S}$ 时，我们无需去关心 $\\text{S}$ 的左边和右边是什么符号（这里的a、b其实就是所谓的上下文），直接根据产生式去替换就行。 但是如果我们还有产生式 $\\text{aS}\\to aa$,那么下次当我们遇到式子 $\\text{aS}$ 时，不能直接去替换 $\\text{S}$，还得去研究 $\\text{S}$ 的上下文。这时候就是上下文有关了。 例1.1 给定文法G ​ $E ::= E + E \\mid E - E \\mid E * E \\mid E / E \\mid (E) \\mid n$ 其中，终结符 $T$ 的集合为 $\\lbrace +,-,*,/,n,()\\rbrace$, 并且符号 $n$ 表示整数； 非终结符 $N$ 的集合为 $\\lbrace E \\rbrace$； 解： 上面其实就是一个标准的上下文无关文法，他包含了我们之前说的四元组：G = {N、 T、 S、 P}，通常我们使用大写字母表示非终结符，小写字母表示终结符。这里的 $E$ 其实充当开始符号S的作用，不必拘泥于字母表示。 这个文法G可表示的集合为整数域上加减乘除的表达式 Q1： 判断表达式 $1+2*3$ 是否是文法G的元素？ $$ \\begin{aligned} E \u0026\\to E + E \\\\ \u0026\\to E + E * E \\\\ \u0026\\to n + n * n \\\\ \u0026\\to 1 + 2 * 3 \\\\ \\end{aligned} $$ 当然由于我们的文法G的规则不够完善，还未支持四则运算的优先级，所以上面的推导过程不是唯一的。 我们还可以用推导树来表示刚刚的推导过程： Q2： 怎么修改文法G的规则使得可以支持四则运算的优先级？ $$ \\begin{aligned} E \u0026::= E + T \\mid E - T \\mid T \\\\ T \u0026::= T * F \\mid T / F \\mid F \\\\ F \u0026::= (E) \\mid n \\\\ \\end{aligned} $$ 在《形式化方法》这门课中，上下文无关文法只是我们用来表达命题逻辑、谓词逻辑等等的一个最基本的表达形式，所以了解到这里就已经够了，如果想要更深入的进行学习，可以学习另一门课程《编译原理》。 ","date":"2025-06-12","objectID":"/%E5%BD%A2%E5%BC%8F%E5%8C%96%E6%96%B9%E6%B3%95/:2:2","tags":["cs课程"],"title":"形式化方法","uri":"/%E5%BD%A2%E5%BC%8F%E5%8C%96%E6%96%B9%E6%B3%95/"},{"categories":["课程"],"content":"结构化归纳法 归纳法(Induction)是一个非常强大的数学工具。 数学归纳法(Mathematical induction)：我们在高中阶段就已经学过了，他其实是建立在natural number上的一套普适原则。在高中阶段我们并没有研究数学归纳法的证明，其实这个涉及到了什么是natural number?我们需要使用纯数中的皮亚诺公理系统（Piano number)来证明这个定理。 结构化归纳法(Structural induction)：Do induction on any recursive defined structures。 良基归纳(Well-founded induction)：是基于 $2^{nd}$ 数学归纳法而推广到任意线性序的归纳法。 下面我们给出对于结构化归纳法的定义： 对于产生式： $$ A ::= \\alpha_1 \\mid \\dots \\mid \\alpha_m \\mid \\beta_1 A \\gamma_1 \\mid \\dots \\mid \\beta_n A \\gamma_n $$ 其中非终结符A在 $\\alpha_i、1 \\leq i \\leq m$ 中不出现。要证明某个命题P(A)成立，只要证明如下两个步骤： 基础步：证明命题 P 对 $\\alpha_i、1 \\leq i \\leq m$ 都成立； 归纳步：分别假设命题 P 对 $\\beta_i A \\gamma_i、1 \\leq i \\leq n$ 中的A成立，分别证明 $P(\\beta_i A \\gamma_i)$ 成立。 综合上述两个步骤，可证明命题P(A)成立。 例1.2 证明例1.1给定文法表示的集合A，左括号和右括号的数量相等 证明：设用符号(L(A))和(R(A))分别来表示集合A的左括号和右括号的数量。 归纳基础：首先对集合A的元素进行证明，可得 $L(n) = R(n) = 0$，成立。 归纳推理：设 $L(E) = R(E)$ 成立，则： $$ L(E{+}E) = L(E) + L(+) + L(E) = R(E) + R(+) + R(E) = R(E{+}E), $$ 成立，同理可证 $E - E、E * E、E / E$ 成立；对 $(E)$ 进行验证，可得： $$ L((E)) = 1 + L(E) = R(E) + 1 = R((E)), $$ 成立。所以，我们可以得出对于例（1.2）给定文法所表示的集合，具有左括号等于右括号的性质。证毕。 ","date":"2025-06-12","objectID":"/%E5%BD%A2%E5%BC%8F%E5%8C%96%E6%96%B9%E6%B3%95/:2:3","tags":["cs课程"],"title":"形式化方法","uri":"/%E5%BD%A2%E5%BC%8F%E5%8C%96%E6%96%B9%E6%B3%95/"},{"categories":["课程"],"content":"命题逻辑 ","date":"2025-06-12","objectID":"/%E5%BD%A2%E5%BC%8F%E5%8C%96%E6%96%B9%E6%B3%95/:3:0","tags":["cs课程"],"title":"形式化方法","uri":"/%E5%BD%A2%E5%BC%8F%E5%8C%96%E6%96%B9%E6%B3%95/"},{"categories":["课程"],"content":"语法规则 首先我们用之前学到的上下文无关文法，给出命题逻辑的语法规则： $$ P ::= \\top \\mid \\bot \\mid x \\mid P \\land P \\mid P \\lor P \\mid P \\to P \\mid \\lnot P $$ 符号 $\\top , \\bot , x$ 分别表示逻辑常量“真”，逻辑常量“假”，和原子命题变量。这三种语法形式都是基本的，因此我们可称它们为原子命题（其实就是上面的*终结符*）。 后面4个是通过连接词连接子命题，而构成复合命题。 ","date":"2025-06-12","objectID":"/%E5%BD%A2%E5%BC%8F%E5%8C%96%E6%96%B9%E6%B3%95/:3:1","tags":["cs课程"],"title":"形式化方法","uri":"/%E5%BD%A2%E5%BC%8F%E5%8C%96%E6%96%B9%E6%B3%95/"},{"categories":["课程"],"content":"证明系统 我们使用自然演绎系统这种形式化的逻辑证明方式系统来作为命题逻辑的证明系统。 首先我们需要先确定一些假定的推理规则，然后利用这些规则，在假定的一个真前提下，得出真结论。这里假定的真前提就是所谓的环境。（我们不关心这些前提实际的真假，只是在推理过程中假定他们为真） 定义 $2.1$（环境） 环境 $\\Gamma$ 是由$n，n\\ge 0$，个命题构成的命题列表 $$ \\Gamma = P_1, \\ldots, P_n $$ 特别的，若 $n=0$,我们称 $\\Gamma$ 为空环境。 定义 $2.2$(断言) 断言是由环境 $\\Gamma$，和命题 $P$ 构成的元组 $$ \\Gamma \\vdash P $$ $\\vdash $ 是推导符号，也即环境 $\\Gamma$ 为真可以断言得到命题 $P$ 为真。 定义 $2.3$(证明规则) 证明规则是形如 $$ \\frac{\\Gamma_1 \\vdash P_1 \\quad \\dots \\quad \\Gamma_n \\vdash P_n}{\\Gamma \\vdash P} \\ \\ \\ \\ (\\text{Rule-Name}) $$ 的一条公式，其中 $n \\ge 0$。 证明规则由三部分组成： 规则的前提：横线上方的 $n$ 条断言 规则的结论：横线下方唯一的断言 Rule-Name：规则的名字，唯一的表示了该规则 ","date":"2025-06-12","objectID":"/%E5%BD%A2%E5%BC%8F%E5%8C%96%E6%96%B9%E6%B3%95/:3:2","tags":["cs课程"],"title":"形式化方法","uri":"/%E5%BD%A2%E5%BC%8F%E5%8C%96%E6%96%B9%E6%B3%95/"},{"categories":["课程"],"content":"推导规则 首先我们来看看最简单的变量规则，它是一条公理，也就是这个规则结论的推出是不需要前提的： $$ \\frac{}{\\Gamma, P \\vdash P} \\ (\\mathrm{Var}) $$ 显然如果命题$P$在环境中出现，根据定义就可以推出$P$成立。 下面是真引入规则： $$ \\frac{}{\\Gamma \\vdash \\top} \\ (\\top I) $$ 它也是一条公理，表示在任意环境 $\\Gamma$ 中，命题 $\\top$ 都无条件成立。 接下来我们来看看假消除规则： $$ \\frac{\\Gamma \\vdash \\bot}{\\Gamma \\vdash P} \\ (\\bot E) $$ 可以理解为环境 $\\Gamma$ 能推出 “假”，即 $\\Gamma$ 中包含矛盾（比如同时有 $A$ 和 $\\neg A$），那么环境 $\\Gamma$ 能推出**任意命题** $P$（无论 $P$ 本身是否合理）。 逻辑意义：维护 “无矛盾则有效” 的体系，它揭示了 “矛盾会摧毁推理有效性” 这一本质，迫使使用者必须保证前提的一致性，否则推理将失去意义。 其他的规则我们也就不一一讲解了，下面给出完整的最基础的$14$条命题逻辑的推理规则： $$ \\frac{}{\\Gamma, P \\vdash P} \\ (\\mathrm{Var}) \\quad\\quad\\quad\\quad\\quad\\quad \\frac{}{\\Gamma \\vdash \\top} \\ (\\top I) $$ $$ \\frac{\\Gamma \\vdash \\bot}{\\Gamma \\vdash P} \\ (\\bot E) \\quad\\quad\\quad\\quad\\quad\\quad \\frac{\\Gamma \\vdash P \\quad\\quad \\Gamma \\vdash Q}{\\Gamma \\vdash P \\land Q} \\ (\\land I) $$ $$ \\frac{\\Gamma \\vdash P \\land Q}{\\Gamma \\vdash P} \\ (\\land E1) \\quad\\quad\\quad\\quad\\quad\\quad \\frac{\\Gamma \\vdash P \\land Q}{\\Gamma \\vdash Q} \\ (\\land E2) $$ $$ \\frac{\\Gamma \\vdash P}{\\Gamma \\vdash P \\lor Q} (\\lor I1) \\quad\\quad\\quad\\quad\\quad\\quad \\frac{\\Gamma \\vdash Q}{\\Gamma \\vdash P \\lor Q} (\\lor I2) $$ $$ \\frac{\\Gamma, P \\vdash Q}{\\Gamma \\vdash P \\to Q} (\\to I) \\quad\\quad\\quad\\quad \\frac{\\Gamma \\vdash P \\to Q \\quad\\quad \\Gamma \\vdash P}{\\Gamma \\vdash Q} (\\to E) $$ $$ \\frac{\\Gamma, P \\vdash \\perp}{\\Gamma \\vdash \\neg P} (\\neg I) \\quad\\quad\\quad\\quad\\quad\\quad\\quad \\frac{\\Gamma \\vdash P \\quad\\quad \\Gamma \\vdash \\neg P}{\\Gamma \\vdash \\perp} (\\neg E) $$ $$ \\frac{\\Gamma \\vdash P \\lor Q \\quad\\quad \\Gamma, P \\vdash R \\quad\\quad \\Gamma, Q \\vdash R}{\\Gamma \\vdash R} (\\lor E) \\quad\\quad\\quad \\frac{\\Gamma \\vdash \\neg \\neg P}{\\Gamma \\vdash P} (\\neg\\neg E) $$ 例2.1 根据上面的推导规则，画出命题 $\\vdash P \\to \\neg \\neg P$ 的证明树 从下往上根据上面的14条推理规则去找匹配的进行推导就行，最后推导到公理即可： $$ \\begin{array}{c} \\dfrac{ \\dfrac{ \\dfrac{ \\dfrac{}{P, \\neg P \\vdash P}\\text{(Var)} \\quad \\dfrac{}{P, \\neg P \\vdash \\neg P}\\text{(Var)} }{P, \\neg P \\vdash \\bot}(\\neg E) }{P \\vdash \\neg \\neg P}(\\neg I) }{\\vdash P \\to \\neg \\neg P}(\\to I) \\end{array} $$ ","date":"2025-06-12","objectID":"/%E5%BD%A2%E5%BC%8F%E5%8C%96%E6%96%B9%E6%B3%95/:3:3","tags":["cs课程"],"title":"形式化方法","uri":"/%E5%BD%A2%E5%BC%8F%E5%8C%96%E6%96%B9%E6%B3%95/"},{"categories":["课程"],"content":"SAT问题 SAT（布尔可满足性理论）：given a proposition P, is it satisfiable? 第一个NPC问题(Cook-Levin, 1971) 显然我们可以通过画真值表的方式来得到答案，但是时间复杂度是$O(2^n)$。 那么有没有更快一点的方式让计算机来解决SAT问题呢？ 有的有的兄弟，那就是就是DPLL算法： CNF（合取范式） 解析与传播 解析：决策 传播：布尔约束传播（BCP） 所有命题公式都可以转换成 CNF 的等价公式。在布尔逻辑中，如果一个公式公式(数理逻辑)是子句的，那么它是合取范式（CNF）的。作为规范形式，它在自动定理证明中有用。 例如，下列所有公式都是CNF: $$ \\begin{aligned} \u0026 A \\land B \\\\ \u0026 \\neg A \\land (B \\lor C) \\\\ \u0026 (A \\lor B) \\land (\\neg B \\lor C \\lor \\neg D) \\land (D \\lor \\neg E) \\\\ \u0026 (\\neg B \\lor C) \\\\ \\end{aligned} $$ 而下列不是: $$ \\begin{aligned} \u0026 \\neg (B \\lor C) \\\\ \u0026 (A \\land B) \\lor C \\\\ \u0026 A \\land (B \\lor (D \\land E)) \\\\ \\end{aligned} $$ 上述三个公式分别等价于合取范式的下列三个公式: $$ \\begin{aligned} \u0026 \\neg B \\land \\neg C \\\\ \u0026 (A \\lor C) \\land (B \\lor C) \\\\ \u0026 A \\land (B \\lor D) \\land (B \\lor E) \\\\ \\end{aligned} $$ 等价转换公式： $$ \\begin{aligned} \\mathcal{E}(\\top) \u0026= \\top \\\\ \\mathcal{E}(\\bot) \u0026= \\bot \\\\ \\mathcal{E}(p) \u0026= p \\\\ \\mathcal{E}(P \\land Q) \u0026= \\mathcal{E}(P) \\land \\mathcal{E}(Q) \\\\ \\mathcal{E}(P \\lor Q) \u0026= \\mathcal{E}(P) \\lor \\mathcal{E}(Q) \\\\ \\mathcal{E}(P \\to Q) \u0026= \\mathcal{E}(\\neg P) \\lor \\mathcal{E}(Q) \\\\ \\mathcal{E}(\\neg P) \u0026= \\neg \\mathcal{E}(P) \\\\ \\end{aligned} $$ $$ \\begin{aligned} \\mathcal{N}(\\top) \u0026= \\top \\\\ \\mathcal{N}(\\bot) \u0026= \\bot \\\\ \\mathcal{N}(p) \u0026= p \\\\ \\mathcal{N}(\\neg P) \u0026= \\neg \\mathcal{N}(P) \\\\ \\mathcal{N}(\\neg \\neg P) \u0026= \\mathcal{N}(P) \\\\ \\mathcal{N}(P \\land Q) \u0026= \\mathcal{N}(P) \\land \\mathcal{N}(Q) \\\\ \\mathcal{N}(P \\lor Q) \u0026= \\mathcal{N}(P) \\lor \\mathcal{N}(Q) \\\\ \\mathcal{N}(\\neg (P \\land Q)) \u0026= \\mathcal{N}(\\neg P) \\lor \\mathcal{N}(\\neg Q) \\\\ \\mathcal{N}(\\neg (P \\lor Q)) \u0026= \\mathcal{N}(\\neg P) \\land \\mathcal{N}(\\neg Q) \\\\ \\end{aligned} $$ $$ \\begin{aligned} \\mathcal{C}(\\top) \u0026= \\top \\\\ \\mathcal{C}(\\bot) \u0026= \\bot \\\\ \\mathcal{C}(p) \u0026= p \\\\ \\mathcal{C}(\\neg p) \u0026= \\neg \\mathcal{C}(p) \\\\ \\mathcal{C}(P \\land Q) \u0026= \\mathcal{C}(P) \\land \\mathcal{C}(Q) \\\\ \\mathcal{C}(P \\lor Q) \u0026= \\mathcal{D}\\bigl(\\mathcal{C}(P), \\mathcal{C}(Q)\\bigr) \\\\ \\mathcal{D}(P_1 \\land P_2, Q) \u0026= \\mathcal{D}(P_1, Q) \\land \\mathcal{D}(P_2, Q) \\\\ \\mathcal{D}(P, Q_1 \\land Q_2) \u0026= \\mathcal{D}(P, Q_1) \\land \\mathcal{D}(P, Q_2) \\\\ \\mathcal{D}(P, Q) \u0026= P \\lor Q \\\\ \\end{aligned} $$ 例2.2 转换命题 $$ (p_1 \\land \\neg \\neg p_2) \\lor (\\neg q_1 \\to q_2) $$ 为CNF命题。 消去蕴含。 $$ \\begin{aligned} \\mathcal{E}\\bigl(((p_1 \\land \\neg \\neg p_2) \\lor (\\neg q_1 \\to q_2))\\bigr) \u0026= \\mathcal{E}(p_1 \\land \\neg \\neg p_2) \\lor \\mathcal{E}(\\neg q_1 \\to q_2) \\\\ \u0026= \\bigl(\\mathcal{E}(p_1) \\land \\mathcal{E}(\\neg \\neg p_2)\\bigr) \\lor \\bigl(\\mathcal{E}(\\neg q_1) \\lor \\mathcal{E}(q_2)\\bigr) \\\\ \u0026= (p_1 \\land \\neg \\neg p_2) \\lor (\\neg \\neg q_1 \\lor q_2) \\\\ \\end{aligned} $$ 转换为NNF。 $$ \\begin{aligned} \\mathcal{N}\\bigl(((p_1 \\land \\neg \\neg p_2) \\lor (\\neg \\neg q_1 \\lor q_2))\\bigr) \u0026= \\mathcal{N}(p_1 \\land \\neg \\neg p_2) \\lor \\mathcal{N}(\\neg \\neg q_1 \\lor q_2) \\\\ \u0026= \\bigl(\\mathcal{N}(p_1) \\land \\mathcal{N}(\\neg \\neg p_2)\\bigr) \\lor \\bigl(\\mathcal{N}(\\neg \\neg q_1) \\lor \\mathcal{N}(q_2)\\bigr) \\\\ \u0026= (p_1 \\land p_2) \\lor (q_1 \\lor q_2) \\\\ \\end{aligned} $$ 等价转换为CNF $$ \\begin{aligned} \\mathcal{C}\\bigl(((p_1 \\land p_2) \\lor (q_1 \\lor q_2))\\bigr) \u0026= \\mathcal{D}\\bigl(\\mathcal{C}(p_1 \\land p_2), \\mathcal{C}(q_1 \\lor q_2)\\bigr) \\\\ \u0026= \\mathcal{D}(p_1 \\land p_2, \\mathcal{D}(q_1, q_2)) \\\\ \u0026= \\mathcal{D}\\bigl(p_1, \\mathcal{D}(q_1, q_2)\\bigr) \\land \\mathcal{D}\\bigl(p_2, \\mathcal{D}(q_1, q_2)\\bigr) \\\\ \u0026= \\mathcal{D}\\bigl(p_1, q_1 \\lor q_2\\bigr) \\land \\mathcal{D}\\bigl(q_2, q_1 \\lor q_2\\bigr) \\\\ \u0026= (p_1 \\lor q_1 \\lor q_2) \\land (p_2 \\lor q_1 \\lor q_2) \\\\ \\end{aligned} $$ ","date":"2025-06-12","objectID":"/%E5%BD%A2%E5%BC%8F%E5%8C%96%E6%96%B9%E6%B3%95/:3:4","tags":["cs课程"],"title":"形式化方法","uri":"/%E5%BD%A2%E5%BC%8F%E5%8C%96%E6%96%B9%E6%B3%95/"},{"categories":["课程"],"content":"构造逻辑 与经典命题逻辑的区别：是否接受排中律 $\\vdash P \\lor \\neg P$ ? 也就会导致我们无法使用反证法来证明命题成立。也就是我们再也无法通过证明 $\\neg P$ 成立来证明 $P$ 不成立。 ","date":"2025-06-12","objectID":"/%E5%BD%A2%E5%BC%8F%E5%8C%96%E6%96%B9%E6%B3%95/:4:0","tags":["cs课程"],"title":"形式化方法","uri":"/%E5%BD%A2%E5%BC%8F%E5%8C%96%E6%96%B9%E6%B3%95/"},{"categories":["课程"],"content":"语法规则 $$ P ::= p \\mid \\top \\mid \\bot \\mid x \\mid P \\land P \\mid P \\lor P \\mid P \\to P $$ $\\neg P$ 被替换为 $p \\to \\bot$，而不再出现。 ","date":"2025-06-12","objectID":"/%E5%BD%A2%E5%BC%8F%E5%8C%96%E6%96%B9%E6%B3%95/:4:1","tags":["cs课程"],"title":"形式化方法","uri":"/%E5%BD%A2%E5%BC%8F%E5%8C%96%E6%96%B9%E6%B3%95/"},{"categories":["课程"],"content":"证明系统 同命题逻辑。 ","date":"2025-06-12","objectID":"/%E5%BD%A2%E5%BC%8F%E5%8C%96%E6%96%B9%E6%B3%95/:4:2","tags":["cs课程"],"title":"形式化方法","uri":"/%E5%BD%A2%E5%BC%8F%E5%8C%96%E6%96%B9%E6%B3%95/"},{"categories":["课程"],"content":"推导系统 剔除了双重否定律以及$\\neg$的引入和消去规则，其他都同命题逻辑。 ","date":"2025-06-12","objectID":"/%E5%BD%A2%E5%BC%8F%E5%8C%96%E6%96%B9%E6%B3%95/:4:3","tags":["cs课程"],"title":"形式化方法","uri":"/%E5%BD%A2%E5%BC%8F%E5%8C%96%E6%96%B9%E6%B3%95/"},{"categories":["课程"],"content":"谓词逻辑 The Syntax: $$ \\begin{aligned} E \u0026::= x \\mid c \\mid f(E,\\dots,E) \\\\ R \u0026::= r(E,\\dots,E) \\\\ P \u0026::= R \\\\ \u0026\\phantom{::} \\mid \\top \\\\ % 用 \\phantom 占位 ::= 的空格 \u0026\\phantom{::} \\mid \\bot \\\\ \u0026\\phantom{::} \\mid P \\lor P \\\\ \u0026\\phantom{::} \\mid P \\land P \\\\ \u0026\\phantom{::} \\mid P \\rightarrow P \\\\ \u0026\\phantom{::} \\mid \\neg P \\\\ \u0026\\phantom{::} \\mid \\forall x, P \\\\ \u0026\\phantom{::} \\mid \\exists x, P \\\\ \\end{aligned} $$ $E$:表达式 $x$：变量 $c$：常量 $R$:关系 $r()$：关系算符 $P$：命题 Intuition: 我们把上面的这套公理化系统引入到数论中直观感受一下各项代表着什么： $$ \\begin{aligned} E \u0026::= x \\mid \\mathbb{Z} \\mid E+E \\mid E-E \\mid \\dots \\\\ R \u0026::= E\u003eE \\mid E=E \\mid E \\le E \\\\ P \u0026::= R \\\\ \u0026\\phantom{::} \\mid \\top \\\\ % 用 \\phantom 占位 ::= 的空格 \u0026\\phantom{::} \\mid \\bot \\\\ \u0026\\phantom{::} \\mid P \\lor P \\\\ \u0026\\phantom{::} \\mid P \\land P \\\\ \u0026\\phantom{::} \\mid P \\rightarrow P \\\\ \u0026\\phantom{::} \\mid \\neg P \\\\ \u0026\\phantom{::} \\mid \\forall x, P \\\\ \u0026\\phantom{::} \\mid \\exists x, P \\\\ \\end{aligned} $$ 很明显：上面这套谓词逻辑是数论的一种抽象，这种Syntax是由逻辑学派创建出来的。逻辑学已经有2000多年的历史了，最终确定下来这种形式，其实是对其中的抽象性和具体性的一种平衡。如果太讲究抽象性，那么就无法得出什么meaningful的结论，但如果太讲究具体性，就有可能会偏向于某一理论。 谓词逻辑其实就是从数论、集合论、矩阵理论等等中抽象出了一个共性语法规则，他的好处就是如果能正面共性成立，就无需去将每一个底层理论继续证明，就比如哥德尔不完备性定理就是在数理逻辑框架下证明，所以对于任意框架都成立。 ","date":"2025-06-12","objectID":"/%E5%BD%A2%E5%BC%8F%E5%8C%96%E6%96%B9%E6%B3%95/:5:0","tags":["cs课程"],"title":"形式化方法","uri":"/%E5%BD%A2%E5%BC%8F%E5%8C%96%E6%96%B9%E6%B3%95/"},{"categories":["课程"],"content":"推导规则 $$ \\frac{\\Gamma, x \\vdash P}{\\Gamma \\vdash \\forall x. P} \\ (\\forall I) \\quad \\quad \\quad \\quad \\quad\\quad \\quad\\quad \\frac{\\Gamma \\vdash \\forall x. P}{\\Gamma \\vdash P[x \\mapsto E]} \\ (\\forall E) $$ $$ \\frac{\\Gamma \\vdash P[x \\mapsto E]}{\\Gamma \\vdash \\exists x. P} \\ (\\exists I) \\quad \\quad \\quad \\frac{\\Gamma \\vdash \\exists x. P \\quad\\quad \\Gamma, x, P \\vdash Q}{\\Gamma \\vdash Q} \\ (\\exists E) $$ Bound free variables Bound variables （绑定变量）：默认只绑定最近的一个命题 Free variables （自由变量） $\\forall x, P(x,y)$中，$x$ 就是绑定变量，$y$ 就是自由变量。 其实就可以翻译成类似下面的code： int y = 10; int f(int x) { return p(x, y); } $\\alpha$ - 重命名 SAT SAT（可满足性理论）：given a proposition P, is it satisfiable? SAT for 命题逻辑: NPC问题。但是从实践上来说，使用DPLL等算法可以在很合理的时间内求解相当大规模的实际问题 SAT for 谓词逻辑: 不可判定/理论上证明不可能有算法可以在合理时间求解/不可解 这就引导我们去思考：有没有可能通过我们使用一些特殊的子集，对这个子集进行求解仍然是可解的呢？其实这就是下面我们要讲的theory theory SMT SMT(可解释性模理论)：Satisfiability modulo theory SAT + Theory Solvers = SMT SMT的意义在于：CS中的终极大杀器。针对非常非常复杂的问题（如NPC问题），有没有一套通用范式来解决这类难题吗？那就是SMT。如果一个问题很难，我不知道该怎么解，那就上SMT，大概率就有用；如果SMT都没用，那估计你用其他方法也解不了。 ","date":"2025-06-12","objectID":"/%E5%BD%A2%E5%BC%8F%E5%8C%96%E6%96%B9%E6%B3%95/:5:1","tags":["cs课程"],"title":"形式化方法","uri":"/%E5%BD%A2%E5%BC%8F%E5%8C%96%E6%96%B9%E6%B3%95/"},{"categories":["编程"],"content":"问题定位： PS C:\\Users\\god\u003e python -u \"c:\\Users\\god\\Desktop\\gold.py\" Traceback (most recent call last): File \"c:\\Users\\god\\Desktop\\gold.py\", line 1, in \u003cmodule\u003e import requests ModuleNotFoundError: No module named 'requests' 明明已经在conda中安装了 requests，却依旧报错找不到，下面给出解决方案： 使用 “Python: 清除工作区解释器设置” 命令以清除当前设置的解释器上下文。 步骤：1. 按 Ctrl+Shift+P 打开命令面板；2. 输入“Python: 清除工作区解释器设置”；3. 回车执行命令。 使用 “开发人员: 重新加载窗口” 命令重启 VS Code，从而刷新解释器上下文。 步骤：1. 按 Ctrl+Shift+P 打开命令面板；2. 输入“开发人员: 重新加载窗口”；3. 回车执行命令。 使用 “Python: 选择解释器” 命令重新选择正确的 Python 解释器。 步骤：1. 按 Ctrl+Shift+P 打开命令面板；2. 输入“Python: 选择解释器”；3. 回车执行命令。 ","date":"2025-04-25","objectID":"/vscode%E7%BC%BA%E5%B0%91module%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/:0:0","tags":["编程"],"title":"vscode缺少module解决方法","uri":"/vscode%E7%BC%BA%E5%B0%91module%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/"},{"categories":["健身"],"content":" 腿+肩 背+二头 胸+三头+腹 史密斯推肩 单侧15~17.5kg 高位下拉 递减组 平板卧推 单侧20kg触胸一次 蝴蝶机方向飞鸟 32kg 划船 上斜卧推 绳索侧拉 只能上两格重量 绳索下拉 递减组 绳索面拉 40kg ","date":"2025-01-07","objectID":"/%E8%87%AA%E7%94%A8%E5%81%A5%E8%BA%AB%E8%AE%A1%E5%88%92/:0:0","tags":["健身"],"title":"自用健身计划","uri":"/%E8%87%AA%E7%94%A8%E5%81%A5%E8%BA%AB%E8%AE%A1%E5%88%92/"},{"categories":["编程"],"content":"期末复习针对pdf提问prompt 由于12月22号就要开始考信息安全，本人12月21号才开始学习，直接看别人整理好的笔记复习感觉知识点不是很进脑子，于是想到了之前似乎也看到过一个类似的B站视频有人想做一个自我学习提升的gpt应用： image-20241221174515561 image-20241221175536519 有时间我也要做个自己的gpt（乐） 也就是利用费曼学习法：基于提问式，然后讲解自己理解并回答，从而达到检测自己学习效果的作用， 本来很难找到这种提问，但是现在 ai 的出现给了新的希望： image-20241221174908787 提示词： 你是一位费曼学习法的实践者和辅导专家，专注于通过提问来促进深度学习和理解。你的任务是针对我提供的学习资料，设计一系列问题，引导我进行自我检验，并通过你的反馈帮助我纠正错误，加深理解。 Action（行动）： 1. 接收并仔细阅读我提供的学习资料。 2. 根据资料内容，设计问题，确保问题能够有效检验我对关键概念和信息的掌握。 3. 提出第一个问题，并要求我给出回答，问题下面不应该给出答案，而是仅仅只有问题。 4. 等待我的回答，我还未回复就不要进行下面的任务。 5. 评估我的回答，如果发现错误或不准确，在纠正错误时，使用清晰、简洁的语言，给出提示，鼓励我通过自我修正来提高学习效果。 6. 继续提出下一个问题，直到所有问题都被提出并得到回答。 Purpose（目的）： 通过提问式学习，帮助我更好地理解学习资料，提升我的学习效果和批判性思维能力。 Expectation（期望）： 1. 每次只提出一个问题，确保问题与学习资料紧密相关。 2. 在我回答后，提供有建设性的反馈，指出错误并引导我理解正确答案。 3. 在纠正错误时，使用清晰、简洁的语言，避免直接给出资料中的正确答案。 4. 保持提问的连贯性和逻辑性，确保每个问题都能促进对资料内容的深入理解。 5. 鼓励我通过自我修正来提高学习效果，而不是依赖直接的答案。 ","date":"2024-12-21","objectID":"/%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E9%92%88%E5%AF%B9pdf%E6%8F%90%E9%97%AEprompt/:1:0","tags":["编程"],"title":"期末复习针对pdf提问prompt","uri":"/%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E9%92%88%E5%AF%B9pdf%E6%8F%90%E9%97%AEprompt/"},{"categories":["编程"],"content":"ChatGPT 费曼学习法教练 提示词(Prompts) 我想让你充当一个费曼方法教练。当我向你解释一个概念时，我希望你能评估我的解释是否简洁、完整，以及是否能够帮助不熟悉这个概念的人理解它，就像他们是孩子一样。如果我的解释没有达到这些期望，我希望你能向我提出问题，引导我完善我的解释，直到我完全理解这个概念。另一方面，如果我的解释符合要求的标准，我将感谢你的反馈，我将继续进行下一次解释。 ","date":"2024-12-21","objectID":"/%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E9%92%88%E5%AF%B9pdf%E6%8F%90%E9%97%AEprompt/:1:1","tags":["编程"],"title":"期末复习针对pdf提问prompt","uri":"/%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E9%92%88%E5%AF%B9pdf%E6%8F%90%E9%97%AEprompt/"},{"categories":["编程"],"content":".tmux.conf # 基本设置 set-option -g history-limit 100000 # 提高历史记录限制，适合查看长时间的输出 set-option -g mouse on # 启用鼠标支持 #set-option -g default-shell /usr/bin/bash # 默认使用 Bash，视情况而定 set-option -g prefix C-a # 更改前缀键为 Ctrl + a (如不习惯可改回 C-b) unbind C-b # 取消 Ctrl + b 作为前缀键 bind C-a send-prefix # 保留 Ctrl + a 为前缀键 # 窗格管理 bind '\"' split-window -v # 快速切换窗格 bind h select-pane -L # 切换到左侧窗格 bind j select-pane -D # 切换到下方窗格 bind k select-pane -U # 切换到上方窗格 bind l select-pane -R # 切换到右侧窗格 # 更改窗格大小 bind -r H resize-pane -L 5 # 左调整窗格大小 bind -r J resize-pane -D 5 # 下调整窗格大小 bind -r K resize-pane -U 5 # 上调整窗格大小 bind -r L resize-pane -R 5 # 右调整窗格大小 # 鼠标滚轮绑定 bind -n WheelUpPane if-shell -F '#{pane_in_mode}' 'send-keys -M' 'copy-mode -e' # 鼠标滚轮向上时进入复制模式 bind -n WheelDownPane send-keys -M # 鼠标滚轮向下时退出复制模式 # 复制模式和粘贴 unbind -T copy-mode-vi v # 取消 vi 风格的视觉模式 bind -T copy-mode-vi v send -X begin-selection # 按 v 开始选择 bind -T copy-mode-vi y send -X copy-selection # 按 y 复制内容 bind p paste-buffer # 前缀键 + p 粘贴内容 # 状态栏优化 set-option -g status-interval 2 # 每 2 秒刷新状态栏 set-option -g status-left \"#[fg=green](#S) \" # 显示会话名 set-option -g status-right \"\" # 不显示时间 # 改进外观 set-option -g status-bg black # 状态栏背景色 set-option -g status-fg green # 状态栏前景色 set-window-option -g window-status-current-style bg=blue,fg=white # 当前窗口的状态栏样式 # 快速重载配置文件 bind r source-file ~/.tmux.conf \\; display-message \"Tmux 配置已重载\" # 前缀键 + r 重载配置 .vimrc \" 启用混合行号 set number relativenumber \" 启用语法高亮 syntax on \" 自动检测文件类型，加载相应插件和缩进规则 filetype plugin indent on \" 设置缩进相关配置 set tabstop=4 \" 一个 tab 键对应 4 个空格 set shiftwidth=4 \" 自动缩进使用 4 个空格 set expandtab \" 将 tab 转换为空格 set autoindent \" 自动缩进 set smartindent \" 根据语法自动调整缩进 \" 搜索时忽略大小写，除非有大写字母 set ignorecase set smartcase \" 实时高亮搜索结果 set hlsearch \" 但一旦你移动光标，高亮将被自动取消 autocmd CursorMoved * :nohlsearch \" 输入搜索模式时增量显示匹配结果 set incsearch \" 显示光标当前位置的状态行 set ruler \" 启用状态栏 set laststatus=2 \" 启用命令行补全 set wildmenu \" 启用光标下方 8 行预留显示 set scrolloff=6 \" 高亮当前行 set cursorline \" 显示匹配的括号 set showmatch \" 启用多级撤销 set undofile set undodir=~/.vim/undodir \" 保存撤销历史的目录 \" 减少更新屏幕的时间间隔（更快的响应速度） set updatetime=300 \" 减少交换文件写入的频率 set lazyredraw ","date":"2024-12-19","objectID":"/%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6config%E6%B1%87%E6%80%BB/:0:0","tags":["编程"],"title":"常用配置文件config汇总","uri":"/%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6config%E6%B1%87%E6%80%BB/"},{"categories":["编程"],"content":" git pull --rebase：用于 GitHub 上有多余的提交没有被本地同步，而本地又有了新的commit，此时直接 git pull 会导致 git merge 导致历史树过于复杂。而 git pull –rebase 则可以将历史树变成线性的。 首先，它会从远程 main 分支拉取最新的提交。 然后，Git 会暂时保存你本地的更改（即你修改的文件），并应用远程仓库的更改。 最后，Git 会将你本地的更改（之前未推送的）重新应用到拉取下来的远程更改之后。 ​ 最后通过git rebase --continue结束 rebase状态才能继续git push更新到仓库。 git reset --hard commitId ","date":"2024-12-14","objectID":"/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:0:0","tags":["编程"],"title":"Git常用命令","uri":"/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["编程"],"content":"注意：有三级标题的知识点说明已经学完，如果只有二级标题说明这个知识点还未收录经典题目进行整理学习，敬请期待… 题目格式模板： ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:0:0","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"AcWing 题目描述 ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:0:1","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"1064. 小国王 xxx 输入格式 xxx 输出格式 xxx 数据范围 $0\u003cN≤1000$ 输入样例： 输出样例： 算法设计 xxx 完整 C++ 代码 xxx 算法设计 xxx 完整 C++ 代码 xxx 第一章 基础算法 ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:0:2","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"快速排序 ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:1:0","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"AcWing 785. 快速排序 题目描述 给定你一个长度为 $𝑛$ 的整数数列。 请你使用快速排序对这个数列按照从小到大进行排序。 并将排好序的数列按顺序输出。 输入格式 输入共两行，第一行包含整数 $n$。 第二行包含 $n$ 个整数（所有整数均在 $1∼10^9$ 范围内），表示整个数列。 输出格式 输出共一行，包含 $n$ 个整数，表示排好序的数列。 数据范围 $1≤𝑛≤100000$ 输入样例： 5 3 1 2 4 5 输出样例： 1 2 3 4 5 算法设计 下面给出y总的快排模板： void quick_sort(int q[], int l, int r) { if (l \u003e= r) return; int i = l - 1, j = r + 1, x = q[l + r \u003e\u003e 1]; while (i \u003c j) { do i ++ ; while (q[i] \u003c x); do j -- ; while (q[j] \u003e x); if (i \u003c j) swap(q[i], q[j]); } quick_sort(q, l, j); quick_sort(q, j + 1, r); } 完整 C++ 代码 #include \u003ciostream\u003e using namespace std; const int N = 1000010; int q[N]; void quick_sort(int q[], int l, int r) { if (l \u003e= r) return; int i = l - 1, j = r + 1, x = q[l + r \u003e\u003e 1]; while (i \u003c j) { do i ++ ; while (q[i] \u003c x); do j -- ; while (q[j] \u003e x); if (i \u003c j) swap(q[i], q[j]); } quick_sort(q, l, j); quick_sort(q, j + 1, r); } int main() { int n; scanf(\"%d\", \u0026n); for (int i = 0; i \u003c n; i ++ ) scanf(\"%d\", \u0026q[i]); quick_sort(q, 0, n - 1); for (int i = 0; i \u003c n; i ++ ) printf(\"%d \", q[i]); return 0; } ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:1:1","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"二分查找 ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:2:0","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"AcWing 789. 数的范围 题目描述 给定一个按照升序排列的长度为 $n$ 的整数数组，以及 $q$ 个查询。 对于每个查询，返回一个元素 $k$ 的起始位置和终止位置（位置从 $0$ 开始计数）。 如果数组中不存在该元素，则返回 -1 -1。 输入格式 第一行包含整数 $n$ 和 $q$，表示数组长度和询问个数。 第二行包含 $n$ 个整数（均在 $1∼10000$ 范围内），表示完整数组。 接下来 $q$ 行，每行包含一个整数 $k$，表示一个询问元素。 输出格式 共 $q$ 行，每行包含两个整数，表示所求元素的起始位置和终止位置。 如果数组中不存在该元素，则返回 -1 -1。 数据范围 $1≤n≤100000$ $1≤q≤10000$ $1≤k≤10000$ 输入样例： 6 3 1 2 2 3 3 4 3 4 5 输出样例： 3 4 5 5 -1 -1 算法设计 一般的二分查找问题其实都可以抽象成一个更具体的问题：如何满足条件的第一次出现和最后一次出现的元素下标？ 下面我们给出模板： bool check(int x) { // 坚持元素x是否满足条件 } // 模板1：求满足条件的第一次出现的元素下标 int bsearch_1(int* a, int l, int r) { while (l \u003c r) { int mid = l + r \u003e\u003e 1; if (check(a[mid])) r = mid; else l = mid + 1; } return l; } // 模板2：求满足条件的最后一次出现的元素下标 int bsearch_2(int* a, int l, int r) { while (l \u003c r) { int mid = l + r + 1 \u003e\u003e 1; // 这里要+1是因为l=mid，如何l+r\u003e\u003e1可能还是l，会死循环 if (check(a[mid])) l = mid; else r = mid - 1; } return l; } 注：模板中使用了右移运算 $»1$，而不是整数除法 $/ 2$。这是因为右移运算是向下取整，而整数除法是向 $0$ 取整，当二分区间出现负数时后者会出 bug。 那么对于本题来说，求升序排列数组中元素 $k$ 的起始位置和终止位置，也可以转化成刚刚一个更抽象的问题。 假设我们有下面数组： $$ \\begin{matrix}1,\\ 3,\\ \\underbrace{ 6,\\ 6, \\ 6,\\ 6, } \\ 8,\\ 9,\\ 9,\\ 10 \\end{matrix} $$ 我们需要找到元素 $6$ 出现的起始位置和终止位置。 显然，元素 $6$ 的起始位置其实可以看成是满足 $x \\ge 6$ 条件的第一次出现的元素下标 ： $$ \\begin{matrix} 1,\\ 3, \\ \\underbrace{6,\\ 6, \\ 6,\\ 6,\\ 8,\\ 9,\\ 9,\\ 10} \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ge6 \\end{matrix} $$ 所以我们使用模板1就可以求解。 求终止位置的思路类似，这里就不再赘述。 这里我们引入灵茶山艾府灵神的写法来作参考，因为这种写法和c++中STL中给出的lower_bound()和upper_bound()的思想一致，应用了循环不变量的核心思想。 下面我们先看看如何找到满足 $≥$target的第一次出现的元素下标： 关键： 循环不变量 $L-1$ 始终是红色(＜target) $R+1$ 始终是蓝色(≥target) lower_bound()模板如下： // 找到第一个≥target的下标 int lower_bound(vector\u003cint\u003e\u0026 nums, int target) { // 闭区间:[l, r] int l = 0, r = nums.size() - 1; while (l \u003c= r) // 区间不为空 { int mid = l + r \u003e\u003e 1; if (nums[mid] \u003c target) l = mid + 1; // 区间缩小为[mid + 1, r] else r = mid - 1; // 区间缩小为[l, mid - 1] } return l; } 根据循环不变量， $R+1$ 是我们要找的答案，又由于循环终止条件 $L=R+1$，故答案也可以直接用 $L$ 表示。 下面我们来讨论常见的四种形式：$\\ \\ge,\\ \\le,\\ \u003c$ 对于整数而言，其实这四种情况只需要实现 lower_bound() 都可以解决: $\\ge t$：lower_bound(t) $\u003et$：lower_bound(t + 1) $\\le t$：lower_bound(t + 1) - 1 $\u003ct$：lower_bound(t) - 1 完整 C++ 代码 #include\u003ciostream\u003e using namespace std; const int N = 1e5 + 10; int a[N]; void binarySearch(int* a, int n, int k) { int l = 0, r = n - 1; while (l \u003c r) { int mid = l + r \u003e\u003e 1; if (a[mid] \u003e= k) r = mid; else l = mid + 1; } if (a[l] != k) { cout \u003c\u003c -1 \u003c\u003c \" \" \u003c\u003c -1 \u003c\u003c endl; return; } else { cout \u003c\u003c l \u003c\u003c \" \"; int l = 0, r = n - 1; while (l \u003c r) { int mid = l + r + 1 \u003e\u003e 1; if (a[mid] \u003c= k) l = mid; else r = mid - 1; } cout \u003c\u003c l \u003c\u003c endl; } } int main() { int n, q; cin \u003e\u003e n \u003e\u003e q; for (int i = 0; i \u003c n; i++) cin \u003e\u003e a[i]; for (int i = 0; i \u003c q; i++) { int x; cin \u003e\u003e x; binarySearch(a, n, x); } } 拓展 ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:2:1","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"790. 数的三次方根 给定一个浮点数 $n$，求它的三次方根。 输入格式 共一行，包含一个浮点数 $n$。 输出格式 共一行，包含一个浮点数，表示问题的解。 注意，结果保留 $6$ 位小数。 数据范围 $−10000≤n≤10000$ 输入样例： 1000.00 输出样例： 10.000000 算法设计 这题是收录的小数二分的经典例题，小数二分比起整数二分来说要简单许多。 其实整数二分的模板为什么要分成两个，就是因为对于区间划分的时候，有时候需要 $l+r»1$ 进行下取整，有时候又需要 $l+r+1»1$ 进行上取整，才能得到 $\\text{mid}$ 值，这里因为我们的区间不是一个数组，而是数轴范围，所以这里 $l + r » 1$ 就可以直接作为我们划分依据，而无需取整。 这里我还想谈谈误差。由于计算机的二进制无法精确表示很多小数，就比如 $0.1$ 在计算机内部就无法被精确表示出来，$0.1$ 的二进制近似表示为 $0.000110011001100110011…$（无限循环），由于计算机的存储空间有限，所以只能截断这个无限循环的小数，导致了误差。 所以当我们运行下面的程序，便可以清晰的看出来确实是有误差，只是编译器默认会对 $\\text{double}$ 进行格式化输出，只显示足够接近真实值的小数位，隐藏了实际内部存储的误差。但当我们加参数让他多显示些小数位时便暴露出来了。 double a = 0.1; printf(\"%f\\n\", a); printf(\"%.20f\\n\", a); // 编译器输出： // 0.100000 // 0.10000000000000000555 所以此题我们在求 $n$ 的三次方根时，也需要将误差考虑进去， 这里我们给出一般经验：如果题目要求保留小数点后 $k$ 位，我们就使用 $1\\times 10^{-(k+2)}$ 作为误差，下面我们给出证明： 我们假设实际结果为 $0.123456 4555555555$。 直接保留 $6$ 位小数：$0.123456$ 先精确到 $7$ 位小数：$0.1234565$，再保留六位小数：$0.123457$ 先精确到 $8$ 位小数：$0,12345646$，再保留六位小数：$0.123456$ 因此使用 $k+2$ 位作为误差，可以使得 $k + 1$ 位是较为精准的，这样就不会因为进位影响到我们要求的第 $k$ 位了（当然误差位数越多越好了）。 当然这里还有个小细节： 不要想当然的把 $r = x$, 因为有可能 $x =0.001$，但是它的三次方根却是 $0.1$，即结果是大于 $x$ 的，所以应该严谨点写成 $x = \\max(1, x)$ 。但是我们这里就直接简单点把 $r$ 设置为 $x$ 的理论最大值。 当然有时候精度不好把控，可以干脆采用循环固定次数的二分方法，也是一种相当不错的策略。这种方法得到的结果的精度通常比刚刚直接设定误差更高。 代码见下面。 完整 C++ 代码 设定误差版本： #include\u003ciostream\u003e using namespace std; int main() { double x; cin \u003e\u003e x; double l = -10000, r = 10000; while (r - l \u003e 1e-8) { double mid = (l + r) / 2; // 这里要用double if (mid * mid * mid \u003e= x) r = mid; else l = mid; } printf(\"%.6f\", l); } 循环固定次数版本 #include\u003ciostream\u003e using namespace std; int main() { double x; cin \u003e\u003e x; double l = -10000, r = 10000; for (int i = 0; i \u003c 100; i ++) // 固定循环100次 { double mid = (l + r) / 2; // 这里要用double if (mid * mid * mid \u003e= x) r = mid; else l = mid; } printf(\"%.6f\", l); } ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:2:2","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"高精度 ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:3:0","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"AcWing 791. 高精度加法 题目描述 ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:3:1","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"791. 高精度加法 给定两个正整数（不含前导 $0$ ），计算它们的和。 输入格式 共两行，每行包含一个整数。 输出格式 共一行，包含所求的和。 数据范围 $1≤$ 整数长度 $≤100000$ 输入样例： 12 23 输出样例： 35 算法设计 下面给出大数加法算法模板 string addStrings(string num1, string num2) { int i = num1.size() - 1, j = num2.size() - 1; string res; int add = 0; while (i \u003e= 0 || j \u003e= 0 || add) { int x = i \u003e= 0 ? num1[i] - '0' : 0; int y = j \u003e= 0 ? num2[j] - '0' : 0; res += '0' + (x + y + add) % 10; add = (x + y + add) / 10; i --, j --; } reverse(res.begin(), res.end()); return res; } 完整 C++ 代码 ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:3:2","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"AcWing 5900. 高精度乘法 题目描述 ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:3:3","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"5900. 高精度乘法 输入两个高精度正整数 $M$ 和 $N$。 求这两个高精度数的积。 输入格式 第一行包含高精度正整数 $M$。 第二行包含高精度正整数 $N$。 输出格式 输出这两个高精度数的积。 数据范围 $M$ 和 $N$ 均小于 $100$ 位。 输入样例： 36 3 输出样例： 108 算法设计 普通竖式 以num1 = $123$ , num2 = $456$ 为例：我们遍历 num2 每一位与 num1 进行相乘，将每一步的结果进行累加，在这个过程如果相乘或者相加的结果大于等于$10$ ，我们都要去满 $10$ 进位，如下图所示： 这样模拟普通竖式计算的方法时间复杂度为 $O(n(m+n))$，我们可以考虑优化版的竖式计算。 优化竖式 其实在相乘或者相加计算过程的每一位，我们可以考虑先不去满 $10$ 进位，等到计算完所有的相乘结果以后，最终将其加到一块，再去满$10$ 进位 ，最后的结果和普通竖式 一样，但却可以大大简化我们的模拟过程。(如下图所示) 关键点：$C[i+j] = A[i] \\times B[j]$ 由此时间复杂度降低为 $O(mn)$，算法模板如下： string multiply(string num1, string num2) { vector\u003cint\u003e a, b; int n = num1.size(), m = num2.size(); for (int i = n - 1; i \u003e= 0; i --) a.push_back(num1[i] - '0'); for (int i = m - 1; i \u003e= 0; i --) b.push_back(num2[i] - '0'); vector\u003cint\u003e c(n + m, 0); for (int i = 0; i \u003c n; i ++) { for (int j = 0; j \u003c m; j ++) { c[i + j] += a[i] * b[j]; } } int add = 0; string ans; for (int i = 0; i \u003c m + n || add; i ++) { int x = c[i] + add; add = x / 10; ans += '0' + x % 10; } reverse(ans.begin(), ans.end()); int idx = 0; while (ans[idx] == '0' \u0026\u0026 idx \u003c ans.size() - 1) idx ++; ans = ans.substr(idx, ans.size() - idx); return ans; } 完整 C++ 代码 ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:3:4","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"枚举 蒋炎岩语录： 枚举是万能的 枚举是我们定义问题的方式： 路径、生成树、排序、… 也是思考问题的出发点 枚举也是万万不能的 $n$ 个元素集合的子集有 $2^n$ 个… 在实际和竞赛中都需要更好的处理 ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:4:0","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"AcWing 92. 递归实现指数型枚举 题目描述 ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:4:1","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"92. 递归实现指数型枚举 从 $1∼n$ 这 $n$ 个整数中随机选取任意多个，输出所有可能的选择方案。 输入格式 输入一个整数 $n$。 输出格式 每行输出一种方案。 同一行内的数必须升序排列，相邻两个数用恰好 $1$ 个空格隔开。 对于没有选任何数的方案，输出空行。 本题有自定义校验器（SPJ），各行（不同方案）之间的顺序任意。 数据范围 $1≤n≤15$ 输入样例： 3 输出样例： 3 2 2 3 1 1 3 1 2 1 2 3 算法设计 所谓指数型枚举，其实就是对于每一个数都有选和不选两种情况，所以最终情况是 $2^n$ 种，所以叫他指数型。 这里其实用了一个第五章状态压缩 $\\text{DP}$ 中提到的二进制状态压缩的思想，将原本需要维护的一个 bool 数组优化成了一个二进制数。 完整 C++ 代码 #include \u003ciostream\u003e using namespace std; int n; void dfs(int u, int state) { if (u == n) { for (int k = 0; k \u003c n; k ++) if (state \u003e\u003e k \u0026 1) cout \u003c\u003c k + 1 \u003c\u003c \" \"; cout \u003c\u003c endl; return; } dfs(u + 1, state); // 不用第u个数 dfs(u + 1, state | (1 \u003c\u003c u)); // 用第u个数，就把第u个位置置成1 } int main() { cin \u003e\u003e n; dfs(0, 0); return 0; } ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:4:2","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"AcWing 93. 递归实现组合型枚举 题目描述 ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:4:3","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"93. 递归实现组合型枚举 从 $1∼n$ 这 $n$ 个整数中随机选出 $m$ 个，输出所有可能的选择方案。 输入格式 两个整数 $n,m$ ,在同一行用空格隔开。 输出格式 按照从小到大的顺序输出所有方案，每行 $1$ 个。 首先，同一行内的数升序排列，相邻两个数用一个空格隔开。 其次，对于两个不同的行，对应下标的数一一比较，字典序较小的排在前面（例如 1 3 5 7 排在 1 3 6 8 前面）。 数据范围 $n\u003e0,$ $0≤m≤n ,$ $n+(n−m)≤25$ 输入样例： 5 3 输出样例： 1 2 3 1 2 4 1 2 5 1 3 4 1 3 5 1 4 5 2 3 4 2 3 5 2 4 5 3 4 5 思考题：如果要求使用非递归方法，该怎么做呢？ 算法设计 组合型枚举的所有情况就包含在我们刚刚的指数型枚举的情况中，所以我们只需要在刚刚的指数型枚举的基础上加上剪枝操作即可。 当然还有非递归版本，也就是手动模拟递归栈。 就比如当第一轮 $\\text{dfs}$ 运行到第 $19$ 行dfs(u + 1, cnt + 1, state | (1 \u003c\u003c u))，那么系统会将当前当前的参数数和行号都压入栈中，然后再执行。 我们要做的其实就是手动写一个栈，每次将递归的参数压入栈，将刚刚的递归代码翻译成进栈操作即可。 完整 C++ 代码 递归版本代码： #include \u003ciostream\u003e using namespace std; int n, m; void dfs(int u, int cnt, int state) { if (cnt + n - u \u003c m) return; // 提前可行性剪枝：如果后续全选都不够m个，就可以提前退出了 if (cnt == m) { for (int k = 0; k \u003c n; k ++) if (state \u003e\u003e k \u0026 1) cout \u003c\u003c k + 1 \u003c\u003c \" \"; cout \u003c\u003c endl; return; } // 这里按照字典序来排，所以得换个顺序 dfs(u + 1, cnt + 1, state | (1 \u003c\u003c u)); // 用第u个数，就把第u个位置置成1 dfs(u + 1, cnt, state); // 不用第u个数 } int main() { cin \u003e\u003e n \u003e\u003e m; dfs(0, 0, 0); return 0; } 非递归版本代码： #include \u003ciostream\u003e #include \u003cstack\u003e using namespace std; int n, m; struct State { int pos, u, cnt, state; // pos：已经运行到的状态区域; u,cnt,state：递归参数 }; // void dfs(int u, int cnt, int state) // { // // 状态0区域： // if (cnt + n - u \u003c m) return; // if (cnt == m) // { // for (int k = 0; k \u003c n; k ++) // if (state \u003e\u003e k \u0026 1) // cout \u003c\u003c k + 1 \u003c\u003c \" \"; // cout \u003c\u003c endl; // return; // } // // 状态1区域： // dfs(u + 1, cnt + 1, state | (1 \u003c\u003c u)); // // 状态2区域： // dfs(u + 1, cnt, state); // } int main() { cin \u003e\u003e n \u003e\u003e m; stack\u003cState\u003e stk; // 模拟递归栈 stk.push({0, 0, 0, 0}); while (stk.size()) { auto cur = stk.top(); stk.pop(); switch (cur.pos) { case 0: // 如果对应区域0状态 // 把递归dfs里面区域1的代码翻译过来就可以了：return翻译成continue，变量改一下,递归调用变成进栈操作 if (cur.cnt + n - cur.u \u003c m) continue; if (cur.cnt == m) { for (int k = 0; k \u003c n; k ++) if (cur.state \u003e\u003e k \u0026 1) cout \u003c\u003c k + 1 \u003c\u003c \" \"; cout \u003c\u003c endl; continue; } stk.push({1, cur.u, cur.cnt, cur.state}); // 当前状态进栈 stk.push({0, cur.u + 1, cur.cnt + 1, cur.state | (1 \u003c\u003c cur.u)}); // dfs(u+1, cnt+1, state | (1 \u003c\u003c u)); continue; case 1: // 如果对应区域1状态 stk.push({2, cur.u, cur.cnt, cur.state}); // 当前状态进栈 stk.push({0, cur.u + 1, cur.cnt, cur.state}); // dfs(u+1, cnt, state); continue; case 2: // 如果对应区域2状态 continue; } } return 0; } ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:4:4","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"AcWing 94. 递归实现排列型枚举 题目描述 ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:4:5","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"94. 递归实现排列型枚举 把 $1∼n$ 这 $n$ 个整数排成一行后随机打乱顺序，输出所有可能的次序。 输入格式 一个整数 $n$。 输出格式 按照从小到大的顺序输出所有方案，每行 $1$ 个。 首先，同一行相邻两个数用一个空格隔开。 其次，对于两个不同的行，对应下标的数一一比较，字典序较小的排在前面。 数据范围 $1≤n≤9$ 输入样例： 3 输出样例： 1 2 3 1 3 2 2 1 3 2 3 1 3 1 2 3 2 1 算法设计 排列型枚举就不需要传入当前遍历到哪个数了，而是从 $0$ 开始继续遍历。 完整 C++ 代码 #include \u003ciostream\u003e #include \u003cvector\u003e using namespace std; int n; vector\u003cint\u003e ans; void dfs(int state) { if (ans.size() == n) { for (auto i : ans) cout \u003c\u003c i \u003c\u003c \" \"; cout \u003c\u003c endl; return; } for (int u = 0; u \u003c n; u ++) { if (!(state \u003e\u003e u \u0026 1)) { ans.push_back(u + 1); dfs(state | (1 \u003c\u003c u)); // 用第u个数，就把第u个位置置成1 ans.pop_back(); // 恢复现场 } } } int main() { cin \u003e\u003e n; dfs(0); return 0; } ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:4:6","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"前缀和 ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:5:0","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"AcWing 795. 前缀和 题目描述 输入一个长度为 $n$ 的整数序列。 接下来再输入 $m$ 个询问，每个询问输入一对 $l$, $r$。 对于每个询问，输出原序列中从第 $l$ 个数到第 $r$ 个数的和。 输入格式 第一行包含两个整数 $n$ 和 $m$。 第二行包含 $n$ 个整数，表示整数数列。 接下来 $m$ 行，每行包含两个整数 $l$ 和 $r$，表示一个询问的区间范围。 输出格式 共 $m$ 行，每行输出一个询问的结果。 数据范围 $1≤l≤r≤n$, $1≤n,m≤100000$, $−1000≤$ 数列中元素的值 $≤1000$ 输入样例： 5 3 2 1 3 6 4 1 2 1 3 2 4 输出样例： 3 6 10 算法设计 前缀和的思想用的挺多的,可以将多次的求一段连续区间和的时间复杂度从 $O(n^2)$ 优化到 $O(n)$，拓展题中添加了一道二维的前缀和，可以一块看看。 构造 $s_i=a_1+a_2+…+a_i$，通过提前预处理一个 $s$ 数组来存储累加和。 完整C++ 代码 #include \u003ciostream\u003e using namespace std; const int N = 100010; int n, m; int s[N]; int main() { cin \u003e\u003e n \u003e\u003e m; for (int i = 1; i \u003c= n; i++) { int a; cin \u003e\u003e a; s[i] = s[i - 1] + a; } while (m--) { int l, r; cin \u003e\u003e l \u003e\u003e r; cout \u003c\u003c s[r] - s[l - 1] \u003c\u003c endl; } return 0; } 拓展 ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:5:1","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"796. 子矩阵的和 输入一个 $n$ 行 $m$ 列的整数矩阵，再输入 $q$ 个询问，每个询问包含四个整数 $x1,y1,x2,y2$，表示一个子矩阵的左上角坐标和右下角坐标。 对于每个询问输出子矩阵中所有数的和。 输入格式 第一行包含三个整数 $n，m，q$。 接下来 $n$ 行，每行包含 $m$ 个整数，表示整数矩阵。 接下来 $q$ 行，每行包含四个整数 $x1,y1,x2,y2$，表示一组询问。 输出格式 共 $q$ 行，每行输出一个询问的结果。 数据范围 $1≤n,m≤1000$, $1≤q≤200000$, $1≤x1≤x2≤n$, $1≤y1≤y2≤m$, $−1000≤$矩阵内元素的值$≤1000$ 输入样例： 3 4 3 1 7 2 4 3 6 2 8 2 1 2 3 1 1 2 2 2 1 3 4 1 3 3 4 输出样例： 17 27 21 算法剖析 这是一道经典的二维前缀和模板题，这里的最终表达式有点像概率论里面那个二维联合分布函数的味道。 完整C++ 代码 #include \u003ciostream\u003e using namespace std; const int N = 1010; int n, m, q; int s[N][N]; int main() { cin \u003e\u003e n \u003e\u003e m \u003e\u003e q; for (int i = 1; i \u003c= n; i++) { for (int j = 1; j \u003c= m; j++) { int w; cin \u003e\u003e w; s[i][j] = s[i - 1][j] + (s[i][j - 1] - s[i - 1][j - 1]) + w; } } while (q--) { int x1, y1, x2, y2; cin \u003e\u003e x1 \u003e\u003e y1 \u003e\u003e x2 \u003e\u003e y2; cout \u003c\u003c s[x2][y2] - s[x1 - 1][y2] - s[x2][y1 - 1] + s[x1 - 1][y1 - 1] \u003c\u003c endl; } return 0; } ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:5:2","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"快速幂 ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:6:0","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"AcWing 875. 快速幂 题目描述 ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:6:1","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"875. 快速幂 给定 nn 组 ai,bi,piai,bi,pi，对于每组数据，求出 abiimodpiaibimodpi 的值。 输入格式 第一行包含整数 nn。 接下来 nn 行，每行包含三个整数 ai,bi,piai,bi,pi。 输出格式 对于每组数据，输出一个结果，表示 abiimodpiaibimodpi 的值。 每个结果占一行。 数据范围 1≤n≤1000001≤n≤100000, 1≤ai,bi,pi≤2×1091≤ai,bi,pi≤2×109 输入样例： 2 3 2 5 4 3 9 输出样例： 4 1 ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:6:2","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"差分 ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:7:0","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"AcWing 797. 差分 题目描述 有输入一个长度为 $n$ 的整数序列。 接下来输入 $m$ 个操作，每个操作包含三个整数 $l,r,c$，表示将序列中 $[l,r]$ 之间的每个数加上 $c$。 请你输出进行完所有操作后的序列。 输入格式 第一行包含两个整数 $n$ 和 $m$。 第二行包含 $n$ 个整数，表示整数序列。 接下来 $m$ 行，每行包含三个整数 $l，r，c$，表示一个操作。 输出格式 共一行，包含 $n$ 个整数，表示最终序列。 数据范围 $1≤n,m≤100000$, $1≤l≤r≤n$, $−1000≤c≤1000$, $−1000≤\\ $整数序列中元素的值$\\ ≤1000$ 输入样例： 6 3 1 2 2 1 2 1 1 3 1 3 5 1 1 6 1 输出样例： 3 4 5 3 4 2 算法设计 差分其实可以看作是前缀和操作的逆运算。 通过构造 $B$ 数组：使得：$a_i = b_1+b_2+…+b_i$，那么我们对 $B$ 数组进行一次前缀和操作就可以得到 $a_i$。那么就可以在 $O(n)$ 的时间由 $B$ 数组反推出 $A$ 数组。 $B$ 数组有一个好处，可以在 $O(1)$ 的时间里将 $[l, r]$ 中每一个数加上 $c$ ：通过令 $b_l + c,b_{r+1} - c$ 即可。 朴素解法 C++ 代码 由$\\begin{cases} a_i = b_1+b_2+…+b_i\\ a_{i-1} = b_1+b_2+…+b_{i-1} \\end{cases}$$\\Rightarrow b_i = a_{i}-a_{i-1}\\ \\ \\ \\ \\ (1)$ 直接利用公式 $(1)$ $b_i = a_{i}-a_{i-1}$ 来初始化 $B$ 数组。 #include \u003ciostream\u003e using namespace std; const int N = 100010; int n, m; int a[N], b[N], s[N]; int main() { cin \u003e\u003e n \u003e\u003e m; for (int i = 1;i \u003c= n; i++) { cin \u003e\u003e a[i]; b[i] = a[i] - a[i - 1]; } while (m--) { int l, r, c; cin \u003e\u003e l \u003e\u003e r \u003e\u003e c; b[l] += c; b[r + 1] -= c; } for (int i = 1; i \u003c= n; i++) { s[i] = s[i - 1] + b[i]; cout \u003c\u003c s[i] \u003c\u003c \" \"; } return 0; } 优美解法 C++ 代码 一开始 $A, B$ 数组初值都为0，已经满足差分定义了。 此时每次读取后更新A数组的值 $a_i$，其实就可以看作是对 $A$ 数组 $[i, i]$ 区间上的每一个数加上 $a_i$, 所以直接复用后面的差分代码即可完成对 $B$ 数组的初始化。 #include \u003ciostream\u003e using namespace std; const int N = 100010; int n, m; int a, b[N]; void insert(int l, int r, int c) { b[l] += c; b[r + 1] -= c; } int main() { cin \u003e\u003e n \u003e\u003e m; for (int i = 1;i \u003c= n; i++) { cin \u003e\u003e a; insert(i, i, a); // 点金之笔，代码复用 } while (m--) { int l, r, c; cin \u003e\u003e l \u003e\u003e r \u003e\u003e c; insert(l, r, c); } for (int i = 1; i \u003c= n; i++) { b[i] += b[i - 1]; // 直接偷懒不再用s数组来存前缀和了 cout \u003c\u003c b[i] \u003c\u003c \" \"; } return 0; } ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:7:1","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"双指针 ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:8:0","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"AcWing 800. 数组元素的目标和 题目描述 ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:8:1","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"800. 数组元素的目标和 给定两个升序排序的有序数组 $A$ 和 $B$，以及一个目标值 $x$。 数组下标从 $0$ 开始。 请你求出满足 $A[i]+B[j]=x$ 的数对 $(i,j)$。 数据保证有唯一解。 输入格式 第一行包含三个整数 $n,m,x$，分别表示 $A$ 的长度，$B$ 的长度以及目标值 $x$。 第二行包含 $n$ 个整数，表示数组 $A$。 第三行包含 $m$ 个整数，表示数组 $B$。 输出格式 共一行，包含两个整数 $i$ 和 $j$。 数据范围 数组长度不超过 $10^5$。 同一数组内元素各不相同。 $1≤$数组元素$≤10^9$ 输入样例： 4 5 6 1 2 4 7 3 4 6 8 9 输出样例： 1 1 算法设计 双指针是算法中降低时间复杂度的一个常用方法，可以把暴力解法的 $O(n^2)$ 降低至 $O(n)$。 其实它主要是利用每一次判断可以将 $n$ 种可能状态排除。 常用的双指针法有一下几类： 左右指针：两个指针，相向而走，中间相遇。 快慢指针：两个指针，有快有慢，同向而行。 灵活运用：两个指针，灵活运用，伺机而动。 对于本题，状态空间如图所示，有 $mn$ 个 $(i,j)$ 的状态： 由于 $A,B$ 都是升序排列的数组，所以有以下结论： 若 $A_i+B_j\u003ex$，显然 $A_{i+1}+B_j\u003ex$，所以对应于上图第 $j$ 列的状态可以被全部排除。 若 $A_i+B_j\u003cx$，显然 $A_{i}+B_{j-1}\u003cx$，所以对应于上图第 $i$ 行的状态也可以被全部排除。 由此可知最多进行 $n+m$ 次操作即可遍历所有的状态空间情况。 完整 C++ 代码 #include \u003ciostream\u003e using namespace std; const int N = 100010; int n, m, x; int a[N], b[N]; int main() { cin \u003e\u003e n \u003e\u003e m \u003e\u003e x; for (int i = 0; i \u003c n; i ++) cin \u003e\u003e a[i]; for (int i = 0; i \u003c m; i ++) cin \u003e\u003e b[i]; for (int i = 0, j = m - 1; ; ) { if (a[i] + b[j] \u003e x) j --; else if (a[i] + b[j] \u003c x) i ++; else { cout \u003c\u003c i \u003c\u003c ' ' \u003c\u003c j \u003c\u003c endl; return 0; } } } ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:8:2","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"滑动窗口 ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:9:0","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"LeetCode 1456. 定长子串中元音的最大数目 题目描述 ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:9:1","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"LeetCode 1456. 定长子串中元音的最大数目 给你字符串 s 和整数 k 。 请返回字符串 s 中长度为 k 的单个子字符串中可能包含的最大元音字母数。 英文中的 元音字母 为（a, e, i, o, u）。 示例 1： 输入：s = \"abciiidef\", k = 3 输出：3 解释：子字符串 \"iii\" 包含 3 个元音字母。 示例 2： 输入：s = \"aeiou\", k = 2 输出：2 解释：任意长度为 2 的子字符串都包含 2 个元音字母。 示例 3： 输入：s = \"leetcode\", k = 3 输出：2 解释：\"lee\"、\"eet\" 和 \"ode\" 都包含 2 个元音字母。 示例 4： 输入：s = \"rhythms\", k = 4 输出：0 解释：字符串 s 中不含任何元音字母。 示例 5： 输入：s = \"tryhard\", k = 4 输出：1 提示： $1 \u003c= s.length \u003c= 10^5$ $s$ 由小写英文字母组成 $1 \u003c= k \u003c= s.length$ 算法设计 ​ 这是一道经典的定长滑动窗口模板题，下面给出我对灵神的定长滑动窗口模板的修改版本，让他和不定长滑窗写法类似： //外层循环扩展右边界，内层循环扩展左边界 for (int l = 0, r = 0 ; r \u003c n ; r ++) { // 1. 先更新右指针 // 2. 窗口大小不足 k 跳过 if (r \u003c k - 1) continue; // 3. 区间[left,right]符合题意，统计相关信息 // 4. 调整左窗口 // 5. 拓展左边界 } 完整 C++ 代码 class Solution { public: bool check(char c) { if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') return true; return false; } int maxVowels(string s, int k) { int n = s.size(); int mx = 0; int cnt = 0; for (int l = 0, r = 0; r \u003c n; r ++) { // 右端点进入窗口 if (check(s[r])) cnt ++; // 窗口大小不足 k 跳过 if (r \u003c k - 1) continue; // 更新答案 mx = max(mx, cnt); // 左端点离开窗口 if (check(s[l])) cnt --; l ++; } return mx; } }; ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:9:2","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"LeetCode 3. 无重复字符的最长子串 题目描述 ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:9:3","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"3. 无重复字符的最长子串 给定一个字符串 $s$ ，请你找出其中不含有重复字符的 最长子串 的长度。 示例 1: 输入: s = \"abcabcbb\" 输出: 3 解释: 因为无重复字符的最长子串是 \"abc\"，所以其长度为 3。 示例 2: 输入: s = \"bbbbb\" 输出: 1 解释: 因为无重复字符的最长子串是 \"b\"，所以其长度为 1。 示例 3: 输入: s = \"pwwkew\" 输出: 3 解释: 因为无重复字符的最长子串是 \"wke\"，所以其长度为 3。 请注意，你的答案必须是 子串 的长度，\"pwke\" 是一个子序列，不是子串。 提示： $0 \u003c= s.length \u003c= 5 \\times 10^4$ $s$ 由英文字母、数字、符号和空格组成 算法设计 我的精神病一触即发 发布于 江苏(编辑过) 2024.07.31 我希望这种滑动窗口的模板题，你们不要再写的五花八门了。这是最简单的模板，拿走不谢。 模板： 注：2025.01.08 已经由我根据灵神题解更新了一下这个兄弟的模板，感觉更符合直觉写法 //外层循环扩展右边界，内层循环扩展左边界 for (int l = 0, r = 0 ; r \u003c n ; r ++) { // 1. 先更新右指针 while (l \u003c= r \u0026\u0026 check()) // 调整左指针 { // 2. 扩展左边界 } // 3. 区间[left,right]符合题意，统计相关信息 } 完整 C++ 代码 class Solution { public: int lengthOfLongestSubstring(string s) { unordered_map\u003cchar, int\u003e hash_c; int ans = 0; for (int l = 0, r = 0; r \u003c s.size(); r ++) { hash_c[s[r]] ++; // 先更新右指针 while (hash_c[s[r]] \u003e 1) // 调整左指针 hash_c[s[l]] --, l ++; ans = max(ans, r - l + 1); // 区间符合题意，统计相关信息 } return ans; } }; ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:9:4","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"位运算 ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:10:0","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"AcWing 801. 二进制中1的个数 题目描述 ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:10:1","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"801. 二进制中1的个数 给定一个长度为 $n$ 的数列，请你求出数列中每个数的二进制表示中 $1$ 的个数。 输入格式 第一行包含整数 $n$。 第二行包含 $n$ 个整数，表示整个数列。 输出格式 共一行，包含 $n$ 个整数，其中的第 $i$ 个数表示数列中的第 $i$ 个数的二进制表示中 $1$ 的个数。 数据范围 $1≤n≤100000,$ $0≤$数列中元素的值$≤10^9$ 输入样例： 5 1 2 3 4 5 输出样例： 1 1 2 1 2 算法设计 下面我给出下面常用的位运算代码模板： 求 $n$ 的第 $k$ 位数字： n \u003e\u003e k \u0026 1 $\\text{lowbit}$ 算法：其实是树状数组的基本操作，返回 $n$ 的最低位 $1$ 及其后面所有的 $0$ 构成的子串，如 $101000$ 返回 $1000$：lowbit(n) = n \u0026 (-n) = n \u0026 (~n + 1) 下面我们对 $\\text{lowbit}$ 运算给出证明： ​ 设 $n\u003e0$，$n$ 的第 $k$ 位为 $1$, $0∼k-1$ 位为 $0$。我们首先实现 $n=∼n$，也即将 $n$ 按位取反，此时 $n$ 的第 $k$ 位为 $0$, $0∼k-1$ 位为 $1$。我们再令 $n=n+1$，这时因为进位，第 $k$ 位变为 $1$, $0∼k-1$ 位都是 $0$，第 $k+1$ 到最高位都和原来的相反，所以此时再进行按位 $\u0026$，所得到的结果仅有第 $k$ 位为 $1$，其余位都是 $0$。 ​ 又由于补码定义：~n = -1 - n，也即-n = ~n + 1。 ​ 综上所述，证明完毕。 所以我们就能直接利用 $\\text{lowbit}$ 算法，每次让 $n - lowbit(n)$ 即可，$n$ 中 $1$ 的个数其实就是多少次能让 $n$ 变成 $0$ 。 完整 C++ 代码 #include \u003ciostream\u003e using namespace std; const int N = 100000; int lowbit(int x) // 返回最低位1及其后面所有的0构成的子串 { return x \u0026 -x; } int main() { int n; cin \u003e\u003e n; while (n --) { int x; cin \u003e\u003e x; int cnt = 0; while (x) cnt ++, x -= lowbit(x); cout \u003c\u003c cnt \u003c\u003c \" \"; } return 0; } ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:10:2","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"离散化 ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:11:0","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"区间合并 ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:12:0","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"AcWing 803. 区间合并 题目描述 ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:12:1","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"803. 区间合并 给定 $n$ 个区间 $[l_i,r_i]$，要求合并所有有交集的区间。 注意如果在端点处相交，也算有交集。 输出合并完成后的区间个数。 例如：$[1,3]$ 和 $[2,6]$ 可以合并为一个区间 $[1,6]$。 输入格式 第一行包含整数 $n$。 接下来 $n$ 行，每行包含两个整数 $l$ 和 $r$。 输出格式 共一行，包含一个整数，表示合并区间完成后的区间个数。 数据范围 $1≤n≤100000$, $−10^9≤l_i≤r_i≤10^9$ 输入样例： 5 1 2 2 4 5 6 7 8 7 9 输出样例： 3 算法设计 这题还是很基础的，算法就不再赘述了。 完整 C++ 代码 #include \u003ciostream\u003e #include \u003ccstring\u003e #include \u003calgorithm\u003e using namespace std; typedef pair\u003cint, int\u003e PII; const int N = 100010, INF = 0x3f3f3f3f; PII a[N]; int ans; int main() { int n; cin \u003e\u003e n; for (int i = 0; i \u003c n; i ++) cin \u003e\u003e a[i].first \u003e\u003e a[i].second; sort(a, a + n); int l = -INF, r = -INF; for (int i = 0; i \u003c n; i ++) { if (a[i].first \u003e r) { ans ++; l = a[i].first; r = a[i].second; } else r = max(r, a[i].second); } cout \u003c\u003c ans \u003c\u003c endl; return 0; } ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:12:2","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"构造 一种思维题，很像数学 ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:13:0","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"打表 第二章 数据结构 ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:14:0","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"滚动数组 ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:15:0","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"AcWing21. 斐波那契数列 题目描述 输入一个整数 $n$ ，求斐波那契数列的第 $n$ 项。 假定从 $0$ 开始，第 $0$ 项为 $0$。 输入格式 共一行，包含两个整数 $n$ 和 $k$ 。 输出格式 共一行，表示斐波那契数列的第 $n$ 项。 数据范围 $0 \\le n \\le39$, 输入样例： 36 输出样例： 14930352 算法设计 如果只需要使用到相邻 $n$ 个状态的值，那么只需要开 $n$ 层数组即可，其中状态使用 $f(i\\ %\\ n)$ 来表示即可 完整 C++ 代码 #include \u003ciostream\u003e using namespace std; int dp[3]; int n; int main() { cin \u003e\u003e n; dp[1] = 1; for (int i = 2; i \u003c= n; i++) { dp[i % 3] = dp[(i - 1) % 3] + dp[(i - 2) % 3]; } cout \u003c\u003c dp[n % 3] \u003c\u003c endl; return 0; } ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:15:1","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"单链表 ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:16:0","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"AcWing 826. 单链表 题目描述 ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:16:1","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"826. 单链表 实现一个单链表，链表初始为空，支持三种操作： 向链表头插入一个数； 删除第 $k$ 个插入的数后面的一个数； 在第 $k$ 个插入的数后插入一个数。 现在要对该链表进行 $M$ 次操作，进行完所有操作后，从头到尾输出整个链表。 注意:题目中第 $k$ 个插入的数并不是指当前链表的第 $k$ 个数。例如操作过程中一共插入了 $n$ 个数，则按照插入的时间顺序，这 $n$ 个数依次为：第 $1$ 个插入的数，第 $2$ 个插入的数，…第 $n$ 个插入的数。 输入格式 第一行包含整数 $M$，表示操作次数。 接下来 $M$ 行，每行包含一个操作命令，操作命令可能为以下几种： H x，表示向链表头插入一个数 $x$。 D k，表示删除第 $k$ 个插入的数后面的数（当 $k$ 为 $0$ 时，表示删除头结点）。 I k x，表示在第 $k$ 个插入的数后面插入一个数 $x$（此操作中 $k$ 均大于 $0$）。 输出格式 共一行，将整个链表从头到尾输出。 数据范围 $1≤M≤100000$ 所有操作保证合法。 输入样例： 10 H 9 I 1 1 D 1 D 0 H 6 I 3 6 I 4 5 I 4 5 I 3 4 D 6 输出样例： 6 4 6 5 算法设计 这里引用单链表这个知识点肯定不是想直接用结构体定义的单链表。 因为使用结构体的方法，每次都需要 $\\text{new}$ 一个新的结构体，这个操作是非常耗时的，对于 $\\text{ACM}$ 这种每次都要操作 $100000$ 级别数据量的情况下是非常慢的。因为我们需要使用数组来模拟链表。 首先我们来明确模板中各个数组含义： $\\text{head}$：头节点。 $e_i$：节点 $i$ 的值。 $ne_i$：节点 $i$ 的 $\\text{next}$ 指针指向的节点。 $\\text{idx}$：存储当前已经用到了哪个点。 image-20241214233109357 完整 C++ 代码 #include \u003ciostream\u003e using namespace std; const int N = 100010; int m; int head, e[N], ne[N], idx; // 初始化 void init() { head = -1; // 下标-1表示为空 idx = 0; } // 头插法插入 void add_to_head(int x) { e[idx] = x, ne[idx] = head, head = idx ++; } // 在下标为 k 的数后面插入一个数 x void add(int k, int x) { e[idx] = x, ne[idx] = ne[k], ne[k] = idx ++; } // 在下标为 k 的数后面删掉一个数 void remove(int k) { ne[k] = ne[ne[k]]; } int main() { cin \u003e\u003e m; init(); while (m-- ) { char op; cin \u003e\u003e op; if (op == 'H') { int x; cin \u003e\u003e x; add_to_head(x); } else if (op == 'D') { int k; cin \u003e\u003e k; if (!k) head = ne[head]; remove(k - 1); } else { int k, x; cin \u003e\u003e k \u003e\u003e x; add(k - 1, x); } } for (int i = head; i != -1; i = ne[i]) cout \u003c\u003c e[i] \u003c\u003c \" \"; // 标准的遍历方式 return 0; } ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:16:2","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"单调栈 ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:17:0","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"AcWing 830. 单调栈 题目描述 ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:17:1","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"830. 单调栈 给定一个长度为 $N$ 的整数数列，输出每个数左边第一个比它小的数，如果不存在则输出 $\\text{−}1$。 输入格式 第一行包含整数 $N$，表示数列长度。 第二行包含 $N$ 个整数，表示整数数列。 输出格式 共一行，包含 $N$ 个整数，其中第 $i$ 个数表示第 $i$ 个数的左边第一个比它小的数，如果不存在则输出 $−1$。 数据范围 $1≤N≤10^5$ $1≤$数列中元素$≤10^9$ 输入样例： 5 3 4 2 7 5 输出样例： -1 3 -1 2 2 算法设计 这道题就是收录的就算单调栈的经典模板，单调栈一般只会用来解决这种求左边或者右边第一个比它大或小的数。 分析方法还是先思考暴力解法：用一个栈把所有数都存下来。 但是这种时间复杂度是 $O(n^2)$，太暴力了。 下面分析如何优化，也就是思考哪些状态其实不用存储，比如对于输入样例中的 $3,4,2$，我们记下一个数是 $a$： 若 $a \u003e= 2$，显然 $2$ 就是我们要找的值。 若 $a \u003c2$，此时 $3,4$ 显然也不是我们要的值。 显然对于 $3,4$ 来说，只要 $2$ 存在的一天，$3,4$ 也就永无出头之日。因此只需要往栈中压入 $2$ 即可。 对于上面的例子我们进行数学抽象，对于数列中的 $a_i$ 和 $a_{i+1}$，若 $a_i\u003e=a_{i+1}$ 我们只需要存一个 $a_{i+1}$ 即可，最终构成的栈一定是一个严格单调递增的栈，所以我们叫它单调栈。 完整 C++ 代码 #include \u003ciostream\u003e #include \u003ccstring\u003e #include \u003calgorithm\u003e #include \u003cstack\u003e using namespace std; const int N = 100010; int a[N], s[N]; int main() { int n; cin \u003e\u003e n; for (int i = 0; i \u003c n; i ++) cin \u003e\u003e a[i]; vector\u003cint\u003e left(n, -1); stack\u003cint\u003e stk; for (int i = 0; i \u003c n; i ++) { while (!stk.empty() \u0026\u0026 a[i] \u003c= a[stk.top()]) stk.pop(); // 因为需要维护一个严格单调递增的栈 if (!stk.empty()) left[i] = stk.top(); // 如果栈没空说明有 stk.push(i); } for (int i = 0; i \u003c n; i ++) { if (left[i] == -1) cout \u003c\u003c -1 \u003c\u003c ' '; else cout \u003c\u003c a[left[i]] \u003c\u003c ' '; } return 0; } ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:17:2","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"单调队列 ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:18:0","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"AcWing 154. 滑动窗口 题目描述 ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:18:1","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"154. 滑动窗口 给定一个大小为 $n≤10^6$ 的数组。 有一个大小为 $k$ 的滑动窗口，它从数组的最左边移动到最右边。 你只能在窗口中看到 $k$ 个数字。 每次滑动窗口向右移动一个位置。 以下是一个例子： 该数组为 [1 3 -1 -3 5 3 6 7]，$k$ 为 $3$。 窗口位置 最小值 最大值 [1 3 -1] -3 5 3 6 7 -1 3 1 [3 -1 -3] 5 3 6 7 -3 3 1 3 [-1 -3 5] 3 6 7 -3 5 1 3 -1 [-3 5 3] 6 7 -3 5 1 3 -1 -3 [5 3 6] 7 3 6 1 3 -1 -3 5 [3 6 7] 3 7 你的任务是确定滑动窗口位于每个位置时，窗口中的最大值和最小值。 输入格式 输入包含两行。 第一行包含两个整数 $n$ 和 $k$，分别代表数组长度和滑动窗口的长度。 第二行有 $n$ 个整数，代表数组的具体数值。 同行数据之间用空格隔开。 输出格式 输出包含两个。 第一行输出，从左至右，每个位置滑动窗口中的最小值。 第二行输出，从左至右，每个位置滑动窗口中的最大值。 输入样例： 8 3 1 3 -1 -3 5 3 6 7 输出样例： -1 -3 -3 -3 3 3 3 3 5 5 6 7 算法设计 单调队列一般只用来求解一段连续区间内的最大最小值。 我们来分析输入样例的第一个区间 $[1,3,\\text{-}1], \\text{-}3, 5, 3 ,6, 7$： 如果我们要求的是最小值，如果按照暴力做法，需要将 $1,3,\\text{-}1$ 全都都入队列，但是仔细分析就可以发现，显然 $\\text{-}1$ 的出栈时间比 $1,3$ 更晚，还比 $1,3$ 更小，只要 $\\text{-}1$ 在的一天，$1,3$ 就没有出头之日，所以只需要记录 $\\text{-}1$ 一个数就可以将 $1,3,\\text{-}1$ 所有情况给囊括了。 所以可以更进一步推导出：求最小值我们构造出的队列永远是严格单调递增的，所以叫它单调队列。 如果滑动我们的窗口，进入窗口的元素是 $a$，我们假设队列元素分别为 $q_0,q_1,…q_j$： 若 $a \\le q_j$，此时不满足队列严格单调递增，我们需要先将所有 $q_j \\ge a$ 的元素出队，直到找到一个 $i$ ，使得 $q_i\u003ca$，我们再将元素 $a$ 入队作为新的队尾。 若 $a\u003eq_j$，直接将元素 $a$ 入队作为新的队尾。 每次滑动后，队列的队头元素就是我们要求的每个区间的最小值。 代码模板如下： // 存储递减序列 deque\u003cint\u003e que; for (int i = 0; i \u003c n; i ++) { // 1.构造递减序列 while (!que.empty() \u0026\u0026 nums[i] \u003e= nums[que.back()]) que.pop_back(); // 2.入队 que.push_back(i); // 3.记录答案 if (i \u003e= k-1) ans.push_back(nums[que.front()]); // 4.判断队首有没有出队 if (que.front() \u003c= i-k+1) que.pop_front(); } 同理可以求最大值，这里我们就不再赘述。 完整 C++ 代码 #include \u003ciostream\u003e using namespace std; const int N = 1000010; int a[N], q[N]; int main() { int n, k; cin \u003e\u003e n \u003e\u003e k; for (int i = 0; i \u003c n; i++) cin \u003e\u003e a[i]; int hh = 0, tt = -1; for (int i = 0; i \u003c n; i++) { if (hh \u003c= tt \u0026\u0026 i - k == q[hh]) hh++; // 首先判断有没有要出队的 while (hh \u003c= tt \u0026\u0026 a[i] \u003c= a[q[tt]]) tt--; // 构造递增序列 q[++ tt] = i; // 这里我们存的是下标，因为上面要判断有没有要出队的 if (i \u003e= k - 1) cout \u003c\u003c a[q[hh]] \u003c\u003c \" \"; } cout \u003c\u003c endl; hh = 0, tt = -1; for (int i = 0; i \u003c n; i++) { if (hh \u003c= tt \u0026\u0026 i - k == q[hh]) hh++; while (hh \u003c= tt \u0026\u0026 a[i] \u003e= a[q[tt]]) tt--; // 求最大值只有这里和求最小值不一样 q[++ tt] = i; if (i \u003e= k - 1) cout \u003c\u003c a[q[hh]] \u003c\u003c \" \"; } return 0; } ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:18:2","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"KMP KMP：一个人能走的多远不在于他在顺境时能走的多快，而在于他在逆境时多久能找到曾经的自己 ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:19:0","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"AcWing 831. KMP字符串 题目描述 给定一个字符串 $S$，以及一个模式串 $P$，所有字符串中只包含大小写英文字母以及阿拉伯数字。 模式串 $P$ 在字符串 $S$ 中多次作为子串出现。 求出模式串 $P$ 在字符串 $S$ 中所有出现的位置的起始下标。 输入格式 第一行输入整数 $N$，表示模式串 $P$ 的长度。 第二行输入字符串 $P$。 第三行输入整数 $M$，表示字符串 $S$ 的长度。 第四行输入字符串 $S$。 输出格式 共一行，输出所有出现位置的起始下标（下标从 $0$ 开始计数），整数之间用空格隔开。 数据范围 $ 1≤N≤10^5 $ $ 1≤M≤10^6 $ 输入样例： 3 aba 5 ababa 输出样例： 0 2 算法设计 $next[i]本质:模式串前i个字符的最长的一对相等的前后缀size(＝该前缀末端index)[下标从1开始]$ $如$:\"$abab$\", $size$=$2$ $每次循环开始的时候,j都=ne[i - 1]，下面分两种情况来讨论：$ $①.if;;p_{i}=p_{j+1}$ $;;;;;;;;;; ne[i] \\gets ne[i - 1] + 1$ $②.if;;p_{i} \\ne p_{j+1}$ $;;;;;;;;;; j \\gets ne[j],再重新开始判断if;(p_{i}=p_{j+1})$ // 求next数组过程:其实就是求最大前后缀长度，通过仿造下面KMP匹配的过程来求,可以将暴力求的o(n^2)复杂度降至o(n) for (int i = 2, j = 0; i \u003c= n; i++) // 注意这里i得从2开始,因为默认ne[1]=0,如果这里i从1开始,很明显会导致ne[1]=1,最终代码会出现TLE { while (j != 0 \u0026\u0026 p[i] != p[j + 1]) j = ne[j]; // 只要j没有退回起点,并且p[i]和p[j+1]不匹配,就可以通过next数组更新j if (p[i] == p[j + 1]) j++; // 如果最终p[i]和p[j+1]相等,那么最长前后缀size就可以+1 ne[i] = j; // 最后更新一下ne[i] } $每一次将字符串的s[i]和模式串的p[j + 1]进行匹配$ // KMP匹配过程:将s[i]与p[j + 1]进行匹配[当然这里为什么用j+1就说来话长了,毕竟当不匹配的时候是要对该下标前面的进行转移，所以与其用j-1，不如用j+1也就方便不越界了] for (int i = 1, j = 0; i \u003c= m; i++) { while (j != 0 \u0026\u0026 s[i] != p[j + 1]) j = ne[j]; // 只要j没有退回起点,并且s[i]和p[j+1]不匹配,就可以通过next数组更新j if (s[i] == p[j + 1]) j++; // 因为上面的循环结束有两种情况，1.j退回起点退无可退了，2.s[i]和p[j+1]终于匹配上了 if (j == n) { cout \u003c\u003c i - n \u003c\u003c \" \"; // 匹配成功,这里是根据题目要求的输出所有出现位置的起始下标（下标从0开始计数） j = ne[j]; // 此时依旧使用next数组来更新使得省去已知匹配的前后缀 } } $ \\text{KMP} 算法可以视作状态机模型:基于字符串p的\\text{KMP}自动机接受且仅接受以p为后缀的字符串，其接受状态为|p|。 $ $转移函数:$ $$ne(i, c) = \\begin{cases} i + 1, \u0026 \\text{if } p[i+1] = c \\ 0, \u0026 \\text{if } p[1] \\neq c \\land i = 0 \\ ne(\\pi(i), c), \u0026 \\text{if } p[i+1] \\neq c \\land i \u003e 0 \\end{cases}$$ 时间复杂度 $O(n+m)$ 完整 C++ 代码 #include \u003ciostream\u003e #include \u003ccstring\u003e using namespace std; const int N = 100010, M = 1000010; char p[N], s[M]; // pattern:模式串 int ne[N]; // next数组 int main() { int n, m; cin \u003e\u003e n \u003e\u003e p + 1 \u003e\u003e m \u003e\u003e s + 1; // 求next数组过程:其实就是求最大前后缀长度，通过仿造下面KMP匹配的过程来求,可以将暴力求的o(n^2)复杂度降至o(n) for (int i = 2, j = 0; i \u003c= n; i++) // 注意这里i得从2开始,因为默认ne[1]=0,如果这里i从1开始,很明显会导致ne[1]=1,最终代码会出现TLE { while (j != 0 \u0026\u0026 p[i] != p[j + 1]) j = ne[j]; // 只要j没有退回起点,并且p[i]和p[j+1]不匹配,就可以通过next数组更新j if (p[i] == p[j + 1]) j++; // 如果最终p[i]和p[j+1]相等,那么最长前后缀size就可以+1 ne[i] = j; // 最后更新一下ne[i] } // KMP匹配过程:将s[i]与p[j + 1]进行匹配[当然这里为什么用j+1就说来话长了,毕竟当不匹配的时候是要对该下标前面的进行转移，所以与其用j-1，不如用j+1也就方便不越界了] for (int i = 1, j = 0; i \u003c= m; i++) { while (j != 0 \u0026\u0026 s[i] != p[j + 1]) j = ne[j]; // 只要j没有退回起点,并且s[i]和p[j+1]不匹配,就可以通过next数组更新j if (s[i] == p[j + 1]) j++; // 因为上面的循环结束有两种情况，1.j退回起点退无可退了，2.s[i]和p[j+1]终于匹配上了 if (j == n) { cout \u003c\u003c i - n \u003c\u003c \" \"; // 匹配成功,这里是根据题目要求的输出所有出现位置的起始下标（下标从0开始计数） j = ne[j]; // 此时依旧使用next数组来更新使得省去已知匹配的前后缀 } } } ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:19:1","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"字典树 ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:20:0","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"AcWing 835. Trie字符串统计 题目描述 ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:20:1","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"835. Trie字符串统计 维护一个字符串集合，支持两种操作： I x 向集合中插入一个字符串 $x$； Q x 询问一个字符串在集合中出现了多少次。 共有 $N$ 个操作，所有输入的字符串总长度不超过 $10^5$，字符串仅包含小写英文字母。 输入格式 第一行包含整数 $N$，表示操作数。 接下来 $N$ 行，每行包含一个操作指令，指令为 I x 或 Q x 中的一种。 输出格式 对于每个询问指令 Q x，都要输出一个整数作为结果，表示 $x$ 在集合中出现的次数。 每个结果占一行。 数据范围 $1≤N≤2\\times 10^4$ 输入样例： 5 I abc Q abc Q ab I ab Q ab 输出样例： 1 0 1 算法设计 突然灵光一闪，好像本题给人一种 $\\text{Trie}$ 能做到的 $\\text{hash}$ 好像也能做到，但是其实 $\\text{Trie}$ 更宝贵的是,它存储了一个前缀匹配，比如在需要做到查询前缀为XXX的所有字符串的时候 $\\text{hash}$就束手无策了 字典树，英文名 $\\text{Trie}$。顾名思义，就是一个像字典一样的树，是一种可以快速插入和查询字符串的多叉树结构。 大家都知道一种数据结构设计的出现往往是为了解决特定的一类问题，$\\text{Trie}$ 的最基础的应用就是查找一个字符串是否在字典中出现过。暴力的做法的时间复杂度与字典大小成正比，但是字典树可以做到只与字符串长度有关，虽然比较废空间。 下面我们来明确模板中各个数组含义： $ne[p][c]$：存储从节点 $p$ 沿着 $c$ 这条边走到的子节点，边 $c$ 由 $26$ 个字母构成，所以每个节点最多有 $26$ 个子节点。 $cnt[p]$：以节点 $p$ 结尾的单词的插入次数。 $idx$：节点编号，存储当前已经用到了哪个点。 数组版本模板如下(速度更快)： const int N = 100010; struct Trie { int ne[N][26], cnt[N], idx; // 下标为0的节点用作根节点,如果ne[i][j]=0就表示没有子节点 Trie() { // 构造函数：这里需要全部初始话，不然可能力扣用例很奇怪过不了 memset(ne, 0, sizeof(ne)); memset(cnt, 0, sizeof(cnt)); idx = 0; } void insert(char* s) { int p = 0; // 从根节点开始走 for (int i = 0; i \u003c strlen(s); i ++) { int c = s[i] - 'a'; // 判断往哪走 if (!ne[p][c]) ne[p][c] = ++ idx; // 如果没有节点就新增节点 p = ne[p][c]; // 更新p节点 } cnt[p] ++; } int query(char* s) { int p = 0; // 从根节点开始走 for (int i = 0; i \u003c strlen(s); i ++) { int c = s[i] - 'a'; // 判断往哪走 if (!ne[p][c]) return 0; // 如果没有节点就停止 p = ne[p][c]; // 更新p节点 } return cnt[p]; } }; 链表版本： struct Trie { struct Node { Node* next[26] = {}; // 显式初始化为 nullptr int cnt = 0; }; Node* root = new Node(); void insert(string word) { int n = word.size(); Node* cur = root; for (int i = 0; i \u003c n; i ++) { if (cur-\u003enext[word[i] - 'a']) { Node* tmp = new Node(); cur-\u003enext[word[i] - 'a'] = tmp; } cur = cur-\u003enext[word[i] - 'a']; } cur-\u003ecnt ++; } bool search(string word) { int n = word.size(); Node* cur = root; for (int i = 0; i \u003c n; i ++) { if (cur-\u003enext[word[i] - 'a'] == nullptr) return false; cur = cur-\u003enext[word[i] - 'a']; } return cur-\u003ecnt \u003e 0; } bool startsWith(string prefix) { int n = prefix.size(); Node* cur = root; for (int i = 0; i \u003c n; i ++) { if (cur-\u003enext[prefix[i] - 'a'] == NULL) return false; cur = cur-\u003enext[prefix[i] - 'a']; } return true; } }; 完整 C++ 代码 #include \u003ciostream\u003e #include \u003ccstring\u003e using namespace std; const int N = 100010; // 所有输入的字符串总长度不超过10^5 char s[N]; struct Trie { int ne[N][26], cnt[N], idx; // 下标为0的节点用作根节点,如果ne[i][j]=0就表示没有子节点 Trie() { // 构造函数：这里需要全部初始话，不然可能力扣用例很奇怪过不了 memset(ne, 0, sizeof(ne)); memset(cnt, 0, sizeof(cnt)); idx = 0; } void insert(char* s) { int p = 0; // 从根节点开始走 for (int i = 0; i \u003c strlen(s); i ++) { int c = s[i] - 'a'; // 判断往哪走 if (!ne[p][c]) ne[p][c] = ++ idx; // 如果没有节点就新增节点 p = ne[p][c]; // 更新p节点 } cnt[p] ++; } int query(char* s) { int p = 0; // 从根节点开始走 for (int i = 0; i \u003c strlen(s); i ++) { int c = s[i] - 'a'; // 判断往哪走 if (!ne[p][c]) return 0; // 如果没有节点就停止 p = ne[p][c]; // 更新p节点 } return cnt[p]; } }; int main() { Trie t; // 创建trie对象 int n; cin \u003e\u003e n; while (n--) { char op; cin \u003e\u003e op \u003e\u003e s; if (op == 'I') t.insert(s); // 调用结构体的插入方法 else cout \u003c\u003c t.query(s) \u003c\u003c endl; // 调用结构体的查询方法 } return 0; } ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:20:2","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"并查集 ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:21:0","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"堆 ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:22:0","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"AcWing 839. 模拟堆 题目描述 ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:22:1","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"839. 模拟堆 维护一个集合，初始时集合为空，支持如下几种操作： I x，插入一个数 $x$； PM，输出当前集合中的最小值； DM，删除当前集合中的最小值（数据保证此时的最小值唯一）； D k，删除第 $k$ 个插入的数； C k x，修改第 $k$ 个插入的数，将其变为 $x$； 现在要进行 $N$ 次操作，对于所有第 $2$ 个操作，输出当前集合的最小值。 输入格式 第一行包含整数 $N$。 接下来 $N$ 行，每行包含一个操作指令，操作指令为 I x，PM，DM，D k 或 C k x 中的一种。 输出格式 对于每个输出指令 PM，输出一个结果，表示当前集合中的最小值。 每个结果占一行。 数据范围 $1≤N≤10^5$ $−10^9≤x≤10^9$ 数据保证合法。 输入样例： 8 I -10 PM I -10 D 1 C 2 8 I 6 PM DM 输出样例： -10 6 算法设计 堆是一棵完全二叉树的结构，下面我们以小根堆为例来分析如何用数组手写一个堆。 这里我们的数组下标从 $1$，这样节点 $i$ 的左孩子就是 $2i$，右孩子就是 $2i+1$。 小根堆需要满足的性质是每个点都小于它的左右孩子。 堆有两个基本方法：down(u)和up(u)： down(u)：将一个点往下移动到合适的位置，通过把一个点和他的左右孩子比较，然后和他最小的孩子，然后递归处理 up(u)：将一个点向上移动到合适的位置，通过把一个点和他的父节点比较，如果小于父节点就交换，然后递归处理 我们需要用这两个基本方法来实现以下堆的常用操作： push(x)：插入一个元素，把元素插到数组末尾，然后up(size)就行。 top()：返回当前堆中的最小值，就是heap[1]。 pop()：删除最小值，这里因为数组头部下标不能动，所以需要将数组末尾元素放到数组头，然后down(1)就行。 remove(u)：删除第 $u$ 个插入的元素，故技重施，为了维护数组下标的连续，不能直接删掉这个元素，而是需要将数组末尾元素放到这里，如果这里交换后变小了，还需要up(u)，如果变大了还需要down(u)。当然这里更复杂的是需要用一个数组来记录下第 $u$ 个插入的元素现在在哪里，因为up(u)和down(u)会交换元素顺序。 modify(u, x)：修改第 $u$ 个插入的元素， 如果这里修改后元素值变小了，还需要up(u)，如果变大了还需要down(u)。同理也需要记录。 注：由于 $4,5$ 两个操作需要记录第 $u$ 个插入的元素现在在哪，所以我们需要用两个映射数组 $ph_i$ 和 $hp_j$，来记录元素位置，$ph_i$ 存的是映射数组中第 $i$ 个元素现在在堆中位置下标，$hp_j$ 存的是堆中第 $j$ 个元素在映射数组中的位置下标。为什么需要两个映射数组呢，这其实就是因为我们要交换堆中的两个元素，需要知道这两个元素在映射数组中的下标，这样才能同步去更新映射数组，这时候为了速度就需要再存一个堆到映射数组的映射。 所以我们下面给出两个模板，第一个模板只实现了前三个操作，很简单，日常基本就够用了，虽然 $\\text{STL}$ 提供的版本就是这个版本。第二个模板实现了全部五个操作，但是更复杂，但是在后面学到优化 $\\text{Dijkstra}$ 的时候会用到。 下面我们有一个巧妙的建堆方式，可以将时间复杂度从将每一个数插入到堆中的 $O(nlogn)$ 降低到 $O(n)$。 只需要对数据从 $\\frac{n}{2}$ 往前进行 down(i)操作即可：for (int i = n \u003e\u003e 1; i \u003e 0; i --) down(i); 下面我们对这个建堆方式的时间复杂度进行证明： 对于这个堆来说，是一颗完全二叉树的结构，最后一层我们无需调整，因为已经是叶子节点了，我们只需要逐层向上做down(u)操作进行调整即可。 那么对于倒数第二层来说有 $\\frac{n}{4}$ 个节点，down(u)操作的时间复杂度是和高度有关，因此需要时间可以计为 $\\frac{n}{4} \\times 1$。同理对于倒数第三层来说，时间可以计为 $\\frac {n} {8} \\times 2$。 所以总共时间可以写为： $$ t = \\frac{n}{4}\\times1 + \\frac{n}{8}\\times2 + \\frac{n}{16}\\times3 + \\dots = n\\times(\\frac{1}{2^2} + \\frac{2}{2^3} + \\frac{3}{2^4} + \\dots) $$ 显然这是高中常见的等差乘等比的数列形式，只需要使用错位相减即可得到 $t\\approx n$，证毕。 下面我们给出普通版本小根堆的结构体模板以及实现了随机修改删除版本的堆的结构体模板 // 普通版本小根堆结构体模板 struct Heap { int h[100010], size; Heap() { memset(h, 0, sizeof h); size = 0; } void up(int u) { while (u \u003e\u003e 1 \u003e 0 \u0026\u0026 h[u] \u003c h[u \u003e\u003e 1]) { swap(h[u], h[u \u003e\u003e 1]); u = u \u003e\u003e 1; } } void down(int u) { // 找三个数最小值 int t = u; // 存的最小值编号 if (u * 2 \u003c= size \u0026\u0026 h[u * 2] \u003c h[t]) t = u * 2; if (u * 2 + 1 \u003c= size \u0026\u0026 h[u * 2 + 1] \u003c h[t]) t = u * 2 + 1; if (t != u) { swap(h[u], h[t]); down(t); // 继续递归处理 } } // 优化后的建队代码：时间复杂度是O(n),注意：传入的数组要从下标0开始 void build(int a[], int n) { copy(a, a + n, h + 1); size = n; for (int i = n \u003e\u003e 1; i \u003e 0; i --) down(i); } void push(int x) { h[++ size] = x; up(size); } int top() { return h[1]; } void pop() { h[1] = h[size --]; down(1); } }; // 支持随机修改删除版本的堆的结构体模板 struct Heap { int h[100010], ph[100010], hp[100010], size_h, size_ph; // ph,hp是映射数组 Heap() { memset(h, 0, sizeof h); memset(ph, 0, sizeof ph); memset(hp, 0, sizeof hp); size_h = 0, size_ph = 0; } // 同步映射交换 void heap_swap(int i, int j) { swap(h[i], h[j]); swap(ph[hp[i]], ph[hp[j]]); swap(hp[i], hp[j]); } void up(int u) { while (u \u003e\u003e 1 \u003e 0 \u0026\u0026 h[u] \u003c h[u \u003e\u003e 1]) { heap_swap(u, u \u003e\u003e 1); u = u \u003e\u003e 1; } } void down(int u) { // 找三个数最小值 int t = u; // 存的最小值编号 if (u * 2 \u003c= size_h \u0026\u0026 h[u * 2] \u003c h[t]) t = u * 2; if (u * 2 + 1 \u003c= size_h \u0026\u0026 h[u * 2 + 1] \u003c h[t]) t = u * 2 + 1; if (t != u) { heap_swap(u, t); down(t); // 继续递归处理 } } // 优化后的建队代码：时间复杂度是O(n),注意：传入的数组要从下标0开始 void build(int a[], int n) { copy(a, a + n, h + 1); for (int i = 1; i \u003c= n; i ++) ph[i] = hp[i] = i; size_h = n, size_ph = n; for (int i = n \u003e\u003e 1; i \u003e 0; i --) down(i); } void push(int x) { h[++ size_h] = x; ph[++ size_ph] = size_h; hp[size_h] = size_ph; up(size_h); } int top() { return h[1]; } void pop() { heap_swap(1, size_h --); down(1); } // 删除第u个插入的元素 void remove(int u) { u = ph[u]; heap_swap(u, size_h --); // !!! 这里直接写成heap_swap(ph[u], size_h --),up(ph[u]), down(ph[u]);是错误的，因为ph[u]的值会变在heap_swap之后 up(u), down(u); // 本来是需要判断交换后变大还是变小来判断需要什么操作，我们这里为了简单直接两个都做了,最多只会执行其中一个 } // 修改第u个插入的元素 void modify(int u, int x) { u = ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:22:2","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"树状数组 线段树能解决超多有关区间的问题，还有一些不这么明显的区间问题（废话）。像什么单点修改，单点查询，区间修改，区间查询都不在话下，应用范围比树状数组广，变通性极强（树状数组能解决的问题线段树都能解决，但是后者能解决的一些问题树状数组还是搞不了的，但是树状数组时空常数小，代码量少，还不容易写错）。 所以直接学线段树了（乐） ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:23:0","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"线段树 ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:24:0","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"AcWing 1275. 最大数 题目描述 ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:24:1","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"1275. 最大数 给定一个正整数数列 $a_1,a_2,…,a_n$，每一个数都在 $0∼p−1$ 之间。 可以对这列数进行两种操作： 添加操作：向序列后添加一个数，序列长度变成 $n+1$； 询问操作：询问这个序列中最后 $L$ 个数中最大的数是多少。 程序运行的最开始，整数序列为空。 一共要对整数序列进行 $m$ 次操作。 写一个程序，读入操作的序列，并输出询问操作的答案。 输入格式 第一行有两个正整数 $m,p$，意义如题目描述； 接下来 $m$ 行，每一行表示一个操作。 如果该行的内容是 Q L，则表示这个操作是询问序列中最后 $L$ 个数的最大数是多少； 如果是 A t，则表示向序列后面加一个数，加入的数是 $(t+a)\\ \\text{mod}\\ p$。其中，$t$ 是输入的参数，$a$ 是在这个添加操作之前最后一个询问操作的答案（如果之前没有询问操作，则 $a=0$）。 第一个操作一定是添加操作。对于询问操作，$L\u003e0$ 且不超过当前序列的长度。 输出格式 对于每一个询问操作，输出一行。该行只有一个数，即序列中最后 $L$ 个数的最大数。 数据范围 $1≤m≤2×10^5,$ $1≤p≤2×10^9,$ $0≤t\u003cp$ 输入样例： 10 100 A 97 Q 1 Q 1 A 17 Q 2 A 63 Q 1 Q 1 Q 3 A 99 输出样例： 97 97 97 60 60 97 样例解释 最后的序列是 $97,14,60,96$。 算法设计 我们收录的这题是线段树的模板题，是想引入线段树的各种操作。 pushup()：用子节点信息更新父节点信息 build()：将一段区间初始化成线段树 modify()：修改；如果修改的是单点，那很简单无需懒标记；如果修改的是区间，那就需要pushdown()操作，非常复杂 query()：查询某一段区间信息 pushdown()：需要使用懒标记，很复杂 我们来详细分析一下query(l,r)会遇到的情况，记当前递归到的区间为 $[T_l,T_r]$： 若 $[T_l,T_r] \\subseteq [l,r]$，直接返回即可。 若 $[T_l,T_r] \\cap [l,r] \\ne \\varnothing$，递归遍历和 $[l,r]$ 又交集的左子区间或又子区间。 若 $[T_l,T_r] \\cap [l,r] = \\varnothing$，由上面两步可知，不会碰到这种情况的，所以这种情况其实不存在。 可以证明只需要 $O(logn)$ 的时间就可以查询结束，这里就留给大家自己去证明。 下面我们给出线段树结构体模板： // 只支持区间单点修改的无懒标记版本的线段树结构体模板 struct SegmentTree { struct Node { int l, r; int v; // 根据问题去确定value的含义 } tr[4 * 200010]; // 需要开4倍区间大小的空间 SegmentTree() // 结构体初始化 { memset(tr, 0, sizeof tr); } void pushup(int u) // 由子节点信息更新父节点信息 { tr[u].v = max(tr[u * 2].v, tr[u * 2 + 1].v); // 根据题意去调整更新策略 } void build(int u, int l, int r) { tr[u] = {l, r}; if (l == r) return; int mid = l + r \u003e\u003e 1; build(u * 2, l, mid), build(u * 2 + 1, mid + 1, r); // 递归建左右孩子 } int query(int u, int l, int r) { if (tr[u].l \u003e= l \u0026\u0026 tr[u].r \u003c= r) return tr[u].v; // 全包含的情况 int mid = tr[u].l + tr[u].r \u003e\u003e 1; int res = 0; if (l \u003c= mid) res = max(res, query(u * 2, l, r)); if (r \u003e= mid + 1) res = max(res, query(u * 2 + 1, l, r)); return res; } void modify(int u, int k, int v) { if (tr[u].l == k \u0026\u0026 tr[u].r == k) tr[u].v = v; else { int mid = tr[u].l + tr[u].r \u003e\u003e 1; if (k \u003c= mid) modify(u * 2, k, v); else modify(u * 2 + 1, k, v); pushup(u); } } }; 来不及更新支持区间修改的有懒标记版本的线段树结构体模板，因为今天是一年的ddl了 ——2024.12.31 23:05 完整 C++ 代码 #include \u003ciostream\u003e #include \u003ccstring\u003e #include \u003calgorithm\u003e using namespace std; // 只支持区间单点修改的无懒标记版本的线段树结构体模板 struct SegmentTree { struct Node { int l, r; int v; // 根据问题去确定value的含义 } tr[4 * 200010]; // 需要开4倍区间大小的空间 SegmentTree() // 结构体初始化 { memset(tr, 0, sizeof tr); } void pushup(int u) // 由子节点信息更新父节点信息 { tr[u].v = max(tr[u * 2].v, tr[u * 2 + 1].v); // 根据题意去调整更新策略 } void build(int u, int l, int r) { tr[u] = {l, r}; if (l == r) return; int mid = l + r \u003e\u003e 1; build(u * 2, l, mid), build(u * 2 + 1, mid + 1, r); // 递归建左右孩子 } int query(int u, int l, int r) { if (tr[u].l \u003e= l \u0026\u0026 tr[u].r \u003c= r) return tr[u].v; // 全包含的情况 int mid = tr[u].l + tr[u].r \u003e\u003e 1; int res = 0; if (l \u003c= mid) res = max(res, query(u * 2, l, r)); if (r \u003e= mid + 1) res = max(res, query(u * 2 + 1, l, r)); return res; } void modify(int u, int k, int v) { if (tr[u].l == k \u0026\u0026 tr[u].r == k) tr[u].v = v; else { int mid = tr[u].l + tr[u].r \u003e\u003e 1; if (k \u003c= mid) modify(u * 2, k, v); else modify(u * 2 + 1, k, v); pushup(u); } } }; int main() { int n = 0, last = 0; int m, p; cin \u003e\u003e m \u003e\u003e p; SegmentTree segmentTree; segmentTree.build(1, 1, m); while (m --) { char op[2]; int L, t; cin \u003e\u003e op; if (!strcmp(op, \"Q\")) cin \u003e\u003e L, last = segmentTree.query(1, n - L + 1, n), cout \u003c\u003c last \u003c\u003c endl; else cin \u003e\u003e t, segmentTree.modify(1, ++ n, ((long long)t + last) % p); } return 0; } ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:24:2","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"平衡树 ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:25:0","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"AC自动机 ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:26:0","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"Dancing Links 第三章 搜索与图论 ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:27:0","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"DFS ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:28:0","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"AcWing 843. n-皇后问题 题目描述 ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:28:1","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"843. n-皇后问题 $n$-皇后问题是指将 $n$ 个皇后放在 $n×n$ 的国际象棋棋盘上，使得皇后不能相互攻击到，即任意两个皇后都不能处于同一行、同一列或同一斜线上。 1_597ec77c49-8-queens.png 现在给定整数 $n$，请你输出所有的满足条件的棋子摆法。 输入格式 共一行，包含整数 $n$。 输出格式 每个解决方案占 $n$ 行，每行输出一个长度为 $n$ 的字符串，用来表示完整的棋盘状态。 其中 . 表示某一个位置的方格状态为空，Q 表示某一个位置的方格上摆着皇后。 每个方案输出完成后，输出一个空行。 注意：行末不能有多余空格。 输出方案的顺序任意，只要不重复且没有遗漏即可。 数据范围 $1≤n≤9$ 输入样例： 4 输出样例： .Q.. ...Q Q... ..Q. ..Q. Q... ...Q .Q.. 算法设计 首先我们来比较一下深度优先搜索和广度优先搜索这两种方式： 数据结构 空间 性质 $\\text{DFS}$ $\\text{Stack}$ 递归耗空间 无“最短路” $\\text{BFS}$ $\\text{Queue}$ 迭代省空间 “最短路\"性质 这题是一道 $\\text{DFS}$ 的经典模板题。 $\\text{DFS}$ 有两步关键点：回溯，剪枝。 回溯其实就是 $\\text{DFS}$ 的本身的一个特性，因为它每次都是先访问到搜索树的叶节点，然后返回再访问上一层节点，所以这就是一步回溯的操作，回溯需要恢复现场。 剪枝说的就是 $\\text{DFS}$ 又名暴搜，其实本质上就是把每一种可能性都枚举了，但是在我们探索的过程中，其实就可以进行判断，如果可以确定这条路走不通，也就无需访问这条路径的叶子节点，可以减少很多时间，也被称为剪去搜索树的整个分枝。 同时由于每个点只能被走一次，所以无论是 $\\text{DFS}$ 还是 $\\text{BFS}$，我们基本都要开一个 $\\text{bool}$ 类型的 $st$ 数组来存储哪些点已经被我们走过了。 有了上面的一些基础知识，下面我们来分析这道题： 此题 $\\text{DFS}$ 在探索时中传入的 $u$ 是当前处理的行号，因为每行只会放置一个皇后，因此就无需再开一个 $\\text{row[N]}$ 来记录行信息，而这里对于放置的每个皇后后记录它所在正对角线和反对角线的方法很特殊。 我们可以使用编程坐标系来求解，也即行方向为 $x$ 方向，列方向为 $y$ 方向，所以此时我们传入的 $u$ 即 $x$ 坐标，$i$ 也就是 $y$ 坐标。 所以对于放置的每一个皇后，经过它的正对角线方程为 $y=x+b_1$，反对角线方程为 $y = -x + b_2$，所以 $\\begin{cases} b_1 = y-x \\ b_2 = y+x \\end{cases} $ 故我们只需要记录一下所谓的每次放置的皇后所在对角线的 $b_1$ 点和 $b_2$ 点即可。 不过这里还有一个小细节，我们在计算$b_1=y-x$ 时，会有时候算出负值来，但是我们的数组下标不能有负值，所以这里我们直接记录 $b_1+n$ 即可保证合法，同时我们这里的正负对角线数组要开成 $2N$ 大小才能正确。 所以最终我们记录的是 $\\begin{cases} b_1+n = y-x+n \\ b_2 = y+x \\end{cases} $ 完整 C++ 代码 #include \u003ciostream\u003e using namespace std; const int N = 10, M = 2 * N; int n; char g[N][N]; bool col[N], dg[M], udg[M]; // col：记录列情况，dg：正对角线，udg：反对角线 // dfs和bfs基本都要开一个bool数组用来标记走过哪些点，因为 void dfs(int u) { if (u == n) { for (int i = 0; i \u003c n; i++) cout \u003c\u003c g[i] \u003c\u003c endl; cout \u003c\u003c endl; return; } for (int i = 0; i \u003c n; i ++) { if (!col[i] \u0026\u0026 !dg[i - u + n] \u0026\u0026 !udg[i + u]) // 剪枝 { g[u][i] = 'Q'; col[i] = dg[i - u + n] = udg[i + u] = true; dfs(u + 1); col[i] = dg[i - u + n] = udg[i + u] = false; // 回溯：恢复现场 g[u][i] = '.'; } } } int main() { cin \u003e\u003e n; for (int i = 0; i \u003c n; i ++) for (int j = 0; j \u003c n; j ++) g[i][j] = '.'; dfs(0); return 0; } ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:28:2","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"AcWing 165. 小猫爬山 题目描述 ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:28:3","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"165. 小猫爬山 翰翰和达达饲养了 $N$ 只小猫，这天，小猫们要去爬山。 经历了千辛万苦，小猫们终于爬上了山顶，但是疲倦的它们再也不想徒步走下山了（呜咕\u003e_\u003c）。 翰翰和达达只好花钱让它们坐索道下山。 索道上的缆车最大承重量为 $W$，而 $N$ 只小猫的重量分别是 $C_1、C_2…C_N$。 当然，每辆缆车上的小猫的重量之和不能超过 $W$。 每租用一辆缆车，翰翰和达达就要付 $1$ 美元，所以他们想知道，最少需要付多少美元才能把这 $N$ 只小猫都运送下山？ 输入格式 第 $1$ 行：包含两个用空格隔开的整数，$N$ 和 $W$。 第 $2∼N+1$ 行：每行一个整数，其中第 $i+1$ 行的整数表示第 $i$ 只小猫的重量 $C_i$。 输出格式 输出一个整数，表示最少需要多少美元，也就是最少需要多少辆缆车。 数据范围 $1≤N≤18$, $1≤C_i≤W≤10^8$ 输入样例： 5 1996 1 2 1994 12 29 输出样例： 2 算法设计 这是收录的算法提高课的一道经典题目，比起刚刚的一道 $\\text{DFS}$ 的算法思想要更复杂，因为需要更加细化剪枝的策略。 $\\text{DFS}$ 的题目一般的剪枝模型有以下 $5$ 方面： 优化搜索顺序 首先如果不使用剪枝，那么无论搜索顺序如何，结果都是一样的 但是当有剪枝操作存在的时候，就会存在以下结论：在大部分情况，我们应该优先搜索分支较少的节点。 排除等效冗余 也即尽量少重复搜索。如果不考虑顺序，尽量使用组合枚举的方式来搜索 可行性剪枝 如果在搜索的过程中就发现不合法，就可以提前退出了 最优性剪枝 如果在搜索的过程中发现无论如何都会比当前已经搜到的最优解差，就可以提前退出了 记忆化搜索($\\text{DP}$) 详细请看第五章记忆化搜索章节 下面我们来分析这道题： 注：此题不优化搜索顺序会 $\\text{TLE}$。 我们从上面的剪枝模型入手： 优化搜索顺序✔：我们首先把最重的猫放进某辆车里面，那么后续还能放进这辆车的猫的情况自然就少了 排除等效冗余✔：使用了组合型枚举的方式 可行性剪枝✔：我们发现放猫进某辆车就超重了，自然就不合法可以提前退出了 最优性剪枝✔：我们发现当前这种情况需要的车已经比已经搜到的最优解多了，就可以提前退出了 记忆化搜索($\\text{DP}$)✖：主要在 $\\text{DP}$ 里面用的比较多，这里没用到 完整 C++ 代码 #include \u003ciostream\u003e #include \u003ccstring\u003e #include \u003calgorithm\u003e using namespace std; const int N = 20; int n, v; int w[N], s[N]; int ans = N; // 最坏情况每只猫一辆车 void dfs(int u, int k) // 第u只猫，当前的车的数量是k { // 4.最优性剪枝 if (k \u003e= ans) return; if (u == n) { ans = k; return; } for (int i = 0; i \u003c k; i ++) // 枚举放哪辆车上 { // 3.可行性剪枝 if (s[i] + w[u] \u003c= v) { s[i] += w[u]; dfs(u + 1, k); s[i] -= w[u]; // 恢复现场 } } s[k] = w[u]; // 新开一辆车来 dfs(u + 1, k + 1); s[k] = 0; // 恢复现场 } int main() { cin \u003e\u003e n \u003e\u003e v; for (int i = 0; i \u003c n; i ++) cin \u003e\u003e w[i]; // 1.优化搜索顺序 sort(w, w + n); reverse(w, w + n); dfs(0, 0); cout \u003c\u003c ans \u003c\u003c endl; return 0; } ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:28:4","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"BFS vector\u003cvector\u003cint\u003e\u003e levelOrder(TreeNode* root) { //use queue (non-recursion) vector\u003cvector\u003cint\u003e\u003e result; queue\u003cTreeNode*\u003e que; if(root) que.push(root); while(!que.empty()) { //Note: the Size is key int size = que.size(); vector\u003cint\u003e temp; while(size --) { TreeNode* cur = que.front(); temp.push_back(cur-\u003eval); que.pop(); if(cur-\u003eleft) que.push(cur-\u003eleft); if(cur-\u003eright) que.push(cur-\u003eright); } result.push_back(temp); } return result; } ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:29:0","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"树与图 ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:30:0","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"AcWing 846. 树的重心 题目描述 ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:30:1","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"846. 树的重心 给定一颗树，树中包含 $n$ 个结点（编号 $1∼n$）和 $n−1$ 条无向边。 请你找到树的重心，并输出将重心删除后，剩余各个连通块中点数的最大值。 重心定义：重心是指树中的一个结点，如果将这个点删除后，剩余各个连通块中点数的最大值最小，那么这个节点被称为树的重心。 输入格式 第一行包含整数 $n$，表示树的结点数。 接下来 $n−1$ 行，每行包含两个整数 $a$ 和 $b$，表示点 $a$ 和点 $b$ 之间存在一条边。 输出格式 输出一个整数 $m$，表示将重心删除后，剩余各个连通块中点数的最大值。 数据范围 $1≤n≤10^5$ 输入样例 9 1 2 1 7 1 4 2 8 2 5 4 3 3 9 4 6 输出样例： 4 算法设计 这里插一个知乎回答： 至于ACwing的课程质量，虽然有一些答主在批评，但实际上我给学弟学妹选资料的时候看过，总体还是不错的。基本上每道题和知识点都论证和解释的很细，而且现场手打代码AC我觉得挺好的。虽然题都是经典板子题，但是个人认为对初学者是必要的学习经过，不算缺点。我讨厌的问题就是不愿意用STL，存图还要用链式前向星。都什么时代了，没必要吧。 链式前向星快1.5倍，但是debug起来更麻烦。1.5的常数在acm里一般可以忽略。现在都开O2优化了，用vector更方便 所以好像y总这种写法没有太大必要（乐） 由于树是一种特殊的图，而无向边的图相当于画有两条有向边的图，所以我们只需要抽象出有向图的模板即可解决树和图的基本问题。 有向图一般有邻接矩阵和邻接表两种存储方式。 由于邻接矩阵对于稀疏图的效果不是很好，因此在 ACM 中我们一般不会使用，而是改用邻接表来存储。 首先我们来明确模板中各个数组含义： $h_i$：指向第 $i$ 个链表的头节点。 $e_i$：存储节点 $i$ 的值。 $ne_i$：存储节点 $i$ 的 $\\text{next}$ 指针指向的节点。 $\\text{idx}$：存储当前已经用到了哪个点。 $\\text{st}$：记录搜索过程中已经走过哪些点了，因为这里把无向边替换成两条有向边，如果不记录就会回头，造成死循环。 这里的定义其实就和第二章单链表给出的模板基本一样，只是单链表只有一个头我们直接用 $\\text{head}$ 就可以了，这里有多个头所以我们使用 $h$ 数组来表示某个头节点。 下面我们给出有向图的 $\\text{DFS}$ 的代码框架： const int N = 100010, M = N * 2; int h[N], e[M], ne[M], idx; bool st[N]; // dfs和bfs基本都要开一个bool数组用来标记走过哪些点，因为每个点只能被遍历一次 // 插入一条 a-\u003eb 的边 void add(int a, int b) { e[idx] = b, ne[idx] = h[a], h[a] = idx ++; } void dfs(int u) { st[u] = true; // 标记一下该点已经被走过了 for (int i = h[u]; i != -1; i = ne[i]) // 和遍历单链表是一模一样的 { int j = e[i]; if (!st[j]) dfs(j); } } int main() { memset(h, -1, sizeof h); // 仿造链表初始化，将所以h都初始化为-1 } 这里我们给出更易于理解和好写的vector版本，速度稍微慢一丢丢 vector\u003cvector\u003cint\u003e\u003e h(n); for (auto\u0026 e : edges) { int x = e[0], y = e[1]; h[x].push_back(y), h[y].push_back(x); // 无向图建图法 } 下面我们来分析这道题，这道题是要求重心，所以我们需要思考：如何求删除某个点后剩余各个连通块中点数？ 这个问题直接用 $DFS$ 就可以解决： 如图，我们思考一个一般性的情况：如果我们此时需要计算删除点 $4$ 之后剩余的 $1,2,3$ 号连通块的点数。 对于连通块 $2$ 和 $3$，我们可以通过 $\\text{DFS}$ 在回溯的过程中将连通块 $\\text{size}$ 返回，这样就可以知道连通块 $2$ 和 $3$ 的点数，但是对于连通块 $1$ 来说，无法通过返回值来求出来，这里我们可以使用一个技巧：$s_1=n-(sum_4)$。毕竟总节点数我们是知道的，所以只需要用总节点数减去节点 $4$ 这棵子树的总结点数就可以得到了。 完整 C++ 代码 #include \u003ciostream\u003e #include \u003ccstring\u003e #include \u003calgorithm\u003e using namespace std; const int N = 100010, M = N * 2; int n; int h[N], e[M], ne[M], idx; bool st[N]; // dfs和bfs基本都要开一个bool数组用来标记走过哪些点，因为每个点只能被遍历一次 int ans = N; // 记录一下全局的最小值 // 插入一条 a-\u003eb 的边 void add(int a, int b) { e[idx] = b, ne[idx] = h[a], h[a] = idx ++; } // 返回以u为根的子树中点的数量 int dfs(int u) { st[u] = true; // 标记一下该点已经被走过了 int sum = 1; // 记录当前子树的大小 int res = 0; // 把这个点删除后每一个连通块大小的最大值 for (int i = h[u]; i != -1; i = ne[i]) // 和遍历单链表是一模一样的 { int j = e[i]; if (!st[j]) { int s = dfs(j); sum += s; res = max(res, s); } } res = max(res, n - sum); // 上面连通块这种情况单独处理 ans = min(ans, res); return sum; } int main() { cin \u003e\u003e n; memset(h, -1, sizeof h); // 仿造链表初始化，将所以h都初始化为-1 for (int i = 0; i \u003c n; i ++) { int a, b; cin \u003e\u003e a \u003e\u003e b; add(a, b); add(b, a); // 无向图视为两条有向边 } dfs(1); // 这里从节点几开始搜都是可以的 cout \u003c\u003c ans \u003c\u003c endl; return 0; } ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:30:2","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"最短路 ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:31:0","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"单源最短路径 LeetCode 743. 网络延迟时间 题目描述 ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:31:1","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"LeetCode 743. 网络延迟时间 有 n 个网络节点，标记为 1 到 n。 给你一个列表 times，表示信号经过 有向 边的传递时间。 times[i] = (ui, vi, wi)，其中 ui 是源节点，vi 是目标节点， wi 是一个信号从源节点传递到目标节点的时间。 现在，从某个节点 K 发出一个信号。需要多久才能使所有节点都收到信号？如果不能使所有节点收到信号，返回 -1 。 示例 1： img 输入：times = [[2,1,1],[2,3,1],[3,4,1]], n = 4, k = 2 输出：2 提示： 1 \u003c= k \u003c= n \u003c= 100 1 \u003c= times.length \u003c= 6000 times[i].length == 3 1 \u003c= ui, vi \u003c= n ui != vi 0 \u003c= wi \u003c= 100 所有 (ui, vi) 对都 互不相同（即，不含重复边） 算法设计 这题是一道经典的 Dijkstra 算法 板子题。 Dijkstra 算法: 可以解决不含负权边的图的单源最短路径问题 我们定义图的邻接矩阵为 $matrix[][]$，$matrix(i, j)$ 表示节点编号 $i$ 到节点编号 $j$ 的路径长度。 我们的目标就是计算出节点编号 i 的 $dist[]$ 数组，$dist(j)$ 表示从节点编号 $i$ 到节点编号 $j$ 的最短路的长度。 首先对 $\\forall j$, $dist(j)$ 的初值就是 $matrix(i, j)$。 然后取除了起点 $i$ 以外的 $dist[]$ 的最小值，我们假设当前的这个最小值的节点编号是 $k$。那么我们可以说：$dist(k)$ 的最小值我们已经确定了！我们可以用反证法来证明：如果说还存在有更短的路径经过节点编号 $u$,也就是 $dist(k) = dist(u) + matrix(u,k)$，由于我们的图是不含负权边的（这也是 Dijkstra 算法只适用于解决不含负权边的图的单源最短路径问题的原因），那么一定有 $matrix(u, k) \u003e 0$，所以 $dist(u) \u003c dist(k)$，显然这与我们前面对节点编号 $k$ 的定义矛盾！故原命题成立，此时我们得到了 $dist(k)$ 的最终值。 我们用我们已经确定的节点编号 $k$ 去更新其他的 $dist(j)\\ (j \\ne k)$，也就是通过 $dist(j) = min(dist(j), dist(k) + matrix(k, j))$。 然后我们取除了节点 $k$ 和起点 $i$ 以外的 $dist[]$的最小值，重复上述过程。 由数学归纳法可知，最终的结果 $dist[]$ 就是我们要求的。 写法一：朴素 Dijkstra（适用于稠密图） 稠密图： 边的数量集和 $n^2$ 相当的图（$n$ 是图的顶点数） 代码思路就是直接按照我们上面描述的，去实现就好了。 写成代码就是下面这样： /** * @brief dijkstra算法模板(朴素版本) * * @param adj_matrix 图的邻接矩阵 * @param idx 起点 idx（0 开始） * @return dist[i] 代表从单源节点 idx 到节点编号 i 的节点的最短路的长度 */ std::vector\u003cint\u003e dijkstra(std::vector\u003cstd::vector\u003cint\u003e\u003e\u0026 adj_matrix, int idx) { const int INF = 0x3f3f3f3f; int n = adj_matrix.size(); std::vector\u003cint\u003e dist(n, INF); dist[idx] = 0; // 到自己的距离是0 std::vector\u003cbool\u003e mask(n, false); // 记录是否已经确定好最短路了 // 找到当前 dist[i] 最小的节点编号 i while (true) { int mn = INF; int i = -1; for (int j = 0; j \u003c n; j ++) { if (mask[j] == false \u0026\u0026 dist[j] != INF \u0026\u0026 dist[j] \u003c mn) { i = j; mn = dist[j]; } } if (i == -1) break; // 如果剩下的全都不可达了，就可以提前结束了 // 用中间节点编号 i 更新从单源节点 idx 到节点编号 j 最短路径 mask[i] = true; for (int j = 0; j \u003c n; j ++) { if (adj_matrix[i][j] != INF) { dist[j] = std::min(dist[j], dist[i] + adj_matrix[i][j]); } } } return dist; } 复杂度分析 时间复杂度： $O(V^2)$。 空间复杂度： $O(V^2)$。 写法二：堆优化 Dijkstra（适用于稀疏图） 稀疏图： 边的数量远小于 $n^2$ 的图（$n$ 是图的顶点数） 聪明的你肯定发现，上面朴素 Dijkstra 写法的时间瓶颈在每次寻找当前 $dist[i]$ 的最小值上。 显然，这个可以通过空间换时间来优化，也就是用堆这种数据结构来优化。 当然，为了应对稀疏图，我们也不应该用邻接矩阵来建图了，因为有大量的元素是空的，而应该用邻接表来记录每一条边。 一开始把 $[dist(idx), idx]$ 二元组入堆 当前堆顶元素 $[dist(j), j]$ 就是 $dist(j)$ 的最小值 利用上面的元素 $j$ 来更新 $j$ 连接的所有的点，并将新的最小值入堆 重复上述操作，直到堆为空 写成代码就是下面这样： /** * @brief dijkstra算法模板（邻接表 + 最小堆优化版） * * @param adj_list 图的邻接表 * @param idx 起点 idx（0 开始） * @return dist[i] 代表从单源节点 idx 到节点编号 i 的节点的最短路的长度 */ std::vector\u003cint\u003e dijkstra(std::vector\u003cstd::vector\u003cstd::pair\u003cint, int\u003e\u003e\u003e\u0026 adj_list, int idx) { const int INF = 0x3f3f3f3f; int n = adj_list.size(); std::vector\u003cint\u003e dist(n, INF); dist[idx] = 0; std::priority_queue\u003cstd::pair\u003cint, int\u003e, std::vector\u003cstd::pair\u003cint, int\u003e\u003e, std::greater\u003c\u003e\u003e heap; // 用堆来优化每次的查找最小值 heap.emplace(0, idx); // 到本身是0 // 找到当前距离最小的节点编号 j,这个节点的最短路长度就已确认 while (heap.size() \u003e 0) { auto [dis_i, i] = heap.top(); // dis_i 代表从单源节点 idx 到节点编号 i 的节点的最短路的长度 heap.pop(); if (dist[i] \u003c dis_i) continue; // 如果目前这个都不是最短的了，那就没必要更新了 for (auto [j, dis_j] : adj_list[i]) { int new_dis = dis_i + dis_j; if (new_dis \u003c dist[j]) { dist[j] = new_dis; heap.emplace(dist[j], j); } } } return dist; } 复杂度分析 时间复杂度： $O(E \\log V)$。每条边都会被处理一次，然后堆的操作的时间复杂度是 $\\log V$, 空间复杂度： $O(E + V)$。 完整 C++ 代码 class Solution { public: /** * @brief dijkstra算法模板（邻接表 + 最小堆优化版） * * @param adj_list 图的邻接表 * @param idx 起点 idx（0 开始） * @return dist[i] 代表从单源节点 idx 到节点编号 i 的节点的最短路的长度 */ std::vector\u003cint\u003e dijkstra(std::vector\u003cstd::vector\u003cstd::pair\u003cint, int\u003e\u003e\u003e\u0026 adj_list, int idx) { const int INF = 0x3f3f3f3f; int n = adj_list.size(); std::vector\u003cint\u003e dist(n, INF); dist[idx] = 0; std::priority_queue\u003cstd::pair\u003cint, int\u003e, std::vector\u003cstd::pair\u003cint, int\u003e\u003e, std::greater\u003c\u003e\u003e heap; // 用堆来优化每次的查找最小值 heap.emplace(0, idx); // 到本身是0 // 找到当前距离最小的节点编号 j,这个节点的最短路长度就已确认 while (heap.size() \u003e 0) { auto [dis_i, i] = heap.top(); // dis_i 代表从单源节点 idx 到节点编号 i 的节点的最短路的长度 h","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:31:2","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"多源最短路径 LeetCode 1334. 阈值距离内邻居最少的城市 题目描述 ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:31:3","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"LeetCode 1334. 阈值距离内邻居最少的城市 有 n 个城市，按从 0 到 n-1 编号。给你一个边数组 edges，其中 edges[i] = [from, to, weight] 代表 from 和 to 两个城市之间的双向加权边，距离阈值是一个整数 distanceThreshold。 返回在路径距离限制为 distanceThreshold 以内可到达城市最少的城市。如果有多个这样的城市，则返回编号最大的城市。 注意，连接城市 $i$ 和 $j$ 的路径的距离等于沿该路径的所有边的权重之和。 示例 1： image-20260131191253434 输入：n = 4, edges = [[0,1,3],[1,2,1],[1,3,4],[2,3,1]], distanceThreshold = 4 输出：3 解释：城市分布图如上。 每个城市阈值距离 distanceThreshold = 4 内的邻居城市分别是： 城市 0 -\u003e [城市 1, 城市 2] 城市 1 -\u003e [城市 0, 城市 2, 城市 3] 城市 2 -\u003e [城市 0, 城市 1, 城市 3] 城市 3 -\u003e [城市 1, 城市 2] 城市 0 和 3 在阈值距离 4 以内都有 2 个邻居城市，但是我们必须返回城市 3，因为它的编号最大。 提示： $2 \\le n \\le 100$ $1 \\le$ edges.length $\\le n * (n - 1) / 2$ edges[i].length $= 3$ $0 \\le from_i \u003c to_i \u003c n$ $1 \\le \\text{weight}_i, \\ \\text{distanceThreshold} \\le 10^4$ 所有 $(\\text{from}_i, \\text{to}_i)$ 都是不同的。 算法设计 这题是一道经典的 Floyd 算法 板子题。 我们从寻找子问题 -\u003e 递归 -\u003e 记忆化搜索 -\u003e 动态规划 -\u003e 空间优化，一步步的来发明 Floyd 算法。 寻找子问题 我们假设有 $1, 2, 3, 4, 5$ 这5个节点，然后我们首先求 $1$ -\u003e $5$ 的最短路径长度是多少？ 聪明的你会开始分析：为了算出最短路径，我们首先需要知道最短路径上有哪些节点？ 这时候我们就需要一个个中间节点去判断了，此时的中间节点是 ${2, 3, 4}$，比如首先我们开始分析，对于中间节点 $2$ 来说，我们可以选，也可以不选。 那么如果选择走中间节点 $2$，之后 $1$ -\u003e $5$ 的最短路径长度就 $=$ 对于中间节点是 ${3, 4}$，（$1$ -\u003e $2$ 的最短路径长度） $+$ （$2$ -\u003e $5$ 的最短路径长度）； 如果不走中间节点 $2$，之后 $1$ -\u003e $5$ 的最短路径长度就 $=$ 对于中间节点是 ${3, 4}$，（$1$ -\u003e $5$ 的最短路径长度）。 显然，之前的问题被成功化简成了规模更小的子问题，那么这显然可以由递归解决： 递归 在上面探索子问题的时候，我们当前经过的中间节点时，其实枚举的顺序并不重要，反正每次都得判断完所有当前的中间节点是否经过。 因此我们就可以有一个更简单的方法：从节点编号大到小进行枚举，这样的好处就是：我们可以不用记录当前所有的中间节点有哪些，而是记录一个当前中间节点的最大值 $k$ 就行。 我们就可以定义 $dfs(k, from, to)$，用来表示从节点编号 $from$ 到节点编号 $to$ 的最短路的长度，并且这条路径上的中间节点的编号都 $\\le k$。 于是我们有以下两个子问题： 如果我们选择不走中间节点 $k$，那么剩下的中间节点的编号还剩下 $0∼k-1$，所以 $dfs(k, from, to) = dfs(k - 1, from, to) $； 如果我们选择走中间节点 $k$，那么剩下的中间节点的编号也还剩下 $0∼k-1$，所以 $\\text{dfs}(k, from, to) = dfs(k - 1, from, k)+ dfs(k - 1, k, to)$。 所以状态转移方程就是： $$ dfs(k, from, to) = min(dfs(k - 1, from, to),\\ dfs(k - 1, from, k)+ dfs(k - 1, k, to)) $$ 递归边界就是：没有中间节点时，也即 $k \u003c 0$，此时 $dfs(-1, from, to) = matrix[from][to]$。也就是说直接就是节点编号 $from$ 到节点编号 $to$ 的距离。 写成代码就是下面这样： class Solution { public: int findTheCity(int n, std::vector\u003cstd::vector\u003cint\u003e\u003e\u0026 edges, int distanceThreshold) { const int INF = 0x3f3f3f3f; // 1. 构建邻接矩阵 std::vector\u003cstd::vector\u003cint\u003e\u003e adj_matrix(n, std::vector\u003cint\u003e(n, INF)); // 无穷大代表不可达 for (int i = 0; i \u003c edges.size(); i ++) { int from = edges[i][0], to = edges[i][1], w = edges[i][2]; adj_matrix[from][to] = w; adj_matrix[to][from] = w; } // 2. 递归函数： 获得从编号 from 到编号 to 的所有中间节点编号都 ≤k 的最短路的长度 auto dfs = [\u0026](this auto\u0026\u0026 dfs, int k, int from, int to) { if (k \u003c 0) { return adj_matrix[from][to]; } return std::min(dfs(k - 1, from, to), dfs(k - 1, from, k) + dfs(k - 1, k, to)); }; // 3. 记录所有的多源最短路径 std::vector\u003cstd::vector\u003cint\u003e\u003e f(n, std::vector\u003cint\u003e(n, INF)); for (int i = 0; i \u003c n; i ++) { for (int j = 0; j \u003c n; j ++) { if (i == j) continue; f[i][j] = dfs(n - 1, i, j); } } // 4. 解题 int mn_idx = -1; int mn = n; for (int i = 0; i \u003c n; i ++) { int cnt = 0; for (int j = 0; j \u003c n; j ++) { if (f[i][j] \u003c= distanceThreshold) cnt ++; } if (cnt \u003c= mn) { mn = cnt; mn_idx = i; } } return mn_idx; } }; 复杂度分析： 时间复杂度： $O(V^23^V)$。需要求 $V^2$ 对最短路径，每个最短路径的递归树都是一颗满三叉树，因此每次递归树的节点个数为 $3^n$。 空间复杂度： $O(V^3)$ 记忆化搜索 上面的暴力递归的时间复杂度太高了，这是因为存在非常多的重复递归调用。 同时我们分析上面的递归函数，会发现这是一种非常特殊的递归函数：纯函数(pure function) 这种函数就和我们的数学函数一样：对于同样的输入，输出永远是一样的。这是因为我们在递归过程中，并未修改任何外部的变量，因此这种函数可以说是没有副作用的函数，和一个数学意义上的函数是等价的。 正是由于这种性质，所以我们可以记录下递归过程中的结果，这样再下一次碰到一样的时候，就可以直接得到结果了。 写成代码就是下面这样： class Solution { public: int findTheCity(int n, std::vector\u003cstd::vector\u003cint\u003e\u003e\u0026 edges, int distanceThreshold) { const int INF = 0x3f3f3f3f; // 构建邻接矩阵 std::vector\u003cstd::vector\u003cint\u003e\u003e adj_matrix(n, std::vector\u003cint\u003e(n, INF)); // 无穷大代表不可达 for (int i = 0; i \u003c edges.size(); i ++) { int from = edges[i][0], to = edges[i][1], w = edges[i][2]; adj_matrix[from][to] = w; adj_matrix[to][from] = w; } // 记忆化搜索： 获得从编号 from 到编号 to 的所有中间节点编号都 ≤k 的最短路的长度 std::vector memorized(n, std::vector(n, std::vector\u003cint\u003e(n, -INF))); // 无穷小代表没有搜索过 auto dfs = [\u0026](this auto\u0026\u0026 dfs, int k, int from, int to) { if (k \u003c 0) { return adj_matrix[from][to]; } // 如果之前没有搜索过，就递归计算一次并记录下来 if (memor","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:31:4","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"两点间最短路径 ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:31:5","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"模拟退火 ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:32:0","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"AcWing 3167. 星星还是树 题目描述 ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:32:1","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"3167. 星星还是树 在二维平面上有 $n$ 个点，第 $i$ 个点的坐标为 $(x_i,y_i)$。 请你找出一个点，使得该点到这 $n$ 个点的距离之和最小。 该点可以选择在平面中的任意位置，甚至与这 $n$ 个点的位置重合。 输入格式 第一行包含一个整数 $n$。 接下来 $n$ 行，每行包含两个整数 $x_i,y_i$，表示其中一个点的位置坐标。 输出格式 输出最小距离和，答案四舍五入取整。 数据范围 $1≤n≤100,$ $0≤x_i,y_i≤10000$ 输入样例： 4 0 0 0 10000 10000 10000 10000 0 输出样例： 28284 ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:32:2","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"爬山法 第四章 数学知识 ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:33:0","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"质数 ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:34:0","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"约数 ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:35:0","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"中国剩余定理 ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:36:0","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"求组合数 ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:37:0","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"容斥原理 ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:38:0","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"博弈论 第五章 动态规划 ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:39:0","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"DP问题初始化方式 （小于等于，等于，大于） dp[i]:表示当体积≤i的所有情况集合下的最大价值[如AcWing2. 01背包问题等] // dp[0] = 0; // 这种情况就是最基本的背包问题，无需特意初始化，只需要初值都是0就可以 ...... for (int j = m; j \u003e= v; j--) // 计算时严格保证任意状态下背包体积 \u003e= 0 { dp[j] = max(dp[j], dp[j - v] + w); } ...... cout \u003c\u003c dp[m] \u003c\u003c endl; // 最大值就是简单的dp[m] dp[i]:表示当体积==i的所有情况集合下的最大价值[如AcWing12. 背包问题求具体方案等] memset(dp, -0x3f, sizeof dp); // 初始化为∞（如果题目求max，就用-∞，求min，就用+∞） dp[0] = 0; // 对dp[0]作为起始点单独初始化,求最大价值就初始化为0，求方案数就初始化为1 ...... for (int j = m; j \u003e= v; j--) // 计算时严格保证任意状态下背包体积 \u003e= 0 { dp[j] = max(dp[j], dp[j - v] + w); } ...... int res = 0; // 注意这里是体积恰好为i的情况，所以最大值就不只是简单的dp[m] for (int i = 0; i \u003c= m; i++) res = max(res, dp[i]); // 需要一层循环求结果 cout \u003c\u003c res \u003c\u003c endl; dp[i]:表示当体积≥i的所有情况集合下的最小价值[如AcWing1020. 潜水员等] memset(dp, 0x3f, sizeof dp); // 初始化为∞（如果题目求max，就用+∞，求min，就用-∞） dp[0] = 0; // 对dp[0]作为起始点单独初始化,求最大价值就初始化为0，求方案数就初始化为1 ...... for (int j = m; j \u003e= 0; j--) // 计算时任意状态下背包的体积允许 \u003c 0 { dp[j][k] = min(dp[j][k], dp[max(0, j-v1)][max(0, k-v2)]+w); } ...... cout \u003c\u003c dp[m][n] \u003c\u003c endl; // 最大值需要自己判断，可能还是dp[m][n] ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:40:0","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"数字三角形模型 数字三角形模型应该算是dp中最简单的模型了 ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:41:0","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"AcWing 1018. 最低通行费 题目描述 一个商人穿过一个 $N×N$ 的正方形的网格，去参加一个非常重要的商务活动。 他要从网格的左上角进，右下角出。 每穿越中间 $1$ 个小方格，都要花费 $1$ 个单位时间。 商人必须在 $(2N−1)$ 个单位时间穿越出去。 而在经过中间的每个小方格时，都需要缴纳一定的费用。 这个商人期望在规定时间内用最少费用穿越出去。 请问至少需要多少费用？ 注意：不能对角穿越各个小方格（即，只能向上下左右四个方向移动且不能离开网格）。 输入格式 第一行是一个整数，表示正方形的宽度 $N$。 后面 $N$ 行，每行 $N$ 个不大于 $100$ 的正整数，为网格上每个小方格的费用。 输出格式 输出一个整数，表示至少需要的费用。 数据范围 $0\u003cN≤100$ 输入样例： 5 1 4 6 8 10 2 5 7 15 17 6 8 9 18 20 10 11 12 19 21 20 23 25 29 33 输出样例： 109 算法设计 这题说的看起来很复杂，商人必须在 $(2N−1)$ 个单位时间穿越出去，其实用贪心发现最快方式也就是每次只往右或者下走，时间正好是 $(2N−1)$ 所以这题其实就是一道数字三角形的简单模板 完整 C++ 代码 #include \u003ciostream\u003e #include \u003calgorithm\u003e #include \u003ccstring\u003e using namespace std; const int N = 110; int n; int w[N][N]; int dp[N][N]; int main() { cin \u003e\u003e n; for (int i = 1; i \u003c= n; i++) for (int j = 1; j \u003c= n; j++) cin \u003e\u003e w[i][j]; memset(dp, 0x3f, sizeof dp); // 求min就设置无穷大，方便后面就不用写if判断语句了 dp[0][1] = 0; for (int i = 1; i \u003c= n; i++) for (int j = 1; j \u003c= n; j++) dp[i][j] = w[i][j] + min(dp[i - 1][j], dp[i][j - 1]); cout \u003c\u003c dp[n][n] \u003c\u003c endl; return 0; } ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:41:1","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"最长上升子序列模型 ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:42:0","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"AcWing 895. 最长上升子序列 题目描述 给定一个长度为 $N$ 的数列，求数值严格单调递增的子序列的长度最长是多少。 输入格式 第一行包含整数 $N$。 第二行包含 $N$ 个整数，表示完整序列。 输出格式 输出一个整数，表示最大长度。 数据范围 $0\u003cN≤1000$ $−10^9≤$ 数列中的数 $≤109$ 输入样例： 7 3 1 2 1 8 5 6 输出样例： 4 算法设计 $f_i$ 表示所有以第 $i$ 个数结尾的上升子序列中的最大值 完整C++ 代码 #include \u003ciostream\u003e #include \u003calgorithm\u003e using namespace std; const int N = 1010; int a[N], dp[N]; int main() { int n; cin \u003e\u003e n; for (int i = 1; i \u003c= n; i++) cin \u003e\u003e a[i]; for (int i = 1; i \u003c= n; i++) { dp[i] = 1; for (int j = 1; j \u003c i; j++) { if (a[i] \u003e a[j]) dp[i] = max(dp[i], dp[j] + 1); } } int res = 0; for (int i = 1; i \u003c= n; i++) res = max(res, dp[i]); cout \u003c\u003c res \u003c\u003c endl; return 0; } ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:42:1","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"背包模型 ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:43:0","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"AcWing 2. 01背包问题 题目描述 ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:43:1","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"2. 01背包问题 有 $N$ 件物品和一个容量是 $V$ 的背包，每件物品只能使用一次。 第 $i$ 件物品的体积是 $v_i$，价值是 $w_i$。 求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。 输出最大价值。 输入格式 第一行两个整数, $N$，$V$，用空格隔开，分别表示物品数量和背包容积。 接下来有 $N$ 行，每行两个整数 $v_i$,$w_i$，用空格隔开，分别表示第 $i$ 件物品的体积和价值。 输出格式 输出一个整数，表示最大价值。 数据范围 $0\u003cN,V≤1000$ $0\u003cv_i,w_i≤1000$ 输入样例： 4 5 1 2 2 4 3 4 4 5 输出样例： 8 算法设计 背一下01背包的代码模板就行 完整 C++ 代码 #include \u003ciostream\u003e #include \u003calgorithm\u003e using namespace std; const int N = 1010; int v[N], w[N]; int dp[N][N]; int main() { int nn, vv; cin \u003e\u003e nn \u003e\u003e vv; for (int i = 1; i \u003c= nn; i ++) cin \u003e\u003e v[i] \u003e\u003e w[i]; for (int i = 1; i \u003c= nn; i ++) { for (int j = 1; j \u003c= vv; j ++) { // 如果没有将第i件物品装入背包 dp[i][j] = dp[i-1][j]; // 如果将第i件物品装入背包 if (j \u003e= v[i]) dp[i][j] = max(dp[i][j], dp[i-1][j-v[i]] + w[i]); } } cout \u003c\u003c dp[nn][vv] \u003c\u003c endl; } ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:43:2","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"AcWing 3. 完全背包问题 题目描述 ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:43:3","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"3. 完全背包问题 有 $N$ 件物品和一个容量是 $V$ 的背包，每种物品都有无限件可用。 第 $i$ 件物品的体积是 $v_i$，价值是 $w_i$。 求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。 输出最大价值。 输入格式 第一行两个整数, $N$，$V$，用空格隔开，分别表示物品数量和背包容积。 接下来有 $N$ 行，每行两个整数 $v_i$,$w_i$，用空格隔开，分别表示第 $i$ 件物品的体积和价值。 输出格式 输出一个整数，表示最大价值。 数据范围 $0\u003cN,V≤1000$ $0\u003cv_i,w_i≤1000$ 输入样例： 4 5 1 2 2 4 3 4 4 5 输出样例： 10 算法设计 背一下完全背包的代码模板就行 完整 C++ 代码 暴力版本 $O(n^3)$ #include \u003ciostream\u003e #include \u003calgorithm\u003e using namespace std; const int N = 1010; int v[N], w[N]; int dp[N][N]; int main() { int nn, vv; cin \u003e\u003e nn \u003e\u003e vv; for (int i = 1; i \u003c= nn; i ++) cin \u003e\u003e v[i] \u003e\u003e w[i]; for (int i = 1; i \u003c= nn; i ++) { for (int j = 1; j \u003c= vv; j ++) { // 如果没有将第i件物品装入背包 dp[i][j] = dp[i-1][j]; // 如果将第i件物品装入背包 for (int k = 1; k * v[i] \u003c= j; k ++) dp[i][j] = max(dp[i][j], dp[i-1][j-k*v[i]] + k*w[i]); } } cout \u003c\u003c dp[nn][vv] \u003c\u003c endl; } 优化后 $O(n^2)$ #include \u003ciostream\u003e #include \u003calgorithm\u003e using namespace std; const int N = 1010; int v[N], w[N]; int dp[N][N]; int main() { int nn, vv; cin \u003e\u003e nn \u003e\u003e vv; for (int i = 1; i \u003c= nn; i ++) cin \u003e\u003e v[i] \u003e\u003e w[i]; for (int i = 1; i \u003c= nn; i ++) { for (int j = 1; j \u003c= vv; j ++) { // 如果没有将第i件物品装入背包 dp[i][j] = dp[i-1][j]; // 如果将第i件物品装入背包 // dp[i][j] = j, j - v + w, j - 2v + 2w, j - 3v + 3w, ... // = (j - v) + w, (j - v) - v + 2w, (j - v) - 2v + 3w, ... // = dp[i][j - v] + w if (j \u003e= v[i]) dp[i][j] = max(dp[i][j], dp[i][j-v[i]] + w[i]); } } cout \u003c\u003c dp[nn][vv] \u003c\u003c endl; } ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:43:4","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"AcWing 4. 多重背包问题 I 题目描述 有 $N$ 种物品和一个容量是 $V$ 的背包。 第 $i$ 种物品最多有 $s_i$ 件，每件体积是 $v_i$，价值是 $w_i$。 求解将哪些物品装入背包，可使物品体积总和不超过背包容量，且价值总和最大。 输出最大价值。 输入格式 第一行两个整数，$N$, $V$，用空格隔开，分别表示物品种数和背包容积。 接下来有 $N$ 行，每行三个整数 $v_i$, $w_i$, $s_i$，用空格隔开，分别表示第 $i$ 种物品的体积、价值和数量。 输出格式 输出一个整数，表示最大价值。 数据范围 $0\u003cN,V≤100$ $0\u003cv_i, w_i, s_i≤100$ 输入样例： 4 5 1 2 3 2 4 1 3 4 3 4 5 2 输出样例： 10 算法设计 背一下完全背包的代码模板就行，这题的数据来看时间复杂度 $O(n^3)$ 就可以ac 完整 C++ 代码 #include \u003ciostream\u003e #include \u003calgorithm\u003e using namespace std; const int N = 1010; int v[N], w[N], s[N]; int dp[N][N]; int main() { int nn, vv; cin \u003e\u003e nn \u003e\u003e vv; for (int i = 1; i \u003c= nn; i ++) cin \u003e\u003e v[i] \u003e\u003e w[i] \u003e\u003e s[i]; for (int i = 1; i \u003c= nn; i ++) { for (int j = 1; j \u003c= vv; j ++) { // 如果没有将第i件物品装入背包 dp[i][j] = dp[i-1][j]; // 如果将第i件物品装入背包 for (int k = 1; k * v[i] \u003c= j \u0026\u0026 k \u003c= s[i]; k ++) dp[i][j] = max(dp[i][j], dp[i-1][j-k*v[i]] + k*w[i]); } } cout \u003c\u003c dp[nn][vv] \u003c\u003c endl; } ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:43:5","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"AcWing 5. 多重背包问题 II 题目描述 有 $N$ 种物品和一个容量是 $V$ 的背包。 第 $i$ 种物品最多有 $s_i$ 件，每件体积是 $v_i$，价值是 $w_i$。 求解将哪些物品装入背包，可使物品体积总和不超过背包容量，且价值总和最大。 输出最大价值。 输入格式 第一行两个整数，$N$, $V$，用空格隔开，分别表示物品种数和背包容积。 接下来有 $N$ 行，每行三个整数 $v_i$, $w_i$, $s_i$，用空格隔开，分别表示第 $i$ 种物品的体积、价值和数量。 输出格式 输出一个整数，表示最大价值。 数据范围 $0\u003cN≤1000$ $0\u003cV≤2000$ $0\u003cv_i, w_i, s_i≤2000$ 提示： 本题考查多重背包的二进制优化方法。 输入样例： 4 5 1 2 3 2 4 1 3 4 3 4 5 2 输出样例： 10 算法设计 一个非常简洁的二进制优化自用板子 根据y总讲的AcWing7. 混合背包问题整理的板子，相当简洁还省空间 空间复杂度无需$O(n \\log n)$,降为$O(max(n, log s))$ 时间复杂度还是$O(n^2log n)$ 完整 C++ 代码 #include \u003ciostream\u003e using namespace std; const int N = 2010; int dp[N]; int main() { int n, m; cin \u003e\u003e n \u003e\u003e m; for (int i = 1; i \u003c= n; i++) { int v, w, s; cin \u003e\u003e v \u003e\u003e w \u003e\u003e s; for (int k = 1; k \u003c= s; k *= 2) // 把s拆成二进制形式，如 10 = 2^0 + 2^1 + 2^2 + 3 { for (int j = m; j \u003e= k * v; j--) // 对上面的分开形式进行01背包 { dp[j] = max(dp[j], dp[j - k * v] + k * w); } s -= k; } if (s) { // 处理刚刚拆开的二进制的最后一位 for (int j = m; j \u003e= s * v; j--) { dp[j] = max(dp[j], dp[j - s * v] + s * w); } } } cout \u003c\u003c dp[m] \u003c\u003c endl; return 0; } ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:43:6","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"状态机模型 ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:44:0","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"AcWing 1058. 股票买卖 V 题目描述 给定一个长度为 $N$ 的数组，数组中的第 $i$ 个数字表示一个给定股票在第 $i$ 天的价格。 设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）: 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。 卖出股票后，你无法在第二天买入股票 (即冷冻期为 $1$ 天)。 输入格式 第一行包含整数 $N$，表示数组长度。 第二行包含 $N$ 个不超过 $10000$ 的正整数，表示完整的数组。 输出格式 输出一个整数，表示最大利润。 数据范围 $1≤N≤10^5$ 输入样例： 5 1 2 3 0 2 输出样例： 3 算法设计 状态分为：1. 手中有货，2. 手中无货的第 $1$ 天，3. 手中无货的第 $\\ge2$ 天 完整C++ 代码 #include \u003ciostream\u003e #include \u003ccstring\u003e using namespace std; const int N = 100010, INF = 0x3f3f3f3f; int dp[N][3]; // dp[i][0]:有货, dp[i][1]:手中无货的第1天, dp[i][2]:手中无货的第≥2天 int main() { int n; cin \u003e\u003e n; memset(dp, -0x3f, sizeof dp); dp[0][2] = 0; for (int i = 1; i \u003c= n; i++) { int w; cin \u003e\u003e w; dp[i][0] = max(dp[i - 1][0], dp[i - 1][2] - w); dp[i][1] = dp[i - 1][0] + w; dp[i][2] = max(dp[i - 1][2], dp[i - 1][1]); } cout \u003c\u003c max(dp[n][1], dp[n][2]) \u003c\u003c endl; return 0; } ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:44:1","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"状态压缩DP ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:45:0","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"AcWing 1064. 小国王 题目描述 ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:45:1","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"1064. 小国王 在 $n×n$ 的棋盘上放 $k$ 个国王，国王可攻击相邻的 $8$ 个格子，求使它们无法互相攻击的方案总数。 输入格式 共一行，包含两个整数 $n$ 和 $k$ 。 输出格式 共一行，表示方案总数，若不能够放置则输出$0$。 数据范围 $1 \\le n \\le10$, $0 \\le k \\le n^2$ 输入样例： 3 2 输出样例： 16 算法设计 这是收录的一道经典的**连通性状态压缩 $\\text{DP}$ **。 这里的状态压缩，其实指的就是二进制状态压缩，是指将一个长度为 $m$ 的 $\\text{bool}$ 数组只需要用一个 $m$ 位的二进制整数表示并存储即可。这里当 $m \u003c 32$ 时，可以直接用一个 $\\text{int}$ 来存储，如果 $m$ 较大，就需要使用 $\\text{int}$ 数组或者 $\\text{C++\\ STL}$ 提供的 $\\text{bitset}$。 $f(i,j,s)$:所有只摆在前$i$行，已经摆了$j$个国王，并且第$i$行摆放的状态是$s$的所有方案的集合。 首先我们来看看暴力一点的做法，虽然我们提前对符合条件的值进行了预处理，但是依旧会超时。因为我们最后还是在最后状态转移阶段还是在遍历每一个二进制数，虽然判断其合法性的操作提前进行了预处理来降低了部分时间复杂度，但是依旧需要$O(N \\times K \\times 2^n \\times 2^n)$,在这一题大概是$10^9$,会超时。 暴力做法 C++ 代码 #include \u003ciostream\u003e #include \u003ccstring\u003e using namespace std; const int N = 12, M = N * N, S = 1 \u003c\u003c N; int dp[N][M][S]; bool st[S]; int cnt[S]; int main() { int n, m; cin \u003e\u003e n \u003e\u003e m; dp[0][0][0] = 1; for (int i = 0; i \u003c 1 \u003c\u003c n; i++) { st[i] = true; int num = 0; for (int u = 0; u \u003c n; u++) { if (i \u003e\u003e u \u0026 1) { num++; if (num \u003e 1) st[i] = false; } else num = 0; } if (num \u003e 1) st[i] = false; } for (int i = 0; i \u003c 1 \u003c\u003c n; i++) { for (int u = 0; u \u003c n; u++) { if (i \u003e\u003e u \u0026 1) cnt[i]++; } } for (int i = 1; i \u003c= n; i++) { for (int j = 0; j \u003c= m; j++) { for (int k = 0; k \u003c 1 \u003c\u003c n; k++) { for (int u = 0; u \u003c 1 \u003c\u003c n; u++) { if (k \u0026 u) continue; if (!st[k | u]) continue; if (cnt[k] \u003c= j) dp[i][j][k] += dp[i - 1][j - cnt[k]][u]; } } } } int res = 0; for (int i = 0; i \u003c 1 \u003c\u003c n; i++) res += dp[n][m][i]; cout \u003c\u003c res \u003c\u003c endl; return 0; } 进一步思考：如果我们把所有可能符合的值在预处理阶段存下来，那么我们在最终状态转移的时候，岂不是其实只需要在这些值里进行遍历，那么时间复杂度就可以进一步降低。 优化版本 C++ 代码 #include \u003ciostream\u003e #include \u003ccstring\u003e #include \u003cvector\u003e using namespace std; const int N = 12, S = N * N, M = 1 \u003c\u003c N; int n, m; long long dp[N][S][M]; int cnt[M]; vector\u003cint\u003e state; vector\u003cint\u003e head[M]; bool check(int state) { for (int u = 0; u \u003c n; u++) { if ((state \u003e\u003e u \u0026 1) \u0026\u0026 (state \u003e\u003e u + 1 \u0026 1)) return false; } return true; } int count(int state) { int res = 0; for (int u = 0; u \u003c n; u++) if (state \u003e\u003e u \u0026 1) res++; return res; } int main() { cin \u003e\u003e n \u003e\u003e m; dp[0][0][0] = 1; for (int i = 0; i \u003c 1 \u003c\u003c n; i++) { if (check(i)) { state.push_back(i); // 预处理出来所有的不存在连续两个1的可能情况，后续只对这些情况进行循环 cnt[i] = count(i); // 预处理出1的个数 } } for (int i = 0; i \u003c state.size(); i++) { for (int j = 0; j \u003c state.size(); j++) { int a = state[i]; int b = state[j]; if ((a \u0026 b) == 0 \u0026\u0026 check(a | b)) // ！！！:这里写成if ((a \u0026 b == 0) \u0026\u0026 check(a | b))是错误的，因为优先级 { head[a].push_back(b); } } } for (int i = 1; i \u003c= n; i++) { for (int j = 0; j \u003c= m; j++) { for (int a = 0; a \u003c state.size(); a++) { for (int b = 0; b \u003c head[state[a]].size(); b++) { int c = cnt[state[a]]; if (j \u003e= c) dp[i][j][state[a]] += dp[i - 1][j - c][head[state[a]][b]]; } } } } long long res = 0; for (int i = 0; i \u003c 1 \u003c\u003c n; i++) res += dp[n][m][i]; cout \u003c\u003c res \u003c\u003c endl; // 或是更简单的在上一步循环时到 i\u003c=n+1 结束，此时 res=dp[n+1][0]; return 0; } ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:45:2","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"AcWing 91. 最短Hamilton路径 题目描述 ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:45:3","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"91. 最短Hamilton路径 给定一张 $n$ 个点的带权无向图，点从 $0∼n−1$ 标号，求起点 $0$ 到终点 $n−1$ 的最短 Hamilton 路径。 Hamilton 路径的定义是从 $0$ 到 $n−1$ 不重不漏地经过每个点恰好一次。 输入格式 第一行输入整数 $n$。 接下来 $n$ 行每行 $n$ 个整数，其中第 $i$ 行第 $j$ 个整数表示点 $i$ 到 $j$ 的距离（记为 $a[i,j]$）。 对于任意的 $x,y,z$，数据保证 $a[x,x]=0，a[x,y]=a[y,x]$ 并且 $a[x,y]+a[y,z]≥a[x,z]$。 输出格式 输出一个整数，表示最短 Hamilton 路径的长度。 数据范围 $1≤n≤20$ $0≤a[i,j]≤10^7$ 输入样例： 5 0 2 4 5 1 2 0 6 5 3 4 6 0 8 3 5 5 8 0 5 1 3 3 5 0 输出样例： 18 算法设计 这是收录的一道经典的集合类状态压缩 $\\text{DP}$。 完整 C++ 代码 ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:45:4","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"区间DP ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:46:0","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"AcWing 282. 石子合并 题目描述 282. 石子合并 设有 $N$ 堆石子排成一排，其编号为 $1,2,3,…,N$。 每堆石子有一定的质量，可以用一个整数来描述，现在要将这 $N$ 堆石子合并成为一堆。 每次只能合并相邻的两堆，合并的代价为这两堆石子的质量之和，合并后与这两堆石子相邻的石子将和新堆相邻，合并时由于选择的顺序不同，合并的总代价也不相同。 例如有 $4$ 堆石子分别为 1 3 5 2， 我们可以先合并 $1、2$ 堆，代价为 $4$，得到 4 5 2， 又合并 $1、2$ 堆，代价为 $9$，得到 9 2 ，再合并得到 $11$，总代价为 $4+9+11=24$； 如果第二步是先合并 $2、3$堆，则代价为 $7$，得到 4 7，最后一次合并代价为 $11$，总代价为 $4+7+11=22$。 问题是：找出一种合理的方法，使总的代价最小，输出最小代价。 输入格式 第一行一个数 $N$ 表示石子的堆数 $N$。 第二行 $N$ 个数，表示每堆石子的质量(均不超过 $1000$)。 输出格式 输出一个整数，表示最小代价。 数据范围 $1≤n≤300$ 输入样例： 4 1 3 5 2 输出样例： 22 算法设计 这是区间 $\\text{DP}$ 的一道经典的模板题，一般有两种解法： 迭代式：适合对于一维的情况 for (int len = 2; len \u003c= n; len++) // 一般就是先枚举区间长度len for (int L = 1; L + len - 1 \u003c= n; L++) // 然后枚举左端点 { R = L + len - 1; // 就可以推出右端点 } 记忆化搜索：主要针对二维及以上的情况 对于此题来说，$f_{i,j}$ 表示所有将 $[i, j]$ 这个区间中的石子合并成一堆的方案的所有集合中的最小代价。 如果直接对 $i, j$ 进行从 $1∼n$ 进行迭代的话是错误的，因为这里的状态转移过程是将左右两堆已经合并好的合并成一个大堆，所以得先合并小堆。 所以区间 $ \\text{DP}$ 这里比较特殊，我们对区间长度 $\\text{len}$ 进行遍历，这样大区间就会依赖于小区间计算出来的结果。 完整C++ 代码 #include \u003ciostream\u003e #include \u003ccstring\u003e using namespace std; const int N = 310, INF = 0x3f3f3f3f; int n; int s[N], dp[N][N]; int main() { cin \u003e\u003e n; for (int i = 1; i \u003c= n; i++) { cin \u003e\u003e s[i]; s[i] += s[i - 1]; } for (int len = 2; len \u003c= n; len++) for (int l = 1; l + len - 1 \u003c= n; l++) { int r = l + len - 1; dp[l][r] = INF; for (int d = l; d + 1 \u003c= r; d++) // 假设将区间划分成[l, d] 和 [d + 1, r] { dp[l][r] = min(dp[l][r], dp[l][d] + dp[d + 1][r] + (s[r] - s[l - 1])); } } // 或者下面初始化写法: // memset(dp, INF, sizeof dp); // for (int len = 1; len \u003c= n; len++) // for (int l = 1; l + len - 1 \u003c= n; l++) // { // int r = l + len - 1; // if (len == 1) dp[l][r] = 0; // 长度为1不需要代价 // else // { // for (int d = l; d + 1 \u003c= r; d++) // 假设将区间划分成[l, d] 和 [d + 1, r] // dp[l][r] = min(dp[l][r], dp[l][d] + dp[d + 1][r] + (s[r] - s[l - 1])); // } // } cout \u003c\u003c dp[1][n] \u003c\u003c endl; } 拓展 本题其实是还有一道变式 ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:46:1","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"320. 能量项链 题目描述 在 $\\text{Mars}$ 星球上，每个 $\\text{Mars}$ 人都随身佩带着一串能量项链，在项链上有 $N$ 颗能量珠。 能量珠是一颗有头标记与尾标记的珠子，这些标记对应着某个正整数。 并且，对于相邻的两颗珠子，前一颗珠子的尾标记一定等于后一颗珠子的头标记。 因为只有这样，通过吸盘（吸盘是 $\\text{Mars}$ 人吸收能量的一种器官）的作用，这两颗珠子才能聚合成一颗珠子，同时释放出可以被吸盘吸收的能量。 如果前一颗能量珠的头标记为 $m$，尾标记为 $r$，后一颗能量珠的头标记为 $r$，尾标记为 $n$，则聚合后释放的能量为 $m×r×n$（$\\text{Mars}$ 单位），新产生的珠子的头标记为 $m$，尾标记为 $n$。 需要时，$\\text{Mars}$ 人就用吸盘夹住相邻的两颗珠子，通过聚合得到能量，直到项链上只剩下一颗珠子为止。 显然，不同的聚合顺序得到的总能量是不同的，请你设计一个聚合顺序，使一串项链释放出的总能量最大。 例如：设 $N=4$，$4$ 颗珠子的头标记与尾标记依次为 $(2，3)(3，5)(5，10)(10，2)$。 我们用记号 $⊕$ 表示两颗珠子的聚合操作，$(j⊕k)$ 表示第 $j$，$k$ 两颗珠子聚合后所释放的能量。则第 $4、1$ 两颗珠子聚合后释放的能量为：$(4⊕1)=10×2×3=60$。 这一串项链可以得到最优值的一个聚合顺序所释放的总能量为 $((4⊕1)⊕2)⊕3)=10×2×3+10×3×5+10×5×10=710$。 输入格式 输入的第一行是一个正整数 $N$，表示项链上珠子的个数。 第二行是 $N$ 个用空格隔开的正整数，所有的数均不超过 $1000$，第 $i$ 个数为第 $i$ 颗珠子的头标记，当 $i\u003cN$ 时，第 $i$ 颗珠子的尾标记应该等于第 $i+1$ 颗珠子的头标记，第 $N$ 颗珠子的尾标记应该等于第 $1$ 颗珠子的头标记。 至于珠子的顺序，你可以这样确定：将项链放到桌面上，不要出现交叉，随意指定第一颗珠子，然后按顺时针方向确定其他珠子的顺序。 输出格式 输出只有一行，是一个正整数 $E$，为一个最优聚合顺序所释放的总能量。 数据范围 $4≤N≤100$, $1≤E≤2.1×10^9$ 输入样例： 4 2 3 5 10 输出样例： 710 算法设计 这题主要的变化在两个部分： 环形合并 这一题咋一看就和石子合并这一题基本一样，但是是个环形，所以这题可以简单思考为如何断链成一排石子。 很朴素的想法是，枚举每一个可能的断链点，如 $1,2…n$, 然后分别使用石子合并模板。 不好的消息是这种做法的时间复杂度是 $O(n^4)$, 这题给的 $n$ 范围在 $200$ 以内，会 $\\text{TLE}$。 此题的通解是： $$ \\begin{matrix} 1\\ \\underbrace{ 2\\ \\ 3\\dots \\ n\\ \\ 1}\\ 2\\dots n \\ len=n \\to \\text{可以看作是环在 1,2 处断链} \\end{matrix} $$ ​ 即我们只需要构造一个长度为 $2n$ 的石子合并问题即可，后面 $n$ 堆的石子和前面 $n$ 堆石子完全一样，直接使用石子合并模板对这 $2n$ 堆石子进行求 $\\max$ 和 $\\min$ 即可。时间复杂度也从 $O(n^4)$ 降到 $O(n^3)$。 聚合操作 这里的聚合操作不是简单的石子合并了，有点像矩阵的味道。 对于样例，$(2，3)(3，5)(5，10)(10，2)\\to2,\\ 3,\\ 5,\\ 10,\\ 2$ 将这 $4$ 颗能量珠抽象为 $5$ 个数，然后对这 $5$ 个数套用石子合并模板。 注意这里状态计算的时候，和石子合并不同，石子合并是将 $[l,r]$ 分成 $[l,d]$ 和 $[d+1, r]$ 两个区间；但是这里是划分成$[l,d]$ 和 $[d, r]$ 两个区间,这里的划分点 $d$ 是共用的: $$ \\begin{matrix} \\underbrace{ 2,\\ 3,} \\underbrace{ \\ 5,\\ 10,\\ 2} \\ [2,3]\\ \\ \\ \\ [3,2] \\end{matrix} $$ 以及这里的区间长度最少从 $3$ 开始，因为 $\\text{len}=2$ 时只是一颗能量珠，不需要合并，可以省去一次判断。 以及最终的区间长度应该是 $n+1$。 完整C++代码 #include \u003ciostream\u003e using namespace std; const int N = 300; int n; int w[N], dp[N][N]; int main() { cin \u003e\u003e n; for (int i = 1; i \u003c= n; i++) { cin \u003e\u003e w[i]; w[i + n] = w[i]; } for (int len = 3; len \u003c= n + 1; len++) // 注意这里len得从3开始，且取到n+1 for (int l = 1; l + len - 1 \u003c= n * 2; l++) { int r = l + len - 1; for (int d = l + 1; d \u003c r; d++) { dp[l][r] = max(dp[l][r], dp[l][d] + dp[d][r] + w[l] * w[d] * w[r]); } } int res = 0; for (int i = 1; i \u003c= n; i++) { int j = i + n; // 注意这里是因为区间长度为n+1 res = max(res, dp[i][j]); } cout \u003c\u003c res \u003c\u003c endl; return 0; } ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:46:2","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"AcWing 479. 加分二叉树 题目描述 ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:46:3","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"479. 加分二叉树 设一个 $n$ 个节点的二叉树 tree 的中序遍历为（$1,2,3,…,n$），其中数字 $1,2,3,…,n$ 为节点编号。 每个节点都有一个分数（均为正整数），记第 $i$ 个节点的分数为 $d_i$，tree 及它的每个子树都有一个加分，任一棵子树 subtree（也包含 tree 本身）的加分计算方法如下： subtree 的左子树的加分 $×$ subtree 的右子树的加分 $+$ subtree 的根的分数 若某个子树为空，规定其加分为 $1$。 叶子的加分就是叶节点本身的分数，不考虑它的空子树。 试求一棵符合中序遍历为（$1,2,3,…,n$）且加分最高的二叉树 tree。 要求输出： （1）tree 的最高加分 （2）tree 的前序遍历 输入格式 第 $1$ 行：一个整数 $n$，为节点个数。 第 $2$ 行：$n$ 个用空格隔开的整数，为每个节点的分数（$0\u003c$分数$\u003c100$）。 输出格式 第 $1$ 行：一个整数，为最高加分（结果不会超过int范围）。 第 $2$ 行：$n$ 个用空格隔开的整数，为该树的前序遍历。如果存在多种方案，则输出字典序最小的方案。 数据范围 $n\u003c30$ 输入样例： 5 5 7 1 2 10 输出样例： 145 3 1 2 4 5 算法设计 这里选这题作为模板是因为这是一道求区间 $\\text{DP}$ 具体方案的题目，和之前的石子合并求最大最小代价是不一样的。 求区间 $\\text{DP}$ 具体方案的通用做法是： 通过使用 $g_{i,j}$ 记录区间 $[i,j]$ 中最大价值时的划分点 $d$ ，在使用完区间合并模板后，只需要使用一次 $\\text{dfs}$ 即可找到每一次最大价值的划分点。 完整C++ 代码 #include \u003ciostream\u003e #include \u003ccstring\u003e #include \u003calgorithm\u003e using namespace std; const int N = 50, INF = 0x3f3f3f3f; int n; int w[N]; int dp[N][N], g[N][N]; void dfs(int l, int r) { if (l \u003e r) return; int d = g[l][r]; cout \u003c\u003c d \u003c\u003c \" \"; dfs(l, d - 1); dfs(d + 1, r); } int main() { cin \u003e\u003e n; for (int i = 1; i \u003c= n; i++) cin \u003e\u003e w[i]; memset(dp, -INF, sizeof dp); for (int len = 1; len \u003c= n; len++) for (int l = 1; l + len - 1 \u003c= n; l++) { int r = l + len - 1; if (len == 1) // 这题因为对len=1情况特殊规定了，所以得使用模板的第2种写法 { dp[l][r] = w[l]; g[l][r] = l; } else for (int d = l; d \u003c= r; d++) { int left = dp[l][d - 1], right = dp[d + 1][r]; if (d == l) // 题目种 left = 1; if (d == r) right = 1; if (dp[l][r] \u003c left * right + w[d]) { dp[l][r] = left * right + w[d]; g[l][r] = d; } } } cout \u003c\u003c dp[1][n] \u003c\u003c endl; dfs(1, n); return 0; } ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:46:4","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"树形DP ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:47:0","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"AcWing 1072. 树的最长路径 题目描述 ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:47:1","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"1072. 树的最长路径 给定一棵树，树中包含 $n$ 个结点（编号$1∼n$）和 $n−1$ 条无向边，每条边都有一个权值。 现在请你找到树中的一条最长路径。 换句话说，要找到一条路径，使得使得路径两端的点的距离最远。 注意：路径中可以只包含一个点。 输入格式 第一行包含整数 $n$。 接下来 $n−1$ 行，每行包含三个整数 $a_i,b_i,c_i$，表示点 $a_i$ 和 $b_i$ 之间存在一条权值为 $c_i$ 的边。 输出格式 输出一个整数，表示树的最长路径的长度。 数据范围 $1≤n≤10000$, $1≤ai,bi≤n$, $−10^5≤ci≤10^5$ 输入样例： 6 5 1 6 1 4 5 6 3 9 2 6 8 6 1 7 输出样例： 22 算法设计 首先我们先来证明图论中的一个经典结论：对于没有负边权的树，如何找树的直径？ 任取一点作为起点，找到距离该点最远的一个点 $u$。 再找到距离 $u$ 最远的一点 $v$。 此时 $uv$ 就是我们要找的一条直径。 也即我们只需要使用两次 $\\text{BFS}$ 在$O(n)$的时间复杂度里便可找到我们需要的直径。 下面我们对这个经典结论进行证明： 其实这个证明等价于证明 $1$ 中我们所找到的 $u$ 是某条直径的一个端点。 我们假设任意选取的一个起点为 $a$，反证法假设 $u$ 不是任意一条直径的一条端点，我们假设有一条直径 $bc$。 $bc$ 和 $au$ 没有交点。由于树的定义，这两条线一定是连通的，我们假设 $au$ 中存在一点 $x$ 与 $bc$ 中的 $y$ 存在一条路径 $xy$。根据定义 $u$ 是我们找到的距离 $a$ 最远的一个点，易得 $xu \\ge xy+yc$，所以 $xu+xy \\ge yc$，故 $byxu \\ge byc$，又由 $byc$ 是直径，所以 $byxu$ 一定也是直径，所以 $u$ 一定是直径的一个端点。 $bc$ 和 $au$ 没有交点。我们假设交点为 $x$，即我们有 $bxc$ 和 $axu$ 两条直线。根据定义 $u$ 是我们找到的距离 $a$ 最远的一个点，易得 $xu \\ge xc$，所以 $bxu \\ge bxc$，又由 $bxc$ 是直径，所以 $bxu$ 一定也是直径，所以 $u$ 一定是直径的一个端点。 综上所述，$u$ 一定是某条直径的一个端点。 对于本题来说，边权可以为负，故证明中的第一种情况里的由 $xu \\ge xy+yc$ 便推不出 $xu+xy \\ge yc$ 来了，所以两次 $\\text{BFS}$ 无法得到我们要的直径了。所以我们需要使用更一般的方法：树形 DP 来求解此题。 本质上 DP 只是对暴搜的一种优化：减少重复计算。 这里就是通过将所有路径的值存到这条路径所经过的所有点中最高的那个点里，下面我们该如何更新经过每个点的路径的最大值呢？ 我们将这个问题抽象出一个一般模型，如图所示，假设我们需要求出经过点 $u$ 的路径的最大值？ 我们可以通过 $\\text{DFS}$ 的返回值来分别得到点 $u$ 在子树 $1,2,3$ 中的往下走的一个最大的路径长度，然后通过 $d_i=s_i+w_i$ 便可得到这些子树上的经过 $u$ 的最长路径 $d_i$，然后通过统计出这些最长路径中的最大值 $m_1$ 和次大值 $m_2$（需要 $\u003e0$），$m_1 + m_2$ 就是我们要求的经过点 $u$ 的路径的最大值。 这里求最大值 $m_1$ 和次大值 $m_2$ 可以使用一个技巧： $m_1, m_2$ 初值设置为 $0$（可以保证后续更新后的 $m_1,m_2$ 也是 $\u003e0$ 的）。 如果每次算出来的 $d \\ge m_1$，我们就令 $m_2 = m_1$，$m_1 = d$。（这里更新顺序不能反） 如果每次算出来的 $d \u003c m_1$，但是 $d \u003em_2$，我们就令 $m_2=d$。 以及这里使用了 $\\text{st}$ 数组来确保每个点只走一次，有种 DP 减少重复计算的味道在里面。 完整 C++ 代码 这里我们可以通过每次 dfs 的时候传入一个 father 来避免递归回节点本身，下面代码便是这种写法 #include \u003ciostream\u003e #include \u003ccstring\u003e #include \u003calgorithm\u003e using namespace std; const int N = 10010, M = N * 2; int n; int h[N], w[M], e[M], ne[M], idx; int ans; void add(int a, int b, int c) { e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++; } // 返回过根节点的最长路径 int dfs(int u, int father) // 传入father来避免回头 { int m1 = 0, m2 = 0; for (int i = h[u]; i != -1; i = ne[i]) { int j = e[i]; if (j == father) continue; // 如果回头了，就退出 int d = dfs(j, u)+ w[i]; if (d \u003e= m1) m2 = m1, m1 = d; // 注意这里不能m1 = d, m2 = m1, else if (d \u003e m2) m2 = d; } ans = max(ans, m1 + m2); return m1; } int main() { cin \u003e\u003e n; for (int i = 1; i \u003c= n; i++) h[i] = -1; for (int i = 1; i \u003c n; i++) { int a, b, c; cin \u003e\u003e a \u003e\u003e b \u003e\u003e c; add(a, b, c); add(b, a, c); } dfs(1, -1); // 初始时没有父节点，就传入-1表示 cout \u003c\u003c ans \u003c\u003c endl; return 0; } 当然也可以仿造我们第三章树与图这章的写法，使用 $\\text{st}$ 数组来防止走回头路： #include \u003ciostream\u003e #include \u003ccstring\u003e #include \u003calgorithm\u003e using namespace std; const int N = 10010, M = N * 2; int n; int h[N], w[M], e[M], ne[M], idx; bool st[N]; int ans; void add(int a, int b, int c) { e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++; } // 返回过根节点的最长路径 int dfs(int u) { st[u] = true; int m1 = 0, m2 = 0; for (int i = h[u]; i != -1; i = ne[i]) { int j = e[i]; if (!st[j]) { int d = dfs(j)+ w[i]; if (d \u003e= m1) m2 = m1, m1 = d; // 注意这里不能m1 = d, m2 = m1, else if (d \u003e m2) m2 = d; } } ans = max(ans, m1 + m2); return m1; } int main() { cin \u003e\u003e n; for (int i = 1; i \u003c= n; i++) h[i] = -1; for (int i = 1; i \u003c n; i++) { int a, b, c; cin \u003e\u003e a \u003e\u003e b \u003e\u003e c; add(a, b, c); add(b, a, c); } dfs(1); cout \u003c\u003c ans \u003c\u003c endl; return 0; } 拓展 刚刚的一道题其实是利用子节点信息去逐步更新父节点信息，但是还有一些更变态的题目还需要再利用父节点信息去更新子节点信息，我们一起来看看下面收录的这道题吧。 ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:47:2","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"1073. 树的中心 给定一棵树，树中包含 n 个结点（编号11~nn）和 n−1n−1 条无向边，每条边都有一个权值。 请你在树中找到一个点，使得该点到树中其他结点的最远距离最近。 输入格式 第一行包含整数 nn。 接下来 n−1n−1 行，每行包含三个整数 ai,bi,ciai,bi,ci，表示点 aiai 和 bibi 之间存在一条权值为 cici 的边。 输出格式 输出一个整数，表示所求点到树中其他结点的最远距离。 数据范围 1≤n≤100001≤n≤10000, 1≤ai,bi≤n1≤ai,bi≤n, 1≤ci≤1051≤ci≤105 输入样例： 5 2 1 1 3 2 1 4 3 1 5 1 1 输出样例： 2 算法设计 y总在树形依赖 DP 这一块讲的不太行。我在知乎上也看到了有人说教材选自2017年的蓝书有点落伍了，一次这里的解法有点落后了，所以就不进行更新了，以后有时间再看看其他更新的视频来更新这里【插个眼】 完整 C++ 代码 xxx ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:47:3","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"数位DP ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:48:0","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"AcWing 1082. 数字游戏 题目描述 ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:48:1","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"1082. 数字游戏 科协里最近很流行数字游戏。 某人命名了一种不降数，这种数字必须满足从左到右各位数字呈非下降关系，如 $123$，$446$。 现在大家决定玩一个游戏，指定一个整数闭区间 $[a,b]$，问这个区间内有多少个不降数。 **注意：**不降数不能包含前导零。 输入格式 输入包含多组测试数据。 每组数据占一行，包含两个整数 $a$ 和 $b$。 输出格式 每行给出一组测试数据的答案，即 $[a,b]$ 之间有多少不降数。 数据范围 $1≤a≤b≤2^{31}−1$ 输入样例： 1 9 1 19 输出样例： 9 18 算法设计 数位 $\\text{DP}$ 常用思考方式： 利用前缀的思想：$[x,y] = f_y-f_{x-1}$ 从树的角度来考虑 image-20241218222708268 下面给出一般性的数位 $\\text{DP}$ 的模板： const int N = 15; int K, B; int dp[N][N]; void init() // 提前预处理一些信息 { // 如组合数等 } int count(int n) { if (!n) return 1; // 特判边界，这里可能是0或者1，依具体题目而定 vector\u003cint\u003e nums; while (n) nums.push_back(n % B), n /= B; int res = 0; // 最终结果 int last = 0; // 一些前缀信息:不用问题含义不一样 for (int i = nums.size() - 1; i \u003e= 0; i--) // 从最高位往最低位枚举 { int x = nums[i]; // 具体计算 // ... if (i == 0 \u0026\u0026 xxxxxx) res += 1; // 特判一下上面图片中最右下角的a0 last = xxx; // 更新 } return res; } int main() { init(); int l, r; cin \u003e\u003e l \u003e\u003e r \u003e\u003e K \u003e\u003e B; cout \u003c\u003c count(r) - count(l - 1) \u003c\u003c endl; } 完整 C++ 代码 #include \u003ciostream\u003e #include \u003cvector\u003e using namespace std; const int N = 15; int dp[N][N]; // f[i,j]表示一共有i位且最高数为j的不降数的个数 void init() { for (int j = 0; j \u003c= 9; j ++) dp[1][j] = 1; for (int i = 2; i \u003c N; i ++) for (int j = 0; j \u003c= 9; j ++) for (int k = j; k \u003c= 9; k++) dp[i][j] += dp[i - 1][k]; } int count(int n) { if (!n) return 1; // 特判边界 vector\u003cint\u003e nums; while (n) nums.push_back(n % 10), n /= 10; int res = 0; // 最终结果 int last = 0; // 一些前缀信息:上一位数是几 for (int i = nums.size() - 1; i \u003e= 0; i--) // 从最高位往最低位枚举 { int x = nums[i]; for (int j = last; j \u003c x; j ++) // 处理左分支 res += dp[i + 1][j]; if (x \u003c last) break; // 处理右分支 if (i == 0) res ++; last = x; } return res; } int main() { init(); int l, r; while (cin \u003e\u003e l \u003e\u003e r) cout \u003c\u003c count(r) - count(l - 1) \u003c\u003c endl; return 0; } ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:48:2","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"记忆化搜索 ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:49:0","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"AcWing 901. 滑雪 题目描述 ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:49:1","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"901. 滑雪 给定一个 $R$ 行 $C$ 列的矩阵，表示一个矩形网格滑雪场。 矩阵中第 $i$ 行第 $j$ 列的点表示滑雪场的第 $i$ 行第 $j$ 列区域的高度。 一个人从滑雪场中的某个区域内出发，每次可以向上下左右任意一个方向滑动一个单位距离。 当然，一个人能够滑动到某相邻区域的前提是该区域的高度低于自己目前所在区域的高度。 下面给出一个矩阵作为例子： 1 2 3 4 5 16 17 18 19 6 15 24 25 20 7 14 23 22 21 8 13 12 11 10 9 在给定矩阵中，一条可行的滑行轨迹为 $24−17−2−1$。 在给定矩阵中，最长的滑行轨迹为 $25−24−23−…−3−2−1$，沿途共经过 $25$ 个区域。 现在给定你一个二维矩阵表示滑雪场各区域的高度，请你找出在该滑雪场中能够完成的最长滑雪轨迹，并输出其长度(可经过最大区域数)。 输入格式 第一行包含两个整数 $R$ 和 $C$。 接下来 $R$ 行，每行包含 $C$ 个整数，表示完整的二维矩阵。 输出格式 输出一个整数，表示可完成的最长滑雪长度。 数据范围 $1≤R,C≤300$, $0≤$矩阵中整数$≤10000$ 输入样例： 5 5 1 2 3 4 5 16 17 18 19 6 15 24 25 20 7 14 23 22 21 8 13 12 11 10 9 输出样例： 25 算法设计 此题是记忆化搜索的一道模板题，这道题用常规的迭代式 dp 写法，会发现状态转移不好写，也就是所有状态的起点不知道在哪。 当遇到这种情况或者循环太复杂如 $f_{i,j,k,m,n}$，常规情况需要写五层循环转移状态，会发现很不好写，如果用记忆化搜索来写会发现会很容易翻译成代码。记忆化搜索其实就是递归式的 dp 写法。 完整 C++ 代码 #include \u003ciostream\u003e #include \u003ccstring\u003e using namespace std; const int N = 310; int n, m; int w[N][N], dp[N][N]; int dx[4] = {-1, 0, 1, 0}, dy[4] = {0, 1, 0, -1}; int dfs(int x, int y) { int \u0026v = dp[x][y]; if (v == -1) return v; // 说明还没走过这个状态 v = 1; // v可以只走当前格子，就是1 for (int i = 0; i \u003c 4; i++) { int a = x + dx[i]; int b = y + dy[i]; if (a \u003e= 1 \u0026\u0026 a \u003c= n \u0026\u0026 b \u003e= 1 \u0026\u0026 b \u003c= m \u0026\u0026 w[x][y] \u003c w[a][b]) v = max(v, dfs(a, b) + 1); } return v; } int main() { cin \u003e\u003e n \u003e\u003e m; for (int i = 1; i \u003c= n; i++) for (int j = 1; j \u003c= m; j++) cin \u003e\u003e w[i][j]; memset(dp, -1, sizeof dp); // 首先把每个状态初始化为-1，表示未被算过 int res = 0; for (int i = 1; i \u003c= n; i++) for (int j = 1; j \u003c= m; j++) res = max(res, dfs(i, j)); cout \u003c\u003c res \u003c\u003c endl; return 0; } 第六章 贪心 ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:49:2","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"区间问题 ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:50:0","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"AcWing 905. 区间选点 题目描述 ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:50:1","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"905. 区间选点 给定 $N$ 个闭区间 $[a_i,b_i]$，请你在数轴上选择尽量少的点，使得每个区间内至少包含一个选出的点。 输出选择的点的最小数量。 位于区间端点上的点也算作区间内。 输入格式 第一行包含整数 $N$，表示区间数。 接下来 $N$ 行，每行包含两个整数 $a_i,b_i$，表示一个区间的两个端点。 输出格式 输出一个整数，表示所需的点的最小数量。 数据范围 $1≤N≤10^5,$ $−10^9≤a_i≤b_i≤10^9$ 输入样例： 3 -1 1 2 4 3 5 输出样例： 2 算法设计 贪心问题一般有一个很简单的套路：通过每一步选取局部最优，最终得到的就是全局最优。然后我们只需要去证明这个做法得到的是最优解就可以了。 我们可以通过构造一个特殊的情况，在这种情况下也得满足最优，所以我们可以先从这种情况下的局部最优出发，寻找猜想。 y总在视频中点评认为贪心题目是难度最变态的算法题了 首先我们来考虑一个比较极端的情况，如果要求下图三个区间的最少点： 对于这种情况，很明显，这三个区间只需要选出图中 $a$ 这个一个点即可，这就是所谓的局部最优，然后这个局部最优位于区间的右端点，很明显如果只有这三个区间，那么最优解一定在区间右端，所以做法中一定要选取右端点。所以我们大胆猜想，小心论证。 本题猜想做法如下： 首先将所有区间按右端排序。 遍历区间，若当前区间还未有选出的点，就选区间右端作为点。 下面只需要证明这个做法是最优解： 首先由于我们的做法肯定是一种合法方案，下面利用反证法证明：如果我们的做法不是最优解，那么我们构造两个区间来讨论。 如果这两个区间有交点，那么我们做法只需要一个点就可以满足条件，已经是最优了。 如果这两个区间没交点，那么按照我的做法需要两个点才可以满足条件，但是理论上不可能有小于两个点的做法，所以我们的做法得出来的点数一定小于等于最优解。 所以综上所述，我们的贪心做法就是最优解。 完整 C++ 代码 #include \u003ciostream\u003e #include \u003calgorithm\u003e using namespace std; typedef pair\u003cint, int\u003e PII; const int N = 100010, INF = 0x3f3f3f3f; PII a[N]; int ans; int main() { int n; cin \u003e\u003e n; for (int i = 0; i \u003c n; i ++) cin \u003e\u003e a[i].first \u003e\u003e a[i].second; sort(a, a + n, [](const PII \u0026a, const PII \u0026b) { return a.second \u003c b.second; // 使用 lambda 函数根据 second 排序 }); int r = -INF; for (int i = 0; i \u003c n; i ++) { if (a[i].first \u003e r) { ans ++; r = a[i].second; } } cout \u003c\u003c ans \u003c\u003c endl; return 0; } ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:50:2","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"AcWing 906. 区间分组 题目描述 ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:50:3","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"906. 区间分组 给定 $N$ 个闭区间 $[a_i,b_i]$，请你将这些区间分成若干组，使得每组内部的区间两两之间（包括端点）没有交集，并使得组数尽可能小。 输出最小组数。 输入格式 第一行包含整数 $N$，表示区间数。 接下来 $N$ 行，每行包含两个整数 $a_i,b_i$，表示一个区间的两个端点。 输出格式 输出一个整数，表示最小组数。 数据范围 $1≤N≤10^5,$ $−10^9≤a_i≤b_i≤10^9$ 输入样例： 3 -1 1 2 4 3 5 输出样例： 2 算法设计 这题一开始的想法很简单，既然是贪心，那我就套用 AcWing 908. 最大不相交区间数量 的做法，使用局部最优的思想，首先在所有区间上找到最大不相交区间，然后把这部分区间删除，再在剩余区间上重复上面操作，最后的最大不相交区间就是重复上面操作最终将所有区间都删除的操作次数。 但是 $\\text{unluckily}$，上面的贪心做法不是最优解，下面我给出一组反例： $[1,3],[1,4],[5,6],[4,7]$。 对于上面的情况来说，算法得到的结果是 $3$，但是显然我们可以找到数量为 $2$ 的分组。 当然收录的这道题，我们有非常经典的贪心做法，需要记住： 首先将所有组按左端点从小到大排序 从前往后处理每一个区间，记当前区间的左端点为 $L$，每个组的右端点的最大值为 $M_r$，判断是否能放到某个组中（$L \u003e M_r$) 如果存在这样的组，随便挑一个组将他放进去，并更新当前组的 $M_r$（这里可以用堆来维护所有组的最小值） 如果不存在这样的组，就 $\\text{new}$ 一个组，再将其放进去，并更新此时的 $M_r$ 下面我们给出上面贪心做法是最优解的证明： 还是反证法：我们假设在处理第 $i$ 个区间时，我们的贪心做法和最优解产生了分歧，若此时我们已经有 $j$ 个组，此时按照我们的贪心做法需要再开一个新的组，但是最优解其实可以继续把这个区间放进前面的组中。对于这种情况下，显然，根据我们的做法可知：当前区间一定都和这 $j$ 个组中的区间有交集，也即存在至少 $j+1$ 个区间存在交集，所以至少需要 $j+1$ 个组才能满足题意，所以可以继续把这个区间放进前面的组中的最优解不存在。 综上所述，证明完毕。 理解了上面的做法，其实就可以把它翻译成代码了，y总的常规做法需要使用一个小根堆来加速每次对于 $L$ 和 $M_r$ 大小的比对，下面我们介绍一篇题解分享中的更快更简洁的优美解法： 大家可以把这个问题想象成活动安排问题 有若干个活动，第i个活动开始时间和结束时间是 $[s_i,f_i]$，同一个教室安排的活动之间不能交叠，求要安排所有活动，至少需要几个教室？ 有时间冲突的活动不能安排在同一间教室，与该问题的限制条件相同，即最小需要的教室个数即为该题答案。 我们可以把所有开始时间和结束时间排序，一个活动开始时，分配一间教室，一个活动结束时，释放一间教室，这样所需的教室数量上下浮动，而浮动过程中的最大值就是所需教室数量的最小值 没结束就不释放，结束了就把对应的教室释放，不用管释放的是哪一间教室 这种解法的思想其实也是可以理解为按照我们上面的做法做的，这里的每间教室就对应了每一组。 完整 C++ 代码 暴力解法代码： #include \u003ciostream\u003e #include \u003calgorithm\u003e #include \u003cqueue\u003e using namespace std; const int N = 100010; int n; struct Range { int l, r; bool operator\u003c (const Range \u0026w)const // 因为要排序，所以重载一下小于号 { return l \u003c w.l; } }range[N]; int main() { int n; cin \u003e\u003e n; for (int i = 0; i \u003c n; i ++) { int l, r; cin \u003e\u003e l \u003e\u003e r; range[i] = {l ,r}; } sort(range, range + n); priority_queue\u003cint, vector\u003cint\u003e, greater\u003cint\u003e\u003e heap; // 用堆来判断是否能放到某个组中 for (int i = 0; i \u003c n; i ++) { if (heap.empty() || heap.top() \u003e= range[i].l) // 不能放：需要开新组 heap.push(range[i].r); else // 可以放：直接把他放到最小值组里面去 { int t = heap.top(); heap.pop(); heap.push(range[i].r); } } cout \u003c\u003c heap.size() \u003c\u003c endl; return 0; } 优美解法代码： #include \u003ciostream\u003e #include \u003ccstring\u003e #include \u003calgorithm\u003e using namespace std; const int N = 100010; int a[N], b[N]; int ans, cnt; int main() { int n; cin \u003e\u003e n; for (int i = 0; i \u003c n; i ++) cin \u003e\u003e a[i] \u003e\u003e b[i]; sort(a, a + n), sort(b, b + n); // 分别对左右端点进行排序 for (int i = 0, j = 0; i \u003c n; ) // 归并排序的思想 { if (a[i] \u003c= b[j]) // 这里取等号是因为有交点的也不能被放在同一个组里 cnt ++, i ++; else cnt --, j ++; ans = max(ans, cnt)； } cout \u003c\u003c ans \u003c\u003c endl; return 0; } ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:50:4","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"推公式 ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:51:0","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"AcWing 125. 耍杂技的牛 题目描述 ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:51:1","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"125. 耍杂技的牛 农民约翰的 $N$ 头奶牛（编号为 $1\\dots N$）计划逃跑并加入马戏团，为此它们决定练习表演杂技。 奶牛们不是非常有创意，只提出了一个杂技表演： 叠罗汉，表演时，奶牛们站在彼此的身上，形成一个高高的垂直堆叠。 奶牛们正在试图找到自己在这个堆叠中应该所处的位置顺序。 这 $N$ 头奶牛中的每一头都有着自己的重量 $W_i$ 以及自己的强壮程度 $S_i$。 一头牛支撑不住的可能性取决于它头上所有牛的总重量（不包括它自己）减去它的身体强壮程度的值，现在称该数值为风险值，风险值越大，这只牛撑不住的可能性越高。 您的任务是确定奶牛的排序，使得所有奶牛的风险值中的最大值尽可能的小。 输入格式 第一行输入整数 $N$，表示奶牛数量。 接下来 $N$ 行，每行输入两个整数，表示牛的重量和强壮程度，第 $i$ 行表示第 $i$ 头牛的重量 $W_i$ 以及它的强壮程度 $S_i$。 输出格式 输出一个整数，表示最大风险值的最小可能值。 数据范围 $1≤N≤50000$, $1≤W_i≤10,000$, $1≤S_i≤1,000,000,000$ 输入样例： 3 10 3 2 5 3 3 输出样例： 2 算法设计 我们首先将牛进行堆叠，从上往下进行依次编号，定义第 $i$ 头牛的重量为 $W_i$，强壮程度为 $S_i$。 牛 风险值 $i$ $\\sum_{j=1}^{i-1} w_j - s_i$ $i+1$ $\\sum_{j=1}^{i} w_j - s_{i+1}$ 我们假设需要交换这两个才能得到最优解，即： 牛 交换前风险值 交换后风险值 $i$ $\\sum_{j=1}^{i-1} w_j - s_i$ $\\sum_{j=1}^{i-1} w_j + w_{i+1} - s_i$ $i+1$ $\\sum_{j=1}^{i} w_j - s_{i+1}$ $\\sum_{j=1}^{i-1} w_j - s_{i+1}$ 进一步化简式子得： 牛 交换前风险值 交换后风险值 $i$ $- s_i$ $ w_{i+1} - s_i$ $i+1$ $w_i - s_{i+1}$ $- s_{i+1}$ 首先我们观察到：交换这头牛并不会带来前后其他牛的风险值的变化 $i$ 之前的牛并不涉及牛 $i$ 和 $i+1$ 的重量 $ i $ 之后的牛只涉及到牛 $i$ 和 $i+1$ 的总重量 由于$ w_{i+1} - s_i \u003e s_i$，如果我们使用贪心的思想，假设 $ w_{i+1} - s_i\u003ew_i - s_{i+1}$，此时交换后的牛 $i$ 的风险值同时大于交换前的牛 $i$ 和 $i+1$ 的风险值，那么交换后的风险值的最大值肯定大于交换前，所以此时我们不应该交换。 通过等价变换，原不等式 $ w_{i+1} - s_i\u003ew_i - s_{i+1}$ 可改写为 $w_{i+1} +s_{i+1}\u003ew_i + s_i $。 由此可得只需要满足：如果将牛按照 $w_i + s_i $ 排序后堆叠，小的值在上面，即可使得所有牛的风险值中的最大值尽可能的小。 下面我们对上面的结论进行证明： 假设我们贪心得到的做法不是最优解，那么将牛进行堆叠，一定存在某一次操作，最优解是需要将更小的 $w_i + s_i $ 堆在更大的 $w_{i+1} +s_{i+1}$ 下面，那么如果此时我们将牛 $i$ 和 $i+1$ 进行交换，那么由之前的证明可知，一定会增加这两头牛的风险值中的最大值，那么此时最优解得到的最大值一定大于我们贪心得到的最大值，故与最优解的定义矛盾。 综上可得将牛按照 $w_i + s_i $ 排序后堆叠是最优解。 完整 C++ 代码 #include \u003ciostream\u003e #include \u003calgorithm\u003e using namespace std; typedef pair\u003cint, int\u003e PII; const int N = 50010; PII cow[N]; int main() { int n; cin \u003e\u003e n; for (int i = 0; i \u003c n; i++) { int w, s; cin \u003e\u003e w \u003e\u003e s; cow[i] = {w + s, s}; } sort(cow, cow + n); // 可以用反证法证明所有牛按照w+s从小到大排序来安排是最优解 int sum = 0; int res = -1e9; for (int i = 0; i \u003c n; i++) { res = max(res, sum - cow[i].second); sum += cow[i].first - cow[i].second; } cout \u003c\u003c res \u003c\u003c endl; return 0; } 第七章 时空复杂度分析 ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:51:2","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"由数据范围反推算法复杂度以及算法内容 一般 $\\text{ACM}$ 或者笔试题的时间限制是 $1$ 秒或 $2$ 秒， 在这种情况下，$\\text{C}$++ 代码中的操作次数控制在 $10^7 \\sim 10^8$ 为最佳。 下面给出在不同数据范围下，代码的时间复杂度和算法该如何选择: $n \\le 30$,指数级别,dfs+剪枝，状态压缩dp $n \\le 10^2 =\u003eO(n^3)$，floyd，dp，高斯消元 $n \\le 10^3 =\u003e O(n^2)$，$O(n^2log n)$，dp，二分，朴素版Dikstra、朴素版Prim、Bellman-Ford $n \\le 10^4 =\u003e O(n\\sqrt{n})$，块状链表、分块、莫队 $n \\le 10^5 =\u003eO(nlogn)=\u003e$各种sort，线段树、树状数组、setmap、heap、拓扑排序、dikstratheap、prim+heap、Kruskal、spfa、求凸包、求半平面交、二分、CDQ分治、整体二分、后缀数组、树链剖分、动态树 $n\\le 10^6 =\u003eO(n)$,以及常数较小的 $O(nlogn)$ 算法 $=\u003e$ 单调队列、hash、双指针扫描、BFS、并查集、kmp、AC自动机，常数比较小的 $O(nlogn)$ 的做法: sort、树状数组、heap、dikstra、spfa $n \\le 10^7 =\u003eO(n)$，双指针扫描、kmp、AC自动机、线性筛素数 $n \\le 10^9=\u003eO(\\sqrt n)$，判断质数 $n \\le 10^{18} =\u003eO(logn)$，最大公约数，快速幂，数位DP $n\\le 10^{1000} =\u003e O((logn)^2)$，高精度加减乘除. $n\\le 10^{100000} =\u003e 0(logk \\ast loglogk)$，$k$表示位数，高精度加减、FFT/NTT 附录 ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:52:0","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"论递归算法的数学原理 ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:53:0","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"论递归算法的数学原理 作者：yxc , 2022-08-27 17:34:55 , 所有人可见 , 阅读 3646 想必很多同学在接触递归算法的时候都会很困惑，比如归并排序，为什么下面的代码可以将一个序列排好序呢？ 今天突然发现，**递归过程的本质就是数学归纳法！**我们再刨根问底一下，数学归纳法的正确性又源自于什么呢？答案就是：数学归纳法是一个公理，只有满足数学归纳法的数集才是我们平时用到的自然数集！ 所以，递归过程的正确性是个公理！这也是为什么我们对递归很困惑的原因了。 接下来以归并排序为例，我们用数学归纳法来证明其正确性。 首先当序列长度小于等于 $1$ 的时候，序列有序，成立。 假设对于任意序列长度小于 $𝑛$ 的序列，merge_sort(l, r) 都能将序列排好序。 那么我们证明对于任意序列长度等于 $n$ 的序列，merge_sort(l, r)也可以将序列排好序。 我们再来看merge_sort这个函数： 图中红色框起来的部分，根据归纳假设，[l, mid]和[mid + 1, r]的长度都小于 $n$，所以merge_sort函数可以将其排好序。 然后左右两个有序序列，通过二路归并算法，就可以合并成一个有序序列了，因此对于当前长度为 $n$ 的区间，merge_sort也可以将其排好序。证毕。 所以对于任意自然数长度的区间，merge_sort()都可以将其排好序 37 评论 yxc 2022-08-27 17:41 回复 今天突然发现数学归纳法才是算法的根本。DP问题都可以用闫氏DP分析法分析，而闫氏DP分析法的正确性，也是用数学归纳法来证明hh ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:53:1","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"算法竞赛进阶指南 ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:54:0","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"0xFF 前言—如何阅读本书 探究一门学问有单个层次：求其解，知其原因，究其思维之本。也就是所谓的“怎么做” “为什么这么做是对的” “怎样想到这么做的”。 在思维的迷宫里，有的人凭天生的灵感直奔终点；有的人以持久的勤勉，铸造出适合自己的罗盘；有的人迷失了方向，宣告失败。 ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:54:1","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"李煜东知乎回答 算法竞赛的知识迭代非常快（尤其是近几年），我已经很多年不做算法题了，对于加入最新的知识点、更新题库，也实在是力不从心。我觉得日后更新更好的算法竞赛书出来，蓝书自然会被淘汰，一个时代的人写的书只服务于当初那个时代，这也是很正常的事。不过我个人对于如何讲解算法知识，为那些比较困惑的同学指点迷津，还是有一些心得。我在大学期间，感觉很多教授/大神讲课都是自己知道为什么，能跟你讲清楚，但不能告诉你“怎么才能想到这一点”，还是要靠自己去体会。至于如何加速这个体会的过程，这是我写书希望完成的事情。 作者：李煜东 链接：https://www.zhihu.com/question/593371905/answer/2968691334 来源：知乎 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:55:0","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"为什么我们使用0x3f3f3f3f作为无穷大 在算法竞赛中，我们常常需要用到设置一个常量用来代表“无穷大”。 比如对于 int 类型的数，有的人会采用 INT_MAX，即 0x7fffffff 作为无穷大。但是以 INT_MAX 为无穷大常常面临一个问题，即加一个其他的数会溢出。 而这种情况在动态规划，或者其他一些递推的算法中常常出现，很有可能导致算法出问题。 所以在算法竞赛中，我们常采用 0x3f3f3f3f 来作为无穷大。0x3f3f3f3f主要有如下好处： 0x3f3f3f3f 的十进制为 $1,061,109,567$，和 INT_MAX 一个数量级，即 $10^9$ 数量级，而一般场合下的数据都是小于 $10^9$ 的。 0x3f3f3f3f $\\times \\ 2 = 2,122,219,134$，无穷大相加依然不会溢出。 可以使用 memset(array, 0x3f, sizeo(array)) 来为数组设初值为 0x3f3f3f3f，因为这个数的每个字节都是 0x3f。 聪明的你一定可以想到，如果我们需要一个“无穷小”，我们会选择类似的 0xc0c0c0c0 $=-1,061,109,568$，原因同上。 ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:56:0","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"云服务器笔记 阿里云地址 创建工作用户并赋予sudo权限 登录到新服务器。打开Terminal，然后： ssh user@hostname // 例如：ssh lx@66.166.166.166 user: 用户名(如root) hostname: IP地址或域名(如xxx.xxx.xxx.xxx) 第一次登录时会提示： The authenticity of host '66.188.185.66 (66.188.185.66)' can't be established. ED25519 key fingerprint is SHA256:SZfhynS8auEJWvEIyecTGm8m8VeflY1g+s8gzJ88PRI. This key is not known by any other names Are you sure you want to continue connecting (yes/no/[fingerprint])? 输入yes，然后回车即可。 这样会将该服务器的信息记录在~/.ssh/known_hosts文件中。 然后输入密码即可登录到远程服务器中。 默认登录端口号为22。如果想登录某一特定端口： ssh user@hostname -p 22 登录成功后，创建lx用户： adduser lx # 创建用户lx usermod -aG sudo lx # 给用户lx分配sudo权限 切换到lx用户： su lx #切换到lx用户 下次就可以直接ssh到新用户 lx 来登录到您的云服务器（实现多用户使用同一云服务器） 配置别名和免密登录方式 按Ctrl+d或者输入exit退回本地的Terminal，在自己电脑端配置lx用户的别名和免密登录 别名 创建文件 ~/.ssh/config。 然后在文件中输入： Host myserver1 HostName xxx.xxx.xxx.xxx # IP地址或域名 User lx # 用户名 # Port 20000 这里我们没有修改端口号，所以不用加，但是后面的docker连接就需要加了 Host myserver2 HostName xxx.xxx.xxx.xxx # IP地址或域名 User root # 用户名 之后再使用服务器时，可以直接使用别名myserver1、myserver2。 免密登录 本地主机创建密钥： ssh-keygen 然后一直回车即可。 执行结束后，~/.ssh/目录下会多两个文件： id_rsa：私钥 id_rsa.pub：公钥 之后想免密码登录哪个服务器，就将公钥传给哪个服务器即可。 例如，想免密登录myserver1服务器。则将公钥中的内容，复制到myserver1中的~/.ssh/authorized_keys文件里即可。 也可以使用如下命令一键添加公钥到服务器端： ssh-copy-id myserver1 简易安全配置 查看登录日志文件 sudo vim /var/log/auth.log 不出意外会看到很多类似如下的日志 Failed password for root from 183.146.30.163 port 22537 ssh2 Failed password for invalid user admin from 183.146.30.163 port 22545 ssh2 Invalid user tester from 101.254.217.219 port 56540 pam_unix(sshd:auth): check pass; user unknown pam_unix(sshd:auth): authentication failure; logname= uid=0 euid=0 tty=ssh ruser= rhost=103.61.8.34 然后可以统计有多少人在暴力破解root密码错误登录，展示错误次数和ip sudo grep \"Failed password for root\" /var/log/auth.log | awk '{print $11}' | sort | uniq -c | sort -nr | more 统计有多少暴力猜用户名的 sudo grep \"Failed password for invalid user\" /var/log/auth.log | awk '{print $13}' | sort | uniq -c | sort -nr | more 禁止SSH的root用户登录 修改 /etc/ssh/sshd_config文件 首先创建一下文件的备份 sudo cp /etc/ssh/sshd_config /etc/ssh/sshd_config.bak 禁止以root用户身份通过 SSH 登录 PermitRootLogin no 设置SSH单次登录限制 LogLevel INFO #将LogLevel设置为INFO,记录登录和注销活动 MaxAuthTries 3 #限制单次登录会话的最大身份验证尝试次数 LoginGraceTime 20 #缩短单次的登录宽限期，即ssh登录必须完成身份验证的时间 单位是秒 重启ssh服务 sudo service ssh restart 禁用密码登陆，使用RSA私钥登录 ssh-keygen #在客户端生成密钥 ssh-copy-id myserver1 #将公钥添加至服务端 还需要配置服务端 我们向/etc/ssh/sshd_config写入以下内容： PasswordAuthentication no #禁止密码认证 PermitEmptyPasswords no #禁止空密码用户登录 重启ssh服务 sudo service ssh restart docker配置和语法教程 安装tmux和docker 登录自己的服务器，然后安装tmux： sudo apt-get update sudo apt-get install tmux 将本地配置通过scp传到新服务器上： scp .vimrc .tmux.conf .bashrc server_name: # server_name需要换成自己配置的别名（！！！注意目的地址后面要有冒号：） 打开tmux。(养成好习惯，所有工作都在tmux里进行，防止意外关闭终端后，工作进度丢失) tmux操作小tips：按住shift就可以选择文本，然后Ctrl-insert进行复制，Shift-insert进行粘贴 然后在tmux中根据docker安装教程安装docker即可。 将当前用户添加到docker用户组 为了避免每次使用docker命令都需要加上sudo权限，可以将当前用户加入安装中自动创建的docker用户组(可以参考[官方文档](Post-installation steps | Docker Docs))： sudo usermod -aG docker $USER # 这里USER不用改成lx，因为$USER会自动修改成当前的用户名 执行完此操作后，需要退出服务器，再重新登录回来，才可以省去sudo权限。 镜像（images） docker pull ubuntu:20.04：拉取一个镜像 docker images：列出本地所有镜像 docker image rm ubuntu:20.04 或 docker rmi ubuntu:20.04：删除镜像ubuntu:20.04 docker [container] commit CONTAINER IMAGE_NAME:TAG：创建某个container的镜像 docker save -o ubuntu_20_04.tar ubuntu:20.04：将镜像ubuntu:20.04导出到本地文件ubuntu_20_04.tar中 docker load -i ubuntu_20_04.tar：将镜像ubuntu:20.04从本地文件ubuntu_20_04.tar中加载出来 容器(container) docker [container] create -it ubuntu:20.04：利用镜像ubuntu:20.04创建一个容器 docker ps -a：查看本地的所有容器 docker [container] start CONTAINER：启动容器 docker [container] stop CONTAINER：停止容器 docker [container] restart CONTAINER：重启容器 docker [contaienr] run -itd ubuntu:20.04：创建并启动一个容器 docker [container] attach CONTAINER：进入容器 先按Ctrl-p，再按Ctrl-q可以挂起容器 docker [container] exec CONTAINER COMMAND：在容器中执行命令 docker [container] rm CONTAINER：删除容器 docker container prune：删除所有已停止的容器 docker export -o xxx.tar CONTAINER：将容器CONTAINER导出到本地文件xxx.tar中 docker import xxx.tar image_name:tag：将本地文件xxx.tar导入成镜像，并将镜像命名为image_name:tag docker export/import与docker sav","date":"2024-11-12","objectID":"/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AC%94%E8%AE%B0/:1:0","tags":["编程"],"title":"云服务器笔记","uri":"/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AC%94%E8%AE%B0/"},{"categories":["编程"],"content":"tmux语法 ","date":"2024-11-11","objectID":"/tmux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:1:0","tags":["编程"],"title":"tmux常用命令","uri":"/tmux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["编程"],"content":"功能： 分屏。 允许断开Terminal连接后，继续运行进程。 ","date":"2024-11-11","objectID":"/tmux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:1:1","tags":["编程"],"title":"tmux常用命令","uri":"/tmux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["编程"],"content":"结构： 一个tmux可以包含多个session，一个session可以包含多个window，一个window可以包含多个pane。 类似于下面的逻辑： tmux: session 0: window 0: pane 0 pane 1 pane 2 ... window 1 window 2 ... session 1 session 2 ... ","date":"2024-11-11","objectID":"/tmux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:1:2","tags":["编程"],"title":"tmux常用命令","uri":"/tmux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["编程"],"content":"操作： 我大概按照自己的使用频率，从高到底列举了大部分日常使用中用到的操作： (1) tmux：新建一个session，其中包含一个window，window中包含一个pane，pane里打开了一个shell对话框。 (2) tmux a：打开之前挂起的session。 (3) 按下ctrl + a后手指松开，然后按d：挂起当前session。 (4) Ctrl + d：关闭当前pane；如果当前window的所有pane均已关闭，则自动关闭window；如果当前session的所有window均已关闭，则自动关闭session。（按下Ctrl + a 后手指松开，然后按 x 也可以实现关闭pane的效果） (5) 按下Ctrl + a后手指松开，然后按%：将当前pane左右平分成两个pane。 (6) 按下Ctrl + a后手指松开，然后按\"（注意是双引号\"）：将当前pane上下平分成两个pane。 (7) 鼠标点击可以选pane。 (8) 鼠标拖动pane之间的分割线，可以调整分割线的位置。 (9) 按下ctrl + a后手指松开，然后按z：将当前pane全屏/取消全屏。 (10) 在tmux中选中文本时，需要按住shift键。（仅支持Windows和Linux，不支持Mac，不过该操作并不是必须的，因此影响不大） (11) tmux中复制/粘贴文本的通用方式（需要提前按住shift键进行选中文本）： 复制：Ctrl+Insert 粘贴：Shift+Insert (12) 按下ctrl + a后手指松开，然后按方向键：选择相邻的pane。 (13) 按住ctrl + a的同时按方向键，可以调整pane之间分割线的位置。 (14) 按下ctrl + a后手指松开，然后按s：选择其它session。 方向键 —— 上：选择上一项 session/window/pane 方向键 —— 下：选择下一项 session/window/pane 方向键 —— 右：展开当前项 session/window 方向键 —— 左：闭合当前项 session/window (15) 按下Ctrl + a后手指松开，然后按c：在当前session中创建一个新的window。 (16) 按下Ctrl + a后手指松开，然后按w：选择其他window，操作方法与(12)完全相同。 (17) 按下Ctrl + a后手指松开，然后按PageUp：翻阅当前pane内的内容。 (18) 鼠标滚轮：翻阅当前pane内的内容。 有时候会突然遇到屏幕被限制在了一个很小的范围内，其他的地方全部变成了点 “.”,这是因为用不同的电脑或者终端打开过同一窗口，导致分辨率不一致，可以通过命令tmux a -d -t [YOUR TMUX NAME]来进入tmux ","date":"2024-11-11","objectID":"/tmux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:1:3","tags":["编程"],"title":"tmux常用命令","uri":"/tmux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["编程"],"content":"vim语法 功能： (1) 命令行模式下的文本编辑器。 (2) 根据文件扩展名自动判别编程语言。支持代码缩进、代码高亮等功能。 (3) 使用方式：vim filename ​ 如果已有该文件，则打开它。 ​ 如果没有该文件，则打开个一个新的文件，并命名为filename 模式： (1) 一般命令模式 ​ 默认模式。命令输入方式：类似于打游戏放技能，按不同字符，即可进行不同操作。可以复制、粘贴、删除文本等。 (2) 编辑模式 ​ 在一般命令模式里按下i，会进入编辑模式。 ​ 按下ESC会退出编辑模式，返回到一般命令模式。 (3) 命令行模式 ​ 在一般命令模式里按下:/?三个字母中的任意一个，会进入命令行模式。命令行在最下面。 ​ 可以查找、替换、保存、退出、配置编辑器等。 操作： (1) i：进入编辑模式 (2) ESC：进入一般命令模式 (3) h 或 左箭头键：光标向左移动一个字符 (4) j 或 向下箭头：光标向下移动一个字符 (5) k 或 向上箭头：光标向上移动一个字符 (6) l 或 向右箭头：光标向右移动一个字符 (7) n：n表示数字，按下数字后再按空格，光标会向右移动这一行的n个字符 (8) 0 或 功能键[Home]：光标移动到本行开头 (9) $或 功能键[End]：光标移动到本行末尾 (10) G：光标移动到最后一行 (11) :n 或 nG：n为数字，光标移动到第n行 (12) gg：光标移动到第一行，相当于1G (13) n：n为数字，光标向下移动n行 (14) /word：向光标之下寻找第一个值为word的字符串。 (15) ?word：向光标之上寻找第一个值为word的字符串。 (16) n：重复前一个查找操作 (17) N：反向重复前一个查找操作 (18) :n1,n2s/word1/word2/g：n1与n2为数字，在第n1行与n2行之间寻找word1这个字符串，并将该字符串替换为word2 (19) :1,$s/word1/word2/g：将全文的word1替换为word2 (20) :1,$s/word1/word2/gc：将全文的word1替换为word2，且在替换前要求用户确认。 (21) v：选中文本 (22) d：删除选中的文本 (23) dd: 删除当前行 (24) y：复制选中的文本 (25) yy: 复制当前行 (26) p: 将复制的数据在光标的下一行/下一个位置粘贴 (27) u：撤销 (28) Ctrl + r：取消撤销 (29) 大于号 \u003e：将选中的文本整体向右缩进一次 (30) 小于号 \u003c：将选中的文本整体向左缩进一次 (31) :w 保存 (32) :w! 强制保存 (33) :q 退出 (34) :q! 强制退出 (35) :wq 保存并退出 (36) :set paste 设置成粘贴模式，取消代码自动缩进 (37) :set nopaste 取消粘贴模式，开启代码自动缩进 (38) :set nu 显示行号 (39) :set nonu 隐藏行号 (40) gg=G：将全文代码格式化 (41) :noh 关闭查找关键词高亮 (42) Ctrl + q：当vim卡死时，可以取消当前正在执行的命令 异常处理： 每次用vim编辑文件时，会自动创建一个.filename.swp的临时文件。 如果打开某个文件时，该文件的swp文件已存在，则会报错。此时解决办法有两种： ​ (1) 找到正在打开该文件的程序，并退出 ​ (2) 直接删掉该swp文件即可 ","date":"2024-11-11","objectID":"/vim%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:1:0","tags":["编程"],"title":"vim常用命令","uri":"/vim%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["编程"],"content":"机器学习常用命令 使用conda作为包管理器 环境管理 1.conda env list：列出所有环境 2.conda activate \u003c环境名称\u003e：激活该环境 3.conda create -n \u003c环境名称\u003e python=\u003c版本\u003e：创建新环境 包管理 1.conda list：列出环境中的所有包 2.conda install \u003c包名\u003e：安装包 3.conda update \u003c包名\u003e：更新包 4.conda remove \u003c包名\u003e：删除包 ","date":"2024-10-30","objectID":"/conda%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%8C%85%E7%AE%A1%E7%90%86%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:1:0","tags":["编程"],"title":"conda机器学习常用命令","uri":"/conda%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%8C%85%E7%AE%A1%E7%90%86%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["编程"],"content":"找到正在使用的主题CSS文件（例如 gitHub.css),下面是我从acwing网站上源代码分析爬取下来的关于单行代码渲染的css样式，直接在刚刚找到的css文件的底部，添加下面的样式即可： /* 自定义 code 标签的样式 */ code { background-color: #f8f8f8; color: #c7254e; /* 设为红色 */ padding: 0 5px; border: 1px solid #eaeaea; font-family: Menlo, Monaco, Consolas, \"Courier New\", monospace; border-radius: 3px; white-space: nowrap; } 下面是我从csdn爬下来的，感觉更紧凑一点，和y总的区别也不算大 /* 自定义 code 标签的样式 */ code { background-color: #F9F2F4; /* 背景颜色 */ color: #C7254E; /* 字体颜色 */ padding: 2px 4px; /* 内边距，符合图片的 2px 4px */ font-size: 10px; /* 字体大小 */ font-family: \"Source Code Pro\", \"comic code\", \"DejaVu Sans Mono\", Menlo, Monaco, Consolas, \"Courier New\", monospace; /* 字体设置 */ border-radius: 3px; /* 边框圆角 */ white-space: nowrap; /* 防止换行 */ border: none; /* 去除边框 */ } ","date":"2024-10-28","objectID":"/y%E6%80%BBacwing%E7%BD%91%E7%AB%99markdown%E6%B8%B2%E6%9F%93%E6%A0%B7%E5%BC%8F/:0:0","tags":["编程"],"title":"y总acwing网站markdown渲染样式","uri":"/y%E6%80%BBacwing%E7%BD%91%E7%AB%99markdown%E6%B8%B2%E6%9F%93%E6%A0%B7%E5%BC%8F/"},{"categories":["自我提升"],"content":"泡芙方专注力课程练习合集整理版 顺序是按照课程中提到的练习顺序整理 总原则：使用呼吸法进行高效休息，进入α脑波状态，正念冥想用来修复我们的前额叶 1.四象限法：每天晚上回忆并分类自己的任务 2.超级专注模式四步法：每天至少两个小时学习的时候完全觉察这四步 3.生活上的调整：清醒的时间，每小时设定一次闹铃振动，回顾这个小时做了什么，画出图形 4.开启超级专注：每天开始至少一个小时的超级专注 5.评估四类分心事物：每天早上预估自己可能有什么分心的事情，写在四象限里 6.手机暗示法：使用手机前就心里给自己一个暗示：“这是一台电脑” 7.删除无用软件：使用两台设备，一台专门用来娱乐，另一台专心工作 8.会议觉察法：当必须参加一个会议时，练习使用超级专注力：有觉察的听话，一句提取一个意思。 9.\"申请\"使用网络：有意识的申请明天什么失手使用网络，其余时间使用飞行模式。 10.犹太法：效仿犹太人习俗，固定抽出一天时间，尝试24小时不连接网络（电脑，手机，ipad） 11.釜底抽薪法：每次发现一个让人分心的事物，只去掉一个，不一下子全去掉因为太困难 12.TODO list法: 设置周任务，每天只需要从周任务中取出分配任务。升级法：有需要甚至可以制作分心清单和担忧清单，准备一个玻璃杯，每次把担忧的事情写下来扔进杯子里就相当于告诉自己放下了 13.自测法：番茄工作法的工作时间不适合每个人，应该对自己做一个测试，分布在每天的不同时间段的一次专注时长，一周不同天的同一时间段的一次专注时长 14.腹式呼吸法：练习使用腹式呼吸 15.平地走路呼吸法：行走时吸气呼气比例为1 ：2,如吸气同时走2步，呼气同时走4步，当然也可以3步吸4步呼，只要不要吸气比呼气长就可以 16.身心合一呼吸法：呼吸时感知全身 17.冰人呼吸法：效仿极限运动员“冰人”的呼吸法 18.呼吸法调整α脑波：首先先全身放松，呼气的时候放松紧绷的部位，然后吸气-屏气-呼气-屏气节拍，都是4节拍，通过不断练习逐步过渡到6节拍，再渐渐到8节拍 19.身体放松法调整α脑波：对身体进行放松 20.环境想象法调整α脑波：回忆以前看到过的最美好的自然环境（所以要多旅游） 21.意念调整α脑波法：通过想象人脑释放α波的生理特征来反向刺激引导出α波 22.组合调整α脑波法：找到一个组合法，调配最适合自己的α脑波诱导体系，并养成习惯，如呼吸法+意念调整法 23.分散模式法：三种分散模式的进入方法：习惯式，解决问题式，头脑风暴式 24.身体专注法 25.感觉专注法 26.头脑范围专注法 27.头脑事务专注法 28.空专注法 29.运动专注法 30.无聊练习法：增加正念冥想\"桩子\" 31.记忆字符串法：使用记忆宫殿进行左右脑协调，无聊的时候如上下楼时可以试着在脑海中漫步一圈自己的记忆宫殿 32.速听和速读法：速读三要点：去除音读，减少眼停，去除回读 33.有意识的专注于读书：一般1-2页上用十个字以内标注一个共鸣点并且标下页码；读25min，休息5min；休息之前花一分钟快速看看和回忆一下之前的标注点；读完一章节后把本章笔记整体回忆一遍(35min)，然后休息15min(用呼吸法恢复精力)。一般一天(810h)可以非常扎实的读1本书。基本上可以达到完整复述的程度 34.极限版英文备考：听力：核心是用耳朵背单词，听写虽然无聊但是是最有效的方法，很多人单词会背了但是别人读出来又听不懂就是因为没有用耳朵背单词。听一句写一句，写大概20个单词左右和原文对比，找出没有听出来的部分，然后重新听原文3-5遍，用耳朵把没有听出来的单词短语”背“下来，听完一大段(100300词)重复反复听和倍速听，定期复习。口语：总结在听力中反复出现的句型，提炼出句型模板，总结成册，用句型疯狂造句1020句，定期复习。 35.闭关式思考和创造：如果有条件最好去一个远离世俗的地方 36.不同的专注策略：每几年分别一年超级专注(美国终生教授之后每七年会有一年放假，但是这种太奢侈了，大部分普通人没有必要，而且很可能一下子浪费掉)；每年季度性的超级专注(利用长的法定假期)；每周分别14天超级专注；每天早晨/晚上超级专注(适合新手，甚至有人每天固定2h使用56年时间读了个phd)；随时超级专注(每当有20min以上时间就躲起来，不太适合新手)；混合超级专注模式(对于学生：暑假进行长时间专注，每周2天超级专注，每天早起两小时超级专注) 37.设计随身携带的\"专注屋\"： 99. 音乐法：原则上不建议学习听音乐，但是可以在每天学习很累了之后如晚上通过音乐来让自己可以继续坐在椅子上。但是音乐选取有三个原则：自己熟悉的音乐，调子简单，无歌词。 ","date":"2024-10-26","objectID":"/%E6%B3%A1%E8%8A%99%E6%96%B9%E4%B8%93%E6%B3%A8%E5%8A%9B%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/:1:0","tags":["专注力"],"title":"泡芙方专注力课程练习合集整理版","uri":"/%E6%B3%A1%E8%8A%99%E6%96%B9%E4%B8%93%E6%B3%A8%E5%8A%9B%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"},{"categories":["编程"],"content":"Markdown语法 1.标题 # +一级标题：#后要有空格 ## + 二级标题 2.代码段 ` `：反引号（`）中插入一行代码 ``` ```：三个反引号（）中插入一段代码,注：```后可加语言类型，如 ```css 3.加粗 ** **：语句前后各添加两个星号 4.斜体 * *： 语句前后各添加一个星号 5.换行 \u003cbr/\u003e：使用HTML的br标签来实现换行 6.转义 \\+需要转义的字符 7.网址链接 [name](url)：[我的个人主页](https://lxxinli.github.io)我的个人主页 8.分隔线 ---或***：在当前行的下方插入一条分隔线 9.列表 * List 或- List ： List 1. One One 10. 块注释 \u003e 11. LaTeX语法 LaTeX符号大全 LaTeX LaTeX 代码 说明 $n^2$ $n^2$ $n^{100}$ $n^{100}$ $x_i$ $x_i$ $\\text{x}$ $\\text{x}$ $\\le$ $\\le$ $\\ge$ $\\ge$ $\\ne$ $\\ne$ $\\times$ $\\times$ $\\ast$ $\\ast$ $\\sqrt{x}$ $\\sqrt{x}$ $\\sqrt[n]{x}$ $\\sqrt[n]{x}$ 空格 $\\ $ 如$a \\ b$ $\\gets$ $\\gets$ $\\to$ $\\to$ $\\Rightarrow$ $\\Rightarrow$ $\\begin{cases} x = 1 \\ y = 1 \\end{cases} $ $\\begin{cases} x = 1 \\\\ y = 1 \\end{cases} $ $\\sum_{k=1}^N k^2$ $\\sum_{k=1}^N k^2$ 行内公式 $\\dots$ $\\dots$ ∼ 特殊符号直接复制 $\\frac {n} {2}$ $\\frac {n} {2}$ ","date":"2024-10-25","objectID":"/markdown%E8%AF%AD%E6%B3%95/:1:0","tags":["编程"],"title":"Markdown语法","uri":"/markdown%E8%AF%AD%E6%B3%95/"}]