[{"categories":["编程"],"content":"首先我们来谈一谈源码编译安装的好处，这边我们引用我一同在百度实习的朋友ywm的话： ","date":"2025-12-11","objectID":"/%E5%BC%80%E5%8F%91%E6%9C%BA%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE/:0:0","tags":["编程"],"title":"开发机常用配置","uri":"/%E5%BC%80%E5%8F%91%E6%9C%BA%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE/"},{"categories":["编程"],"content":"zsh 在外网机器下载源码 wget https://sourceforge.net/projects/zsh/files/zsh/5.9/zsh-5.9.tar.xz 传到内网机： scp zsh-5.9.tar.xz dev:/tmp/ 在内网机编译 tar xf zsh-5.9.tar.xz cd zsh-5.9 ./configure --prefix=/usr/local/zsh make -j$(nproc) sudo make install 安装后： echo /usr/local/zsh/bin/zsh | sudo tee -a /etc/shells chsh -s /usr/local/zsh/bin/zsh zsh-autosuggest（自动灰色提示） 如果你想要那种： 输入几个字符 → 自动浮现灰色历史提示文本 那么用 zsh 的自带能力不够，但你可以： 不下载 直接把插件源码 copy 过去 只需要一个文件 ","date":"2025-12-11","objectID":"/%E5%BC%80%E5%8F%91%E6%9C%BA%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE/:0:1","tags":["编程"],"title":"开发机常用配置","uri":"/%E5%BC%80%E5%8F%91%E6%9C%BA%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE/"},{"categories":["编程"],"content":"设置 ","date":"2025-12-10","objectID":"/vscode%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE/:1:0","tags":["编程"],"title":"vscode常用配置","uri":"/vscode%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE/"},{"categories":["编程"],"content":"代码缩略窗 搜索minimap，找到“Editor: Minimap”选项，并勾选“Enabled”复选框。 image-20251210192552152 在缩略图中只需要双击右边的文件，即可跳转到对应的位置： image-20251210193253900 ","date":"2025-12-10","objectID":"/vscode%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE/:1:1","tags":["编程"],"title":"vscode常用配置","uri":"/vscode%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE/"},{"categories":["编程"],"content":"插件 ","date":"2025-12-10","objectID":"/vscode%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE/:2:0","tags":["编程"],"title":"vscode常用配置","uri":"/vscode%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE/"},{"categories":["编程"],"content":"GitLens 神！可以看到每行代码的提交人，只需要将鼠标放在每一行的提示文字上即可： image-20251210192810252 ","date":"2025-12-10","objectID":"/vscode%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE/:2:1","tags":["编程"],"title":"vscode常用配置","uri":"/vscode%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE/"},{"categories":["编程"],"content":"Material Icon Theme 很漂亮的文件格式 ","date":"2025-12-10","objectID":"/vscode%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE/:2:2","tags":["编程"],"title":"vscode常用配置","uri":"/vscode%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE/"},{"categories":["编程"],"content":"Dracula Theme Official 很喜欢的vscode主题，吸血鬼 ","date":"2025-12-10","objectID":"/vscode%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE/:2:3","tags":["编程"],"title":"vscode常用配置","uri":"/vscode%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE/"},{"categories":["编程"],"content":"Chinese (Simplified) 汉化包，yyds! ","date":"2025-12-10","objectID":"/vscode%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE/:2:4","tags":["编程"],"title":"vscode常用配置","uri":"/vscode%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE/"},{"categories":["阅读"],"content":"《原子习惯》 习惯为什么重要呢，就在于它的复利特征，这个太重要了，最简单的就是 $1.01^{365} \\approx 37.78$，也就是每天提升 $1%$，坚持一年提升的不是我们下意识认为的 $3.65$ 倍的提升，而是低估了整整 $10$ 倍的提升了。 当然很多人会有疑惑，明明我每天的精力都差不多，学的进度也差不多，这明明只是 $1.01 \\times 365 \\approx 3.65 $，那为什么书中却说是复利呢？那是因为我们就先拿知识来说：知识会复合增益，也就是说学习新观念会增加你原有观念的价值。比如本来如果只是看了书本A，你只吸收得到了 $40%$，而如果你继续学习，看了书本B，不但你对书本B的知识掌握了，而且还加深了你对书本A的认知，比如从$20% \\to 60%$，所以最终的收益是复利 $1.01^{365} \\approx 37.78$，这是恐怖的 $10$ 倍错误估计啊！！两条曲线的差异可以看下面这张图： image-20251104145644852 至于为什么我们感觉我们付出了努力去谋求改变，为什么非常的不明显？答案也藏在了上面这个指数函数的图像中，你可知道增长一倍的函数坐标吗？是恐怖的 $(69.66, 1.99999)$,意思是我们努力了整整 $70$ 天，只带来了一倍的提升，这怎么不让现在这个快节奏的社会中的人们感到无比的伤心，但是复利的本质是后期的快速飞跃，我们把目标瞄向第二个 $70$ 天，数据上是 $(140,4.0271)$，第三个 $70$ 天则是 $(210,8.08144)$，增长的越来越快，这就是为什么高手都是专注一个领域的，因为复利效应来看坚持的越久，作用也提升的越快。我们直接来看函数 $1.01^{x+1} - 1.01^x$ 就会更加的明显： image-20251104151739399 就像你自己是一个水池，你应当关注你的流量，也就是进水量和出水量，而不是存量。因为只要流量对了，那么你的存量自然会日积月累地增加。 你得到的结果是衡量你习惯的滞后指标。 忘记目标，专注于体系。目标是关于你想要达到的结果，而体系是涉及导致这些结果的过程。因为如果目标是最重要的话，那么世界上就不会有赢家和输家了，因为他们都心怀相同的目标。这里我们强调“体系”，而非“过程”，是因为“过程”是行为，“体系”是让这些行为长期运作的生态系统，解决如何让这件事持续有效地发生。专注于目标会有以下几个问题： 问题1：赢家和输家心怀相同的目标 问题2：实现一个目标只是短暂的改变 问题3：目标束缚了你的幸福感 ","date":"2025-10-31","objectID":"/%E5%8E%9F%E5%AD%90%E4%B9%A0%E6%83%AF/:1:0","tags":["读书笔记"],"title":"《原子习惯》","uri":"/%E5%8E%9F%E5%AD%90%E4%B9%A0%E6%83%AF/"},{"categories":["编程"],"content":"如何提交一个优雅的pr 暑假参加了2025OSPP的活动，有幸参与了apache/fory的开源项目的开发活动，也因此在实践中学习到了如何在GitHub上参与一个开源项目 在GitHub上你想要给开源项目提交你的代码，就需要提交pr，也就是所谓的 pull request。 ","date":"2025-09-23","objectID":"/%E5%A6%82%E4%BD%95%E6%8F%90%E4%BA%A4%E4%B8%80%E4%B8%AA%E4%BC%98%E9%9B%85%E7%9A%84pr/:1:0","tags":["编程"],"title":"如何提交一个优雅的pr","uri":"/%E5%A6%82%E4%BD%95%E6%8F%90%E4%BA%A4%E4%B8%80%E4%B8%AA%E4%BC%98%E9%9B%85%E7%9A%84pr/"},{"categories":["编程"],"content":"1. fork 仓库 首先需要将这个项目fork到你的主页，注意：后续所有的操作都是基于你仓库内的这个派生的代码库展开的。 image-20250923145650118 拉取的项目的main分支不要动，因为我们要靠这个分支与原仓库做同步。 从优雅简洁的角度来看，每次你想要提交一个pr，都请先在你的这个派生的代码库中新建一个分支： image-20250923150223563 分支名最好和本次提交的主题相关，这样方便分辨哪个分支是干什么的，比如我这次需要提交一个新特性：让go语言的代码生成部分支持slice，那么我就可以新建一个叫做feat-slice的分支。 GitHub里的派生的代码库不会默认进行同步，如果你派生的代码库落后于最新的原始仓库，那么这里就会有提示，点击 Sync fork 按钮即可 Update branch。（注意我们每次只要更新main分支就好，保持main分支是最新的就行） image-20250923150446976 ","date":"2025-09-23","objectID":"/%E5%A6%82%E4%BD%95%E6%8F%90%E4%BA%A4%E4%B8%80%E4%B8%AA%E4%BC%98%E9%9B%85%E7%9A%84pr/:1:1","tags":["编程"],"title":"如何提交一个优雅的pr","uri":"/%E5%A6%82%E4%BD%95%E6%8F%90%E4%BA%A4%E4%B8%80%E4%B8%AA%E4%BC%98%E9%9B%85%E7%9A%84pr/"},{"categories":["编程"],"content":"2. 本地开发 本地开发始终记住：永远不要在main分支上修改提交commit！！！每次开发都请和远程派生的代码库一样，各自新建一个分支来开发，pr提交合并结束记得删除本地相关分支和派生代码库的相关分支。 这里的好处是非常非常大的，也是我本地踩过很多次坑发现的：因为GitHub提交pr的特点是，pr中可能有10个commit，最终如果owner approve 你的合并，那也只会将这个pr的内容作为一个整体commit提交上去。所以如果你在main分支上直接开发，就会出现你的本地commit多于远程代码库的main分支，这显然是有问题的，两边git历史对不上。所以这就是为什么我说的永远不要在main分支上直接修改提交，新建新的分支开发完提交pr之后就可以删掉了，然后本地main分支重新git pull就可以保持完全一致！ 首先先查看git历史： git log --graph --oneline --decorate --all 然后切换到main分支： git checkout main 新建并切换分支： git checkout -b \u003c新分支名\u003e 下面就可以在这个新的分支上进行愉快的开发了！ ","date":"2025-09-23","objectID":"/%E5%A6%82%E4%BD%95%E6%8F%90%E4%BA%A4%E4%B8%80%E4%B8%AA%E4%BC%98%E9%9B%85%E7%9A%84pr/:1:2","tags":["编程"],"title":"如何提交一个优雅的pr","uri":"/%E5%A6%82%E4%BD%95%E6%8F%90%E4%BA%A4%E4%B8%80%E4%B8%AA%E4%BC%98%E9%9B%85%E7%9A%84pr/"},{"categories":["编程"],"content":"3. 创建合并请求 只要你将本地的修改push到你远程的派生代码库的相关分支上，回到线上派生项目的工作区，会看到新分支和修改的合并提交信息，点击Compare \u0026 pull request: image-20250923183009698 选择你想并入的原项目分支，标题和描述信息。如果有对应的 issue，就通过键入 # 添加(Github 会自动展示 issues 列表) 然后点击Create pull request即可创建合并请求成功，之后就等待cr就行。 ","date":"2025-09-23","objectID":"/%E5%A6%82%E4%BD%95%E6%8F%90%E4%BA%A4%E4%B8%80%E4%B8%AA%E4%BC%98%E9%9B%85%E7%9A%84pr/:1:3","tags":["编程"],"title":"如何提交一个优雅的pr","uri":"/%E5%A6%82%E4%BD%95%E6%8F%90%E4%BA%A4%E4%B8%80%E4%B8%AA%E4%BC%98%E9%9B%85%E7%9A%84pr/"},{"categories":["编程"],"content":"4. 根据评论修改你的代码 你提交的pr是需要 code owner 进行 review 的，他们认为你的代码有问题就会在cr的时候提出评论，此时你需要根据评论去修改你本地的内容，然后再提交到之前的那个远程分支上就可以自动更新pr中的commit了。 但是很多情况下会有很复杂的情况，比如给你的评论很复杂改了几天，回头发现有人先提交了一些新的pr并且合入了怎么办？ 我们可以把这种情况抽象为下面的模型： 初始情况: 远程 main: A feat-slice: A 本地 feat_slice: A 你在本地提交了 C 本地 feat_slice: A–C 然后你 push 到远程 feat-slice： main: A feat-slice: A–C 远程 main 更新为 A–B 远程： main: A–B feat-slice: A–C 本地： feat_slice: A–C （还没 git pull --rebase） 本地 git pull --rebase 到 main 执行：git pull --rebase 结果： 本地 feat_slice: A–B–C （C 被“挪”到 B 后面） 远程还是： main: A–B feat-slice: A–C 此时 git push origin master:feat_slice 到远程 feat-slice Git 会检查： 远程 feat-slice 目前是 A–C 你要推的是 A–B–C 👉 这两条历史分叉了： 远程的 C 在 A 后直接接， 本地的 C 在 A–B 后接。 所以，Git 默认会认为这是「非快进 (non-fast-forward) 更新」，直接 push 会报错： ! [rejected] master -\u003e feat_slice (non-fast-forward) 强制推送 怎么办？ 如果你确认要让远程 feat-slice 变成 A–B–C，需要强制推送： git push -f origin master:feat_slice 这样远程 feat-slice 就会被改写成 A–B–C。pr上也会出现force-pushed的相关显示： image-20250923170353243 ","date":"2025-09-23","objectID":"/%E5%A6%82%E4%BD%95%E6%8F%90%E4%BA%A4%E4%B8%80%E4%B8%AA%E4%BC%98%E9%9B%85%E7%9A%84pr/:1:4","tags":["编程"],"title":"如何提交一个优雅的pr","uri":"/%E5%A6%82%E4%BD%95%E6%8F%90%E4%BA%A4%E4%B8%80%E4%B8%AA%E4%BC%98%E9%9B%85%E7%9A%84pr/"},{"categories":["编程"],"content":"5. 删除你的分支 请记住：每次提交的pr合并进去，都请删除本地和派生代码库的相关分支，然后在本地的main分支重新git pull即可，如果还需要继续开发，请回到 步骤2. 本地开发 ","date":"2025-09-23","objectID":"/%E5%A6%82%E4%BD%95%E6%8F%90%E4%BA%A4%E4%B8%80%E4%B8%AA%E4%BC%98%E9%9B%85%E7%9A%84pr/:1:5","tags":["编程"],"title":"如何提交一个优雅的pr","uri":"/%E5%A6%82%E4%BD%95%E6%8F%90%E4%BA%A4%E4%B8%80%E4%B8%AA%E4%BC%98%E9%9B%85%E7%9A%84pr/"},{"categories":["编程"],"content":"cpp学习笔记 ","date":"2025-08-29","objectID":"/cpp%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:0:0","tags":["编程"],"title":"cpp学习笔记","uri":"/cpp%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["编程"],"content":"学习资源 视频地址：C++教程-油管大佬 The Cherno C++教程 ","date":"2025-08-29","objectID":"/cpp%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:1:0","tags":["编程"],"title":"cpp学习笔记","uri":"/cpp%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["编程"],"content":"1. cpp语法 1.1 基本结构 下面有一个简单的cpp程序，我们来看看： #include \u003ciostream\u003e #include \u003cstring\u003e #include \"b.h\" int main() { std::string a = \"Hello World!\"; std::cout \u003c\u003c a \u003c\u003c std::endl; } 由于cpp兼容着c，因此基本语法并没有很明显的区别，这里需要注意的是cpp的头文件和c语言的标准库文件确实是有区别的，c语言的头文件一般是#include \u003cstdio.h\u003e，而cpp的标准库文件一般没有.h作为结尾，这是为了和c语言有所区分。 这时候又会有人问了，那为什么cpp中又有\u003c\u003e又有\"\"这两种include写法呢？其实就是为了让编译器知道，哪些头文件需要从用户的仓库目录里面找，哪些从gcc的库函数里面去找。 1.2 编译、链接、头文件 刚刚给的例子太简单了，这次我们给一个稍微复杂一点的,涉及到调用另一个文件中的方法的代码： main.cc: #include \u003ciostream\u003e int main() { funcB(); // 调用b.cc中的方法funcB(); } 如果设计到一个项目中有两个文件，而且main函数需要调用另一个文件中的funcA方法，编译器到底怎么样才能将这个main函数成功运行呢？ 那么我们就得了解编译器到底干了什么事情。简单来说主要就是两件事：编译和链接 编译其实就是编译器（如 g++）把 源代码（.cpp）转化为 目标文件（.o/.obj），这个过程中包含几个子阶段： 预处理 (Preprocessing) 处理 #include、#define、#if 等预处理指令。 例如：#include \"b.h\" 会直接把 b.h 的内容拷贝进来。 预处理后的文件其实是一个纯 C++ 源文件。 词法/语法分析 检查语法是否正确，比如 int x = \"abc\"; 就会报错。 把代码拆成语法树（AST）。 语义分析 + 生成中间表示 确认类型是否匹配，作用域是否正确。 例如：声明了函数 void f(); 但是在同一个 .cpp 文件里没有定义，不会报错，只会标记“这个符号需要外部解析”。 生成目标文件 (.o) 每个 .cpp 编译后，都会生成对应的 .o。 .o 文件里包含了 机器指令 + 符号表（符号表记录了函数和变量的名字、是否已经实现、还是等待外部提供）。 看了上面的介绍，你认为上面的代码使用g++ -c main.cpp -o a.o能成功编译吗？ 答案当然是 No，根据上面编译过程的分析可以知道，想要使用一个当前文件没有实现的方法，我们需要声明这个函数，我们把代码更新为： #include \u003ciostream\u003e void funcB(); int main() { funcB(); } 现在我们重新编译：g++ -c main.cpp -o a.o 这次果然成功了，生成了a.o这个目标文件，but oh no, b.cc我甚至还没写啊，what crazy! 这样居然编译都没报错，因此你应该理解了下面这句话了： 👉 这个阶段 不会报“未定义引用（undefined reference）”错误，因为编译器只管当前 .cpp 文件，不管别的文件到底有没有funcB()的具体实现。 至于funcB()到底实现在哪了，那就是接下来链接阶段需要关心的。 链接阶段其实就是链接器（ld）把所有 .o 文件和库文件 .a / .so 组合在一起，生成一个可执行文件。 符号解析 每个 .o 文件都有符号表（symbol table）。 如果某个 .o 里声明了 extern void foo();，但是没有实现，链接器会在别的 .o 或库里找 foo 的定义。 符号重定位 不同目标文件中的函数、变量可能会分布在不同内存区域，链接器会把调用地址改成实际的地址。 比如：在 main.o 里有 call foo，但是不知道 foo 在哪，链接器会把它改成 call 0x400123 这种真实地址。 生成可执行文件 所有引用都能匹配 → 链接成功，得到 ELF（Linux）或 PE（Windows）格式的可执行文件。 如果找不到 → 报错 undefined reference to 'foo'。 注：what isextern? 👉 它告诉编译器： “这个变量/函数的定义在别的地方，我这里只是声明一下。” 换句话说，extern 只做 声明 (declaration)，不做 定义 (definition)。 最终在链接阶段，链接器会去别的翻译单元（别的 .o 文件、库）里找到真正的实现。 （1）全局变量跨文件使用 // a.cpp int g_value = 42; // 定义（真正分配内存） // b.cpp extern int g_value; // 声明（不分配内存） void print() { std::cout \u003c\u003c g_value \u003c\u003c std::endl; } 编译时 b.cpp 看到 extern int g_value;，知道有个 int 变量存在，但不生成内存。 链接时，它去 a.o 找到 g_value 的定义，拼在一起 ✅。 （2）函数默认就是 extern // a.cpp void foo() {} // 定义 // b.cpp void foo(); // 声明（其实相当于 extern void foo();） 函数声明本质上都带 extern，所以你不写也行 这时候如果我们没有实现b.cpp直接去把g++ main.cc -o main 我们会发现报错： (TraeAI-4) ~/Downloads/cpp [126] $ g++ main.cc -o main Undefined symbols for architecture arm64: \"funcB()\", referenced from: _main in main-331bbe.o ld: symbol(s) not found for architecture arm64 clang: error: linker command failed with exit code 1 (use -v to see invocation) 这说明虽然上面的编译阶段成功了，但是链接阶段却有问题，提示找不到funcB()的具体实现 这时候我们就需要实际去实现我们的b.cc文件了： #include \u003ciostream\u003e void funcB() { std::cout \u003c\u003c \"B\" \u003c\u003c std::endl; } 现在我们再次运行g++ main.cc b.cc -o main，构建成功了! 聪明的同学肯定还有疑问啊，那c以及cpp文件中随处可见的.h文件，在项目构建时会发生什么呢？ 包括还有人有疑问，每次写我们都得将函数声明void funcB();写在文件的上面吗，那不是非常的丑陋，如果调用的函数非常多的话？ 其实头文件.h就是为了解决这个问题的，也就是我们上面提到的编译过程中的预处理阶段。在预处理阶段，编译器看到了#include等预处理指令，就会 copy 这个文件中的内容到这个位置，对就是这么朴实无华的复制粘贴，因此一个大胆的想法就是，我们为什么不吧函数声明专门放在一个.h文件中呢，那么我们只需要在文件前面使用#include \"b.h\"，就可以实现函数声明的作用，是不是很天才！ 另外要注意的是，.h文件并没有被实际编译，因此我们依旧运行g++ main.cc b.cc -o main便可以构建成功了。以及b.cc的头文件不一定是b.h，也可以命名为c.h，因为本质上b.h的内容只是被 copy 进了main.cc中了，他的使命在编译阶段便结束了，至于怎么找到funcB()的实际实现，就是靠链接阶段的符号表了。 以及头文件中可能会造成重复声明的问题，这里只需要在头文件的开头加上一行#pragma once就可以解决问题了。至于古老的项目中，你可能还会见到下面这种写法，只是不太推荐： #ifndef C_H #define C_H void funcB(); #endif 1.3 pointer 首先我们来下一个定义：指针只是存储内存地址的整数。 int main() { int var = 8; int* ptr = \u0026var; } 因此本质上来看，为什么变量要指定类型呢？答案是需要知道实际用几个字节来存储该变量的值。那么指针指定的变量难道也是为了告诉编译器需要用几个字节来存储吗？No，No，No，如果真这么简单我也不会在这里花一段话来讲了，本质上来看指针存的只是内存中某一个位置的地址值，难道地址大小还不一样吗计算机哈哈哈，所以比如如果是64位的机器，那么默认指针都需要用8B来存啊，这都不用用户去说编译器就能自动知道。但是拿到这个地址值之后，你知道要读多少位吗？是读8位的char，还是32位的int呢？这就需要事先告诉编译器了，因此指针的类型是告诉编译器如果*ptr，编译器需要去读多少字节。 1.4 reference 首先我们来下一个定义：引用只是指针的语法糖。 可以简单理解为引用是一种别名，引用只能引用已经存在的变量，引用本身不是创建变量，因此它并不占用内存。他们并没有真正的存储空间。 要注意的是，c语言中常见的\u0026a的是意思是变量a的地址，引用是跟在类型后面的，实际是类型的一部分，我们会看到int\u0026 ref = a，这里就是引用类型了。 而至于什么时候是引用，什么时候是地址，那就看上下文了，跟在类型","date":"2025-08-29","objectID":"/cpp%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:2:0","tags":["编程"],"title":"cpp学习笔记","uri":"/cpp%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["编程"],"content":"2. 高级特性 ","date":"2025-08-29","objectID":"/cpp%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:3:0","tags":["编程"],"title":"cpp学习笔记","uri":"/cpp%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["编程"],"content":"Linux ","date":"2025-08-29","objectID":"/cpp%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:3:1","tags":["编程"],"title":"cpp学习笔记","uri":"/cpp%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["编程"],"content":"概率算法 首先我们需要区分一下概率算法和确定性算法的区别：在同一个输入实例上，每次执行的结果不尽相同。 ","date":"2025-07-04","objectID":"/%E7%AE%97%E6%B3%95%E7%90%86%E8%AE%BA/:1:0","tags":["编程"],"title":"算法理论","uri":"/%E7%AE%97%E6%B3%95%E7%90%86%E8%AE%BA/"},{"categories":["编程"],"content":"数字概率算法 特点： 主要用于找到一个数字问题的近似解 $\\pi$ 值计算 ","date":"2025-07-04","objectID":"/%E7%AE%97%E6%B3%95%E7%90%86%E8%AE%BA/:1:1","tags":["编程"],"title":"算法理论","uri":"/%E7%AE%97%E6%B3%95%E7%90%86%E8%AE%BA/"},{"categories":["编程"],"content":"Sherwood算法 特点： 当某些确定算法解决一个特殊问题时的平均时间比最坏时间快得多时，我们可以使用Sherwood算法来减少，甚至是消除好的和坏的实例之间的差别。 对于一个确定性算法，它的平均时间很容易计算： T（确定性算法平均时间）= （每次执行的时间之和）/ （执行总次数） 但是会存在这样一个不好的情况：某次执行的时间远远大于平均执行时间，比如最坏情况。 设A是一个确定算法，$t_A(x)$是解某个实例x的执行时间，设$n$是一整数，$X_n$是大小为n的实例的集合。假定$X_n$中每一个实例是等可能出现的，则算法A解一个大小为$n$的实例的平均执行时间为：$\\bar{t}A(n) = \\sum{x \\in X_n} t_A(x) / |X_n|$ 这里无法消除存在一个size为n的实例，使得：$t_A(x) » \\bar{t}_A(n)$ 这时候我们就可以考虑设计一个概率算法B，对每个size为n的实例x，使得： $$ t_B(x) \\approx \\bar{t}_A(n) + s(n) $$ 这里$t_B(x)$是算法B在实例x上的期望值，s(n)是概率算法B为了取得均匀性所付出的成本。 虽然算法B的执行时间也可能偶然地在某一个实例x上$»\\bar{t}_A(n) + s(n)$，但这种偶然性行为只是由于算法所做的概率选择引起的，与实例x本身没有关系。因此，不再有最坏情况的实例，但有最坏的执行时间。 Sherwood 一般方法是： 1. 将被解的实例变换到一个随机实例。// 预处理 2. 用确定算法解此随机实例，得到一个解。 3. 将此解变换为对原实例的解。 // 后处理 ","date":"2025-07-04","objectID":"/%E7%AE%97%E6%B3%95%E7%90%86%E8%AE%BA/:1:2","tags":["编程"],"title":"算法理论","uri":"/%E7%AE%97%E6%B3%95%E7%90%86%E8%AE%BA/"},{"categories":["编程"],"content":"Las Vegas算法 特点： 可能不时地要冒着找不到解的风险，算法要么返回正确的解，要么随机决策导致一个僵局。若算法陷入僵局，则使用同一实例运行同一算法，有独立的机会求出解。成功的概率随着执行时间的增加而增加。 首先我们来看看LV算法与Sherwood算法的比较： Sherwood算法不算很优，因为它只改进确定性算法的最坏情况，所以平均执行时间与确定性算法相差无几。为了提高平均执行时间，就采用Las Vegas算法。 Sherwood算法能够计算出一个给定实例的执行时间上界，因为它总是能够正确运行，所以每次都有一定的执行时间，取最大值就是上界。Las Vegas的时间上界可能不存在，因为它可能找不到解陷入死循环。 算法的一般形式： LV(x, y, success) —— x 是输入的实例，y 是返回的参数，success是布尔值， true 表示成功，false 表示失败 $p(x)$ —— 对于实例x，算法成功的概率 $s(x)$ —— 算法成功时的期望时间 $e(x)$ —— 算法失败时的期望时间 设$t(x)$是算法找到一个正确解的期望时间，易得 $t(x)=p(x)s(x)+(1-p(x))(e(x)+t(x))$ 解得 $t(x) = s(x) + \\frac{1 - p(x)}{p(x)} e(x)$ ","date":"2025-07-04","objectID":"/%E7%AE%97%E6%B3%95%E7%90%86%E8%AE%BA/:1:3","tags":["编程"],"title":"算法理论","uri":"/%E7%AE%97%E6%B3%95%E7%90%86%E8%AE%BA/"},{"categories":["编程"],"content":"Monte Carlo算法 特点： MC算法偶然会犯错，但它无论对何实例均能以高概率找到正确解。当算法出错时，没有警告信息。 定义1：设p是一个实数，且1/2\u003cp\u003c1，若一个MC算法以不小于p的概率返回一个正确的解，则该MC算法称为p-正确，算法的优势（advantage）是 p-1/2. 定义2：若一个MC算法对同一实例决不给出两个不同的正确解，则该算法称是相容的（consistent）或一致的。 定义3：(偏真算法)为简单起见，设MC(x)是解某个判定问题，对任何x，若当MC(x)返回true时解总是正确的，仅当它返回false时才有可能产生错误的解，则称此算法为偏真的(true-biased)。 定义4：(偏$y_0$算法)更一般的情况不再限定是判定问题，一个MC是偏$y_0$的($y_0$是某个特定解)，如果存在问题实例的子集$X$使得： 若被解实例$x\\notin X$，则算法MC(x)返回的解总是正确的(无论返回$y_0$还是非$y_0$)；若$\\forall x \\in X$，正确解是$y_0$ ，但MC并非对所有这样的实例$x$都返回正确解。 $\\implies$ 若返回$y_0$，解一定正确。 设MC是一个一致的、$p$-correct和偏 $y_0$ 的蒙特卡洛算法，$x$ 是一个实例，$y$ 是MC(x)返回的解，可分为如下2种情形讨论： case1: $y=y_0$ 若$x\\notin X$，则算法MC总是返回正确解，因此 $y_0$ 确实是正确的。 若$x\\in X$，算法返回的正确解必定是 $y_0$。这两种情况均可得到结论：$y_0$ 是一个正确解。 case2: $y \\ne y_0$ 若$x\\notin X$，则 $y$ 是正确解。 若$x\\in X$，因为正确解是 $y_0$，故 $y$ 是错误解，此出错概率不超过 $1-p$。 例： 重复调用一个一致的，$p$-正确的，偏真的MC算法$k$次，可以得到一个出错概率是多少的算法？ 由单个算法出错概率为$(1-p)$得， 得出全错概率为全错：$(1-p)^k$ ","date":"2025-07-04","objectID":"/%E7%AE%97%E6%B3%95%E7%90%86%E8%AE%BA/:1:4","tags":["编程"],"title":"算法理论","uri":"/%E7%AE%97%E6%B3%95%E7%90%86%E8%AE%BA/"},{"categories":["编程"],"content":"分布式算法 分布式计算和并行计算区别： 分布式计算的任务通常是相互独立的且实时性要求不高，这样哪怕一台机器出故障，也不影响其他机器，只需要重新启动一个机器去执行； 并行计算是实时性高，且任务之间相关性强。 分布式系统的难点在于： 缺乏全局时间（无法保证所有机器的绝对时间和相对时间都确定） 缺乏全局状态信息（不存在全知全能的上帝） 缺乏统一模式 输入不同 消息顺序不同 执行速率不同 故障不同 分布式模型： 异步共享存储模型：用于紧耦合机器，通常情况下各处理机的时钟信号不是来源于同一信号源 异步msg传递模型：用于松散耦合机器及广域网 同步msg传递模型：这是一个理想的msg传递系统。该系统中，某些计时信息（如msg延迟上界)是已知的，系统的执行划分为轮执行，是异步系统的一种特例。 异步共享存储模型主要是同步计算考虑的模型，我们主要需要考虑的是异步msg传递模型，因为这是现实中最最常见的一种情况。 至于同步msg传递模型，显示中是不可能存在的，因为时钟是漂移的，没有全局时间，同步是不可能在现实中完美存在的。但是这种理想模型是有价值的，由于存在延迟上届，因此超过这个时间我们可以认为一定会接受到消息，因此我们就可以在超过这个时间再做下一件事情，也就是把系统变成按轮来同步执行了。而这个特性就会非常方便我们先在这个简单的环境条件下设计算法，然后再将其推广到实际情况中。以及这种标准的简单环境条件，方便我们去定量评价一个系统的好坏。 错误的种类： 初始死进程：指在局部算法中没有执行过一步 崩溃错误(损毁模型)：指处理机没有任何警告而在某点上停止操作 拜占庭错误：一个出错可引起任意的动作,即执行了与局部算法不一致的任意步。拜占庭错误的进程发送的消息可能包含任意内容 拜占庭错误是恶性故障，因为他会影响到系统的其他。前两种属于良性故障。 ","date":"2025-07-04","objectID":"/%E7%AE%97%E6%B3%95%E7%90%86%E8%AE%BA/:2:0","tags":["编程"],"title":"算法理论","uri":"/%E7%AE%97%E6%B3%95%E7%90%86%E8%AE%BA/"},{"categories":["编程"],"content":"消息传递系统中的基本算法 形式化模型 首先我们给出msg传递系统这样一个形式化模型定义： 我们给出 $G(V,E)$ 这样一个无向图的概念，处理机节点集合 $V= \\lbrace p_0,p_1,\\dots,p_{n-1} \\rbrace$，$\\exists p_ip_j$表示在处理机$P_i$和$p_j$之间存在一条双向信道$E_k$（这里我们统一假设信道都是双向了，下面遵循这个约定） 分布式算法是由所有处理机节点上的分布式程序统一构成的，是一个总和的概念。 由于是同步msg传递模型，所以处理机会在理论上的msg延迟上界时候后才会去取消息，因此每个处理机都需要有buf缓冲区来预存提前到的消息，因此我们在每条双向信道 $E_k$ 的处理机 $p_i$ 处都设计一个 $outbuf_i$ 和 $inbuf_i$，分别用来缓存接受到的消息和发送的消息。 因此对于每个处理机 $p_i$ 来说，都会有两个msg集合，$outbuf_i$[] 和 $inbuf_i$[] $outbuf_i[l]$： $p_i$ 经第$l$条关联的信道发送给邻居，但尚未传到邻居的msg。 $inbuf_i[l]$： 在 $p_i$ 的第$l$条关联的信道上已传递到 $p_i$，但尚未经过 $p_i$ 内部计算步骤处理的msg。 我们假设有一个上帝，在第0秒给 $outbuf_i$[] 和 $inbuf_i$[] 照了个相，内容就是两个msg集合里的内容，我们记为状态 $q_{i0}$,同理，第1秒状态为 $q_{i1}$，第j秒状态就为 $q_{ij}$,这一连串的状态所构成的状态集我们就叫做 $Q_i$，因此每个处理器 $p_i$ 可以模型化为一个具有状态集 $Q_i$ 的状态机。 进一步，在第0秒时，状态机 $q_i$ 的状态为 $q_{i0}$, 状态机 $q_j$ 的状态为 $q_{j0}$,这时候我们已经不满足于只对单个状态机进行照相了，我们在第 $t$ 秒时，对所有状态机的状态 $q_{0t}，q_{1t},\\dots,q_{it}$,统一照了张相，我们把它叫做配置。 初始配置就是所有初始状态组成的配置。 而状态的变化我们就可以叫做状态转移，我们将其抽象为一个转移系统，下面我们介绍这个转移系统的形式化定义：状态按离散步骤（事件/转移）变化的系统。 定义1. 转移系统是一个三元组 $S=\\lbrace C,\\to,I \\rbrace$ 其中$C$是配置集（所有配置的集合），$I$是初始配置的一个子集（表示转移系统的开始位置，如果不是子集就不合法了），$\\to$是$C$上的一个二元转移关系，$\\gamma \\to \\delta$ 代表从配置 $\\gamma$ 转移到配置 $\\delta$。 定义2. 我们记转移系统 $S$ 的一次执行的最大序列 $E=(r_0,r_1,\\dots)$,其中 $r_0 \\in I$ 且对 $\\forall i \\ge 0$,都有 $r_i \\to r_{i+1}$。我们定义终止配置 $\\gamma$ 为不存在 $\\delta$，使得 $\\gamma \\to \\delta$。那么对于序列 $E$,如果他是无限的，或者以终止配置 $\\gamma$ 结束的，我们就称这样的序列为最大的。 这里的 $r_0 \\in I$ 很好理解，因为都是从初始配置开始出发的。 定义3. 如果存在序列 $\\gamma \\to \\gamma _1 \\to \\gamma _2 \\dots \\to \\gamma _k = \\delta$，那么我们称 $\\delta$ 是由 $\\gamma$ 可达的。 如果$\\delta$ 是由初始配置可达的，则称 $\\delta$ 是可达的。 系统里所发生的事情均被模型化为事件，对于msg传递系统，有两种： comp(i)——————计算事件，代表处理器 $p_i$ 的一个计算步骤。其中，$p_i$ 的转换函数被用于当前可访问状态 del(i,j,m)—————传递事件，表示msg $m$ 从 $p_i$ 传送到 $p_j$ 系统在时间上的行为被模型化为一个执行。它是一个由配置和事件交错的序列。该序列须满足各种条件，主要分为两类： safety条件（安全性）：表示某个性质在每次执行中每个可到达的配置里都必须成立 liveness条件(活跃性)：表示某个性质在每次执行中的某些可达配置里必须成立。 对特定系统，满足所有要求的安全性条件的序列称为一个执行；若一个执行也满足所有要求的活跃性条件，则成为容许执行（合法的执行）。 下面我们介绍三个衡量模型性能的方式： Msg复杂度：算法在所有容许的执行上发送msg总数的最大值(同步和异步系统) 时间复杂度： 同步系统：最大轮数，即算法的任何容许执行直到终止的最大轮数。 异步系统：假设：1.节点计算任意有限数目事件的时间为0；2.一条消息发送和接收之间的时间至多为1个时间单位。在这两条假设的前提之下，时间复杂度就是所有计时容许执行中直到终止的最大时间。（也就是说有限计算不花时间，然后如果接受和发送时间太长，我们就不让他参与这次执行中） 消息复杂度：消息总数/消息中总的位数长度。请注意和Msg复杂度的不同。 生成树上的广播和敛播 在一个分布式系统中，广播和敛播是最重要的两个算法，因为msg的传递都需要靠这两个算法。 广播（Broadcast）：在分布式系统中，一个节点向所有其他节点发送同一条消息的过程。目标是让系统中所有节点（或指定组）接收消息 敛播（Gather，也称为收集、汇聚）：与广播相反，是所有节点向一个中心节点（或根）发送消息的过程，最终中心节点收集所有节点的信息。比如，子节点向根汇报状态，根汇总数据。 由于广播的特性，如果是普通图的结构，就会发生广播风暴问题，以及广播/敛播在树结构下才能达到消息复杂度最优，因此我们需要将分布式系统设计成**最小生成树(MST)**的结构。 广播算法： 根节点发送Msg给孩子。收到Msg的节点转发Msg给孩子。 Msg复杂度：$O(n-1)$，因为生成树每条边有一个Msg 时间复杂度：$O(D)$，$D$为生成树直径 敛播算法： 汇集是从所有节点收集信息至根 Msg复杂度：$O(n-1)$，因为生成树每条边有一个Msg 时间复杂度：$O(D)$，$D$为生成树直径 构造生成树 上节讨论的广播和敛播都是建立在已知生成树的拓扑结构，因此我们还需要思考如何来构造生成树 指定根构造生成树 flooding（洪泛）算法 算法思想：设 $p_r$ 是特殊处理器。从 $p_r$ 开始，发送M到其所有邻居。当处理器 $p_i$ 第$1$次收到消息M（不妨设此msg来自于邻居$p_j$）时，$p_i$ 发送M到除 $p_j$ 外的所有邻居。 Msg复杂度：$O(2m-(n-1))$,$m$是信道总数。我们考虑一些延迟误差，比如有3个处理器 $p_0、p_1、p_2$,$p_0$分别向$p_1$和$p_2$转发ms,然后$p_1$和$p_2$同时收到ms，那么此时$p_1$和$p_2$又会同时相互转发，所以一条信道 $E_k$ 就可能有两条ms，但是注意对于每个$p_i$，它是肯定不会对它收到的第1条M来自的邻居$p_j$发送M,因此需要减掉 $n-1$。 时间复杂度：$O(D)$，$D$为生成树直径。 我们可以通过改造flooding算法来设计一种构造生成树的算法： 算法思想： 首先，$p_r$发送M给所有邻居，$p_r$为根 当$p_i$从某邻居$p_j$收到的M是第1个来自邻居的msg时，$p_j$是$p_i$的双亲；若$p_i$首次收到的M同时来自多个邻居，则用一个comp事件处理自上一comp事件以来的所有已收到的msgs，故此时，$p_i$可在这些邻居中任选一个邻居$p_j$做双亲。 双亲一旦选定就绝不更改。当$p_i$确定双亲是$p_j$时，发送给$p_j$，并向此后收到发来M的处理器发送msg。 $p_i$向那些尚未发M给$p_i$(或已发M但尚未到达$p_i$)的邻居转发M之后，等待这些邻居发回响应msg：或。那些回应的邻居是$p_i$的孩子。 当$p_i$发出M的所有接收者均已回应（或)，则$p_i$终止。将parent和children边保留即为生成树。 Msg复杂度：由于算法只是在flooding算法上增加了回应（或)，因此也就是2倍关系，所以也是$O(m)$ 时间复杂度：$O(D)$，$D$为生成树直径。 上述讨论的算法在同步模型下，也可以工作，同时所构造的生成树一定是一棵BFS树 但是在异步模型下，构造的树就不一定是一棵BFS树了 那么自然而然我们会好奇：如何构造DFS生成树呢？ 算法思想： * Msg复杂度：$O(m)$ 时间复杂度：$O(m)$ 不指定根时构造生成树 已知条件：个具有m条边和n个节点的网络，自发启动的节点共有p个，其中ID 值最大者的启动时间为t Msg 复杂度：$O(pn^2)$。最坏情况下，每个处理器均试图以自己为根构造一棵DFS树。 因此，Alg2.4 的msg复杂性至多是Alg2.3的n倍：O(m*n) 时间复杂度： 时间复杂度：$O(t+m)$ ","date":"2025-07-04","objectID":"/%E7%AE%97%E6%B3%95%E7%90%86%E8%AE%BA/:2:1","tags":["编程"],"title":"算法理论","uri":"/%E7%AE%97%E6%B3%95%E7%90%86%E8%AE%BA/"},{"categories":["编程"],"content":"环上选举算法 Leader选举问题 异步环：下界$O(nlgn)$ 同步环：上界$O(n)$和下界$O(nlgn)$ 非均匀： Msg 复杂度：$n·(i+1)$，i为最终Leader的id 时间复杂度：$n·(i+1) $ 均匀： Msg 复杂度：$O(4n)$， 时间复杂度：$O(n· 2^i)$ i为最终Leader的id ","date":"2025-07-04","objectID":"/%E7%AE%97%E6%B3%95%E7%90%86%E8%AE%BA/:2:2","tags":["编程"],"title":"算法理论","uri":"/%E7%AE%97%E6%B3%95%E7%90%86%E8%AE%BA/"},{"categories":["编程"],"content":"近似算法 对于一些NP hard问题，我们只能使用$2^n$数量级的时间来求取最优解，但是近似算法给了我们一条新的思路，我们可以牺牲结果的部分准确性，比如只用$n^k$次方的时间，来求得问题的次优解。这个对于很多情况来说都是非常重要的。 以及对于次优解和最优解之间的误差，我们该如何去控制，如果我们能有效控制误差，那么对于很多优化问题都非常有效。 由于课程安排，近似算法这学期并没有讲，因此只做简单了解。 ","date":"2025-07-04","objectID":"/%E7%AE%97%E6%B3%95%E7%90%86%E8%AE%BA/:3:0","tags":["编程"],"title":"算法理论","uri":"/%E7%AE%97%E6%B3%95%E7%90%86%E8%AE%BA/"},{"categories":["数学"],"content":"同余 首先我们给出两个数同余的定义： $$ a \\equiv b \\pmod{p} \\iff a - b = pk $$ 对某两个整数 $a,b$,若它们除以**正整数** $p$ 所得的余数相等,则称 $a,b$ 对模 $p$ 同余，一般记作： $a \\equiv b \\pmod{p}$ 下面我们思考一个问题： Q. 请问 $2362837 \\times 1419853$ 的个位数字应该是多少？ 显然，大部分人本能想法就是，根据人类的乘法规则，列出两个数字列项相乘，那么最后结果的个位数只会由这两个乘数的个位数的乘积决定，比如这道题明显就是 $(7\\times 3) \\mod 10=1$。 仔细品味这个例子，其实蕴含着一个深刻的道理： $$ x \\equiv r \\pmod{10},\\ y \\equiv s \\pmod{10} \\\\ \\implies xy \\equiv rs \\pmod{10} $$ 证明其实也很简单： $$ \\begin{align*} x \u0026= 10x' + r,\\ y = 10y' + s \\\\ xy \u0026= (10x' + r)(10y' + s) \\\\ \u0026= 10^2 x'y' + 10x's + 10y'r + rs \\end{align*} $$ 当然了，这里的$10$也没有特殊性，我们可以推广到任意的 $p$ ： $$ \\begin{align*} x \u0026\\equiv r \\pmod{p},\\ y \\equiv s \\pmod{p} \\\\ \u0026\\implies xy \\equiv rs \\pmod{p} \\\\ \\\\ x \u0026= px' + r,\\ y = py' + s \\\\ xy \u0026= (px' + r)(py' + s) \\\\ \u0026= p^2 x'y' + px's + py'r + rs \\end{align*} $$ 除了乘法，加法其实也是类似的，最后的结论我们可以写为： $$ x \\equiv r \\pmod{p},\\ y \\equiv s \\pmod{p} \\\\ \\implies xy \\equiv rs \\pmod{p} \\quad \\quad \\quad \\quad \\implies x+y \\equiv r+s \\pmod{p} $$ $$ x = px' + r,\\ y = py' + s \\\\ \\begin{alignat*}{2} xy \u0026= (px' + r)(py' + s) \u0026 x + y \u0026= (px' + r) + (py' + s) \\\\ \u0026= p^2 x'y' + px's + py'r + rs \u0026 \u0026= px' + py' + r + s \\end{alignat*} $$ 所以同余有一个很好的性质： 如果你关心的不是一个数字绝对的大小，而只关心他除以$p$的余数，那么任何时候，你都可以放心地扔掉这个具体的数字，而只保留它的余数进行运算就够了。 ","date":"2025-07-01","objectID":"/%E6%95%B0%E8%AE%BA/:1:0","tags":["数学"],"title":"数论","uri":"/%E6%95%B0%E8%AE%BA/"},{"categories":["数学"],"content":"费马小定理 首先我们来看一个非常有意思的现象，假设我们有一个圆，上面有11个点，然后你可以从任何一个位置出发,且第一次出发后到达的点不能是原来的位置，每次移动相同的距离$a$，那么你会惊奇的发现，你会完美无瑕的走过每一个顶点之后，再回到原来的位置，期间不会走过重复的位置。 你肯定会好奇这到底是为什么呢？以及这个11是随便取的数吗？ 答案当然不是的。这里的11是一个质数。 我们不妨先思考下面这个问题： Q. 对于一个质数$p$来说，我们假设$a$不是$p$的倍数，也就是$a \\ne p k_0$。 那么对于 $a、2a、3a、\\dots、(p-2)a、(p-1)a$，是否存在两个数，这两个数对模 $p$ 同余吗？ 答案显然是不存在。 我们需要证明的是 $xa \\equiv ya \\pmod{p}$,其中 $1\\le y \u003c x \\le p-1$,也即证明 $(x-y)a=pk$,又由乘法分配律可知，左边式子中的 $x-y$ 和 $a$ 需要找到至少一个数，有因数 $p$,但是显然由定义 $a$ 不是，而 $x-y\u003cp$，显然也做不到，因此永远无法找到这样的两个数。 于是上面这个很有意思的现象似乎就可以解释了。 这里圆上点的数量其实就是 $p$,每次我们出发移动的距离其实就是 $a$，比如我们从 $0$ 出发，第一次走到 $a$,第二次走到 $2a$,其实就是我们上面讨论的 $a、2a、3a、\\dots、(p-2)a、(p-1)a$ 这些数，而这些数对 $p$ 取余的结果就是他们每次到达的位置，确实不存在一样的，这就是上面神奇现象的数学原理。 解释完上面这个有意思的现象，我们再继续在刚刚的例子中挖掘一些有意思的东西，比如说： Q. 你知道 $a、2a、3a、\\dots、(p-2)a、(p-1)a$ 除以 $p$ 的余数的集合里有哪些数吗？ 显然正好是 $1、2、3、\\dots、 p-1$。这些数也恰好和 $a、2a、3a、\\dots、(p-2)a、(p-1)a$ 中的某个数同余，因此由上面的乘法性质可得： $$ \\begin{align*} \u0026a^{p-1}(p-1)! \\equiv (p-1)! \\pmod {p} \\\\ \u0026\\implies (a^{p-1}-1)(p-1)!=pk \\end{align*} $$ 又由乘法分配律可知，左边式子中的 $a^{p-1}-1$ 和 $(p-1)!$ 需要找到至少一个数，有因子 $p$,但是显然 $(p-1)!$ 不存在因子 $p$，因此只能是 $a^{p-1}-1=pk'$，也即： $$ a^{p-1} \\equiv 1 \\pmod{p} \\quad\\quad(a \\ne pk_0) $$ 至此你便自己探索出了鼎鼎大名的费马小定理(^_^) Good Boy! ","date":"2025-07-01","objectID":"/%E6%95%B0%E8%AE%BA/:2:0","tags":["数学"],"title":"数论","uri":"/%E6%95%B0%E8%AE%BA/"},{"categories":["养生"],"content":"晴天需要保证每天至少10min光照，调节褪黑素分泌。 BMI需要小于22 ","date":"2025-06-28","objectID":"/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%BB%B6%E5%AF%BF%E6%8C%87%E5%8D%97/:0:0","tags":["有趣","养生"],"title":"程序员延寿指南","uri":"/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%BB%B6%E5%AF%BF%E6%8C%87%E5%8D%97/"},{"categories":["养生"],"content":"1.术语 ACM: All-Cause Mortality / 全因死亡率 ","date":"2025-06-28","objectID":"/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%BB%B6%E5%AF%BF%E6%8C%87%E5%8D%97/:1:0","tags":["有趣","养生"],"title":"程序员延寿指南","uri":"/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%BB%B6%E5%AF%BF%E6%8C%87%E5%8D%97/"},{"categories":["养生"],"content":"2.目标 稳健的活得更久 ","date":"2025-06-28","objectID":"/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%BB%B6%E5%AF%BF%E6%8C%87%E5%8D%97/:2:0","tags":["有趣","养生"],"title":"程序员延寿指南","uri":"/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%BB%B6%E5%AF%BF%E6%8C%87%E5%8D%97/"},{"categories":["养生"],"content":"3.分析 主要参考：对ACM的学术文献相对较多，可以作为主要参考 增加寿命与ACM关系非线性：显然增加寿命与ACM关系是非线性函数，这里假设 ΔLifeSpan=(1/(1+ΔACM)-1)*10（ΔACM为ACM变化值；公式欢迎优化） 变量无法简单叠加：显然各个变量之间并不符合独立同分布假设，变量之间的实际影响也并不明确 存在矛盾观点：所有的证据都有文献/研究对应，但注意到：有些文献之间有显著矛盾的观点（如对于碳水摄入比例的矛盾）；有些文献存在较大争议（如认为22点前睡觉会提升43%全因死亡率） 研究仅表达相关：所有文献表明的更多是相关而非因果，在阅读时要考虑文献是否充分证明了因果 —— 如某文献表明了日均\u003e=7000步的人有显著低的全因死亡率。但步数少的人可能包含更多长期病患，如果没有合理的排除这块数据，那此文献调查失真 ","date":"2025-06-28","objectID":"/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%BB%B6%E5%AF%BF%E6%8C%87%E5%8D%97/:3:0","tags":["有趣","养生"],"title":"程序员延寿指南","uri":"/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%BB%B6%E5%AF%BF%E6%8C%87%E5%8D%97/"},{"categories":["养生"],"content":"4.理论 输入 固体：吃白肉（-11%～-3% ACM）、蔬果为主（-26%～-17% ACM），多吃辣（-23% ACM），多吃坚果（-27%～-4% ACM），中量碳水、多吃植物蛋白（-10% ACM），少吃超加工食物（-62%～-18%） 液体：喝咖啡（-22%～-12% ACM），喝牛奶（-17%～-10% ACM），喝茶（-15%～-8% ACM），少喝或不喝甜味饮料（否则每天一杯+7% ACM，+多巴胺），戒酒（否则+～50% ACM，无上限） 气体：不吸烟（否则+～50% ACM，-12～-11年寿命） 光照：晒太阳（-～40% ACM） 药物：二甲双胍（糖尿病人相比正常人可以+3年）、复合维生素（-8%癌症风险）、亚精胺（-60%～-30% ACM）、葡萄糖胺（-39% ACM） 输出 运动：每周3次45分钟挥拍运动（-47% ACM） 日常：刷牙（-25% ACM） 睡眠：每天睡7小时全因死亡率最低；且22-24点间最好，早睡+43% ACM，晚睡+15% ACM（存在争议） 上下文 体重：减肥（-54% ACM） ","date":"2025-06-28","objectID":"/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%BB%B6%E5%AF%BF%E6%8C%87%E5%8D%97/:4:0","tags":["有趣","养生"],"title":"程序员延寿指南","uri":"/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%BB%B6%E5%AF%BF%E6%8C%87%E5%8D%97/"},{"categories":["养生"],"content":"5.实战 ","date":"2025-06-28","objectID":"/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%BB%B6%E5%AF%BF%E6%8C%87%E5%8D%97/:5:0","tags":["有趣","养生"],"title":"程序员延寿指南","uri":"/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%BB%B6%E5%AF%BF%E6%8C%87%E5%8D%97/"},{"categories":["养生"],"content":"减肥： 对体重减轻的死亡率风险评估发现，体重从肥胖减轻到超重的成年人与稳定肥胖人群相比，全因死亡率降低了54％（危险比为0.46），然而从成年初期的超 重减轻到中年以前的正常体重的人群的死亡率风险并未降低（风险比为1.12）。 BMI建议： 18.5～24 （梨型身材 22～24，苹果型身材20～22） 杜绝腹部脂肪 ","date":"2025-06-28","objectID":"/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%BB%B6%E5%AF%BF%E6%8C%87%E5%8D%97/:5:1","tags":["有趣","养生"],"title":"程序员延寿指南","uri":"/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%BB%B6%E5%AF%BF%E6%8C%87%E5%8D%97/"},{"categories":["养生"],"content":"运动： 每周 $\\ge150$ min中等强度有氧运动（心率130～150次/min） ","date":"2025-06-28","objectID":"/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%BB%B6%E5%AF%BF%E6%8C%87%E5%8D%97/:5:2","tags":["有趣","养生"],"title":"程序员延寿指南","uri":"/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%BB%B6%E5%AF%BF%E6%8C%87%E5%8D%97/"},{"categories":["养生"],"content":"走路 分析结果表明，每日步数每增加 2000 步，过早死亡的风险就会随之降低 8%～11%，直到每天走 10000 步时达到基本饱和。 ","date":"2025-06-28","objectID":"/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%BB%B6%E5%AF%BF%E6%8C%87%E5%8D%97/:5:3","tags":["有趣","养生"],"title":"程序员延寿指南","uri":"/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%BB%B6%E5%AF%BF%E6%8C%87%E5%8D%97/"},{"categories":["养生"],"content":"晒太阳 上午6:00到10:00之间，下午14:00-18:00之间，UVA的量比UVB要多。 当你的影子是你身高的2倍，甚至更多的时候，紫外线指数最安全，可以不需要任何防护，好好晒一晒。 当你的影子处于身高和身高的2倍之间长度时，安全晒太阳的时长可以控制在20分钟左右。 ","date":"2025-06-28","objectID":"/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%BB%B6%E5%AF%BF%E6%8C%87%E5%8D%97/:5:4","tags":["有趣","养生"],"title":"程序员延寿指南","uri":"/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%BB%B6%E5%AF%BF%E6%8C%87%E5%8D%97/"},{"categories":["养生"],"content":"刷牙 经常不刷牙的人：癌症、慢性阻塞性肺病及肝硬化风险分别增加了9%、12%和25%，过早死亡风险增加25%。 ","date":"2025-06-28","objectID":"/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%BB%B6%E5%AF%BF%E6%8C%87%E5%8D%97/:5:5","tags":["有趣","养生"],"title":"程序员延寿指南","uri":"/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%BB%B6%E5%AF%BF%E6%8C%87%E5%8D%97/"},{"categories":["养生"],"content":"睡眠 在男性中，最佳睡眠实际为7小时，睡眠持续时间≥10小时与全因死亡风险增加34%相关； 且22-24点间最好，早睡+43% ACM，晚睡+15% ACM（存在争议） ","date":"2025-06-28","objectID":"/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%BB%B6%E5%AF%BF%E6%8C%87%E5%8D%97/:5:6","tags":["有趣","养生"],"title":"程序员延寿指南","uri":"/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%BB%B6%E5%AF%BF%E6%8C%87%E5%8D%97/"},{"categories":["编程"],"content":" 由于一直想创建一个属于自己的博客，但是一直没有找到合适的平台，所以最近开始尝试利用 Hugo 和 Github Pages 创建一个静态博客。Hugo 可以很大程度上解决我的一个个人需求：我不希望直接将我的.md文件上传到 Github 上，这样别人就会直接拿到我的笔记和代码，而我希望的是别人只能看到我写的博客。 期间也踩坑了很多次，看了非常多的经验帖，最后花费了两天时间终于大功告成！ 看到这么好看的主页，一切都是值得的(^_^)。 ","date":"2025-06-25","objectID":"/%E5%88%A9%E7%94%A8-hugo-%E5%92%8C-github-pages-%E5%88%9B%E5%BB%BA%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E5%B9%B6%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2/:0:0","tags":["编程"],"title":"利用 Hugo 和 Github Pages 创建静态博客并实现自动部署","uri":"/%E5%88%A9%E7%94%A8-hugo-%E5%92%8C-github-pages-%E5%88%9B%E5%BB%BA%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E5%B9%B6%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2/"},{"categories":["编程"],"content":"1. 环境准备 1.1 下载Go Hugo 是用 go 写的，所以速度很快，因此在下载Hugo 之前还得本地配置 go 环境 1.2 下载Hugo 官官网址：Hugo官网 ","date":"2025-06-25","objectID":"/%E5%88%A9%E7%94%A8-hugo-%E5%92%8C-github-pages-%E5%88%9B%E5%BB%BA%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E5%B9%B6%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2/:0:1","tags":["编程"],"title":"利用 Hugo 和 Github Pages 创建静态博客并实现自动部署","uri":"/%E5%88%A9%E7%94%A8-hugo-%E5%92%8C-github-pages-%E5%88%9B%E5%BB%BA%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E5%B9%B6%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2/"},{"categories":["编程"],"content":"2. 创建博客 2.1 初始化博客 通过hugo new site Blog命令初始化一个 Blog/目录，里面会自动生成一些框架代码 └─Blog ├─archetypes ├─assets ├─content ├─data ├─i18n ├─layouts ├─static └─themes 2.2 下载主题 打开 hugo theme 的网站，选择合适的主题，以LoveIt 举例。 Hugo Themes: https://themes.gohugo.io LoveIt 主题的仓库是: https://github.com/dillonzq/LoveIt. 你可以下载主题的 发布版本 .zip 文件 并且解压放到 themes 目录. 另外, 也可以直接把这个主题克隆到 themes 目录: git clone https://github.com/dillonzq/LoveIt.git themes/LoveIt 或者, 初始化你的项目目录为 git 仓库, 并且把主题仓库作为你的网站目录的子模块: git init git submodule add https://github.com/dillonzq/LoveIt.git themes/LoveIt 主题的兼容性 LoveIt 分支或版本 支持的 Hugo 版本 master(不稳定) ≥ 0.128.0 0.3.X(推荐) 0.128.0 - 0.145.0 0.2.X(过时) 0.68.0 - 0.127.0 ","date":"2025-06-25","objectID":"/%E5%88%A9%E7%94%A8-hugo-%E5%92%8C-github-pages-%E5%88%9B%E5%BB%BA%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E5%B9%B6%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2/:0:2","tags":["编程"],"title":"利用 Hugo 和 Github Pages 创建静态博客并实现自动部署","uri":"/%E5%88%A9%E7%94%A8-hugo-%E5%92%8C-github-pages-%E5%88%9B%E5%BB%BA%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E5%B9%B6%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2/"},{"categories":["编程"],"content":"3. 配置 这里是关键步骤，虽然有点不求甚解，但是真的能够省很多功夫，问题就是后期修改需要经常去翻LoveIt的官方文档。 3.1 文件替换 将myblog/themes/LoveIt/exampleSite路径下的所有文件直接复制到myblog/下覆盖掉。 其中： assets存放全局资源 content存放md文件，即你的文章 static存放静态资源 config.toml为博客配置文件 注：这里我踩坑了非常多的时间，标签和分类功能一直显示找不到这个pages，其实最后发现就是content/目录下不是只有posts/就够了，还需要有about/，categories/,tags/文件夹，才能让标签、分类功能生效，这里最好的方法其实就是把myblog/themes/LoveIt/exampleSite/content里面的所有内容都复制到myblog/content/里 完成上面这步应该就能实现跟LoveIt官网一模一样的效果了。 使用hugo serve命令启动网站来看看效果吧。 3.2 参数修改 下面就是把config.toml配置文件里面的一些参数改成自己想要的了 自己看着改就行 ","date":"2025-06-25","objectID":"/%E5%88%A9%E7%94%A8-hugo-%E5%92%8C-github-pages-%E5%88%9B%E5%BB%BA%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E5%B9%B6%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2/:0:3","tags":["编程"],"title":"利用 Hugo 和 Github Pages 创建静态博客并实现自动部署","uri":"/%E5%88%A9%E7%94%A8-hugo-%E5%92%8C-github-pages-%E5%88%9B%E5%BB%BA%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E5%B9%B6%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2/"},{"categories":["编程"],"content":"4. 部署到 Github 4.1 手动部署 在 Hugo 网站文件夹的根目录（\\Blog）下执行 hugo 命令构建 Hugo 会将构建的网站内容默认保存至网站根目录下的 public/ 文件夹下 你只需要每次将 public/ 文件夹里的内容推送到 Github 仓库即可部署成功 4.2 使用Github Actions自动发布网站 手动部署策略每次都得自己生成静态网站然后推送到仓库，有点太麻烦了。 相较于手动发布网站，用Github Actions自动发布网站达成的效果是，每次需更新网站时，只需将Blog文件夹上传到hugo-blog仓库中，之后Github自动就会更新\u003cusername\u003e.github.io仓库中的内容，无需手动将public文件夹上传到\u003cusername\u003e.github.io仓库中。 这里的 hugo-blog 仓库可以配置成 private，因为你的 .md 文件都在这里 4.2.1 创建access tokens 打开Github网页，点击右上角个人头像，进入Settings界面，点击设置列表中的Developer settings 点击Personal access tokens下的Tokens(classic)，然后点击Generate new token下的Generate new token(classic) image-20250626001837636 生成access token时，勾选workflow，同时把 Expiration 的时间设置为永不过期 image-20250626002003275 最后点击页面下方的Generate token按钮即可。生成完成后如下图，将生成的access token复制下来，以后这个aceess token将不可见。 4.2.2 创建Actions Secret 进入到上面提到的hugo-blog仓库，依次点击Settings、Secrets and Variables、Actions、New repository secret 如下图，输入Name和Secret，Name可自定义，这里取名为HUGO_TOKEN，Secret即为上面生成的access token。 最后点击Add secret完成。 4.2.3 创建Github Action 在.github/workflows文件夹下创建一个yaml文件，比如.github/workflows/hugo_deploy.yaml，文件的内容如下： name: GitHub Pages on: push: branches: - master pull_request: jobs: deploy: # 这里指定ubuntu为指定版本, 比如 ubuntu-22.04 runs-on: ubuntu-22.04 concurrency: group: ${{ github.workflow }}-${{ github.ref }} steps: - uses: actions/checkout@v4 with: submodules: true fetch-depth: 0 - name: Setup Hugo uses: peaceiris/actions-hugo@v3 with: # 运行hugo version可以查看本地hugo版本 # 这里使用最新版本的hugo, 也可写具体的版本号, 与本地hugo版本保持一致, 比如 0.138.0 hugo-version: 0.145.0 # 查看hugo version的结果，如果本地是extended版本，就设置成true，反之设置成false extended: false - name: Build run: cd Blog \u0026\u0026 hugo -D # 命令可以修改，比如草稿文章也想发表可改成hugo -D - name: Deploy uses: peaceiris/actions-gh-pages@v3 if: github.ref == 'refs/heads/master' with: # HUGO_TOKEN就是上面Actions Secret取的名字，要与自己取的名字保持一致 personal_token: ${{ secrets.HUGO_TOKEN }} # \u003cusername\u003e替换成自己的用户名 external_repository: ThisingL/thisingl.github.io # 现在默认分支都用main，比如用的是master分支，则改为master publish_branch: master publish_dir: ./Blog/public # 可选配置, 每次博客更新后, 本仓库会自动往\u003cusername\u003e.github.io仓库提交一次更新后的网站内容 # 添加该项配置后, \u003cusername\u003e.github.io仓库的提交信息就会使用本仓库的提交信息 commit_message: ${{ github.event.head_commit.message }} # cname: https://huxinme.top # 填写自己的自定义域名, 如果没有自定义域名, 删除该项配置 4.2.4 发布网站 public和resources文件夹都是Hugo生成静态网站时创建的，因此在.gitignore文件中可以添加以下内容 .hugo_build.lock /public/* /resources/ # hugo生成的文件，也可忽略 最后，将Blog文件夹提交到hugo-blog仓库中即可。 提交到Github上后，稍等一会儿，打开\u003cusername\u003e.github.io就可以看到更新后的网站了。 ","date":"2025-06-25","objectID":"/%E5%88%A9%E7%94%A8-hugo-%E5%92%8C-github-pages-%E5%88%9B%E5%BB%BA%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E5%B9%B6%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2/:0:4","tags":["编程"],"title":"利用 Hugo 和 Github Pages 创建静态博客并实现自动部署","uri":"/%E5%88%A9%E7%94%A8-hugo-%E5%92%8C-github-pages-%E5%88%9B%E5%BB%BA%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E5%B9%B6%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2/"},{"categories":["编程"],"content":"5. 日常使用流程 使用命令hugo new posts/新笔记/新笔记.md, 在 content\\posts\\目录下新建文件夹 新笔记，文件夹下新建 新笔记.md文件，文件图片放在 新笔记\\images\\ 文件夹下，这样在typora中设置图片位置为 ./images即可。这里还需要创建一个新笔记posts/新笔记/新笔记.md，由于 Hugo 在渲染 Markdown 文档时会根据 _/*/\u003e\u003e 之类的语法生成 HTML 文档, 并且有些转义字符形式的文本内容 (如 \\(/\\)/\\[/\\]/\\\\) 会自动进行转义处理, 因此需要对这些地方进行额外的转义字符表达来实现自动渲染。所以一个好的解决方法是：多行公式前使用\u003cdiv\u003e标签，但是这个就会带来一个新问题：Typora中不好看公式了。因此就可以每次在posts/新笔记/新笔记.md中进行笔记书写，然后使用我下面提供的shell脚本来将新笔记.md复制到posts/新笔记/index.md中将行间公式前统一加上 \u003cdiv\u003e标签。 这里我写了一个单行shell脚本,可以一件把将新笔记.md生成符合hugo要求的index.md,直接复制到bash里运行就可以了 find . -maxdepth 1 -name \"*.md\" ! -name \"index.md\" -print \u003e tmp_list \u0026\u0026 \\ file_count=$(wc -l \u003c tmp_list) \u0026\u0026 \\ if [ \"$file_count\" -eq 0 ]; then echo \"错误：未找到任何非index.md的.md文件\" \u0026\u0026 rm tmp_list; \\ elif [ \"$file_count\" -gt 1 ]; then echo \"错误：找到多个非index.md的.md文件：\" \u0026\u0026 cat tmp_list \u0026\u0026 rm tmp_list; \\ else target_file=$(head -n1 tmp_list) \u0026\u0026 echo \"正在处理文件: $target_file\" \u0026\u0026 \\ awk 'BEGIN {in_math=0} {line=$0; output=\"\"; while(match(line, /\\$\\$/)) {pre=substr(line,1,RSTART-1); rest=substr(line,RSTART); if(in_math==0) {output=output pre \"\u003cdiv\u003e$$\"; in_math=1} else {output=output pre \"$$\"; in_math=0} line=substr(rest,3)} output=output line; print output}' \"$target_file\" \u003e index.md \u0026\u0026 \\ echo \"已将处理后的内容写入 index.md\" \u0026\u0026 rm tmp_list; fi 将更新 git push 到hugo-blog仓库中，网站便更新完毕。 注：这里还有一个坑，参考了Hugo 博客插入图片的方法 | Cassius’s Blog 由于 Hugo 生成的是静态博客，因此插入图片是一件相对比较麻烦的事情。当然，一个简单的方法就是采用图床，不过大部分图床都需要收费，免费的也不能保证稳定性，而我们的博客所用的图片数量也并不算多，所以我们可以采取随 markdown 源文件一起存储的方法。 Hugo 普遍的新建博文的方式是 hugo new posts/new-post.md，这样我们可以将图片都存放在 Blog/static/ 目录下，这样经过编译之后图片会存放到网站的根目录。不过如果这样，那么在编写博客的时候编辑器就没办法显示图片，只能凭感觉了。而放到其他目录时，编译后的网站又不能识别。 一个较为优雅的方式就是 hugo new posts/new-post/index.md 将新的博文创建成一个文件夹，将 markdown 源文件命名为 index.md，再在文件夹内创建 pics 文件夹，将图片放入该文件夹，在编写博文插入图片时使用相对路径，即 pics/1.png，这样在编辑器中就可以看到图片了。 而当网站编译完成之后，文件夹的格式就会如下所示 first-post pics 1.png index.html index.html 文件与 pics 文件夹同级，网站同样也可以识别 html 文件中的图片路径。 这里一定要命名为index.md，不可以命名为 新笔记.md，不然你会发现编译后网站图片位置就不再同级网站文件夹下了，上面操作也就会失效(这里花了我起码2小时来发现这个bug所在) ","date":"2025-06-25","objectID":"/%E5%88%A9%E7%94%A8-hugo-%E5%92%8C-github-pages-%E5%88%9B%E5%BB%BA%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E5%B9%B6%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2/:0:5","tags":["编程"],"title":"利用 Hugo 和 Github Pages 创建静态博客并实现自动部署","uri":"/%E5%88%A9%E7%94%A8-hugo-%E5%92%8C-github-pages-%E5%88%9B%E5%BB%BA%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E5%B9%B6%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2/"},{"categories":["数学"],"content":"MAB/多臂老虎机模型（Multi-armed Bandit） 数学家将做我们生活中面临的选择困境抽象为了一个数学模型：MAB/多臂老虎机模型（Multi-armed Bandit） 假如你进入了一个赌场，面前有一台有 $K$ 根拉杆的老虎机，拉动每一根拉杆都对应一个关于奖励的概率分布。我们在各根拉杆的奖励概率分布未知的情况下，操作 $T$ 次拉杆，目标是获得尽可能高的累计奖励。由于奖励的概率分布是未知的，因此我们需要在“探索”和“利用”中进行权衡 探索：尝试其他拉杆，由大数定理可得频率会稳定于概率，所以可以更新其他拉杆的期望奖励估计。可能会牺牲短期收益，但长期可能发现更高奖励的拉杆。 利用：贪心的选择当前期望奖励估计最大的拉杆来最大化短期收益。 多臂老虎机问题可以表示为一个元组 $\\langle \\mathcal{A}, \\mathcal{R} \\rangle$, 其中： $\\mathcal{A}$为动作集合，其中一个动作表示拉动一根拉杆。若多臂老虎机有 $K$ 根拉杆，那么动作空间就是集合 ${a_1, \\ldots, a_K}$ ，我们用$a_t \\in \\mathcal{A}$表示任意一个动作 $a_t$ 。 $\\mathcal{R}$ 为奖励概率分布，拉动每一根杠杆的动作 $a_t$ 都对应一个奖励概率分布 $\\mathcal{R}(r \\mid a_t)$，不同拉杆的奖励概率分布通常是不同的。 假设每个时间步只能拉动一根拉杆，多臂老虎机的目标为最大化一段时间步 $T$ 内累积的奖励：$\\max \\sum_{t=1}^T r_t, r_t \\sim \\mathcal{R}(\\cdot \\mid a_t)$，其中 $a_t$ 代表在第 $t$ 时间步拉动某一拉杆这一动作， $r_t$ 代表动作 $a_t$ 获得的奖励。 在2002年，由Peter Auer等三人提出了一个简单到出人意料的算法：上置信界算法（UCB，Upper Confidence Bound）。 从概率论中我们可以知道：假设我们定义 $\\Delta \\mu$ 为样本均值 $\\bar{X}$ 的标准误差（可以理解为样本均值与总体均值的平均差异程度），那么 $\\Delta \\mu = \\frac{\\sigma}{\\sqrt{n}}$，其中 $\\sigma$ 为标准差， $n$ 为样本容量。这里由于我们对老虎机拉杆的奖励概率分布是未知的，所以这个里 $\\sigma$ 是无法精确计算得到的，所以我们将这个标准误差改写成 $\\Delta \\mu = \\frac{c}{\\sqrt{n}}$，这里的 $c$ 的取值就需要根据具体情况来进行初始化了。 对于 $\\forall a_t \\in \\mathcal{A}$，期望奖励估计更新为 $\\hat{Q}(a_t) = \\hat{Q}(a_t) + \\frac{1}{N(a_t)} \\left[ r_t - \\hat{Q}(a_t) \\right]$，由 Hoeffding 不等式（霍夫丁不等式）$\\mathbb{P} \\lbrace \\mathbb{E}[X] \\geq \\bar{x}_t + u \\rbrace \\leq e^{-2nu^2}$，我们可以很大概率得出：期望奖励 $Q(a_t)$满足 $\\hat{Q}(a_t) - \\Delta \\mu \\le Q(a_t) \\le \\hat{Q}(a_t) + \\Delta \\mu$，因此上置信界 $\\text{UCB}(a_t)=\\hat{Q}(a_t) + \\Delta \\mu=\\hat{Q}(a_t) + \\frac{c}{\\sqrt{n}}$ 这个UCB算法可以被概括为：在乐观中选择最好，在交互中降低乐观。 上面的数学定义形式下的标准误差被叫做乐观加分，在一次次选择中，乐观加分会因为 $n$ 的增大而不断减小，而算法每次会选择拉动上置信界 $\\text{UCB}(a_t)$ 最大的，也就是乐观中选择最好。 这也给了我们一个深刻的人生启示：在乐观中选择最好的那个去尝试，在尝试的交互中逐步降低你的乐观。不要害怕犯错，不要担心时间来不及，这个算法是数学中接近理论最优的做法，只要肯尝试、体验、感受、比较和提升，你一定能找到属于自己最好的选择，就怕你畏首畏尾，在固定型思维中焦虑恐惧畏缩不前，选择了一个随大流的稳妥选择了事。 ","date":"2025-06-18","objectID":"/%E4%BB%8E%E6%95%B0%E5%AD%A6%E8%A7%92%E5%BA%A6%E6%9D%A5%E7%9C%8B%E5%81%9A%E9%80%89%E6%8B%A9/:0:0","tags":["数学","RL"],"title":"从数学角度来看做选择","uri":"/%E4%BB%8E%E6%95%B0%E5%AD%A6%E8%A7%92%E5%BA%A6%E6%9D%A5%E7%9C%8B%E5%81%9A%E9%80%89%E6%8B%A9/"},{"categories":["数学"],"content":"注： 1.通用符号约定 花体字母的使用习惯：在数学中，花体字母（如 $\\mathcal{A},\\mathcal{B},\\mathcal{C}$）通常用于表示 “高级” 或 “结构化” 的对象，例如集合的集合、代数结构、拓扑空间等，以区别于普通的集合或元素（如 A,B,C 或 a,b,c）。 2.强化学习中的符号 $\\mathcal{R}(r \\mid a_t)$ 强化学习直接借用了概率论的表示方法，但有以下特点： 符号习惯： 强化学习文献中常用 $\\mathcal{R}$ 或 $R$ 表示奖励分布，以强调其与“奖励（Reward）”的关联。 例如：$\\mathcal{R}(r \\mid a_t)$ 是MDP中状态-动作对的奖励分布。 本质仍是条件概率分布，只是变量名 $(r,a_t)$ 具有领域含义。 与传统概率论的区别： 变量含义：$a_t$ 是智能体的动作（Action），属于强化学习的专用术语。 建模对象：奖励分布 $\\mathcal{R}$ 通常是问题设定的核心部分（如MAB中拉杆的奖励分布）。 数学一致性： 如果替换符号 $\\mathcal{R}(r \\mid a_t)$ 为 $P(r \\mid a_t)$，其数学定义完全不变。 ","date":"2025-06-18","objectID":"/%E4%BB%8E%E6%95%B0%E5%AD%A6%E8%A7%92%E5%BA%A6%E6%9D%A5%E7%9C%8B%E5%81%9A%E9%80%89%E6%8B%A9/:0:1","tags":["数学","RL"],"title":"从数学角度来看做选择","uri":"/%E4%BB%8E%E6%95%B0%E5%AD%A6%E8%A7%92%E5%BA%A6%E6%9D%A5%E7%9C%8B%E5%81%9A%E9%80%89%E6%8B%A9/"},{"categories":["课程"],"content":" 研一选修课程 形式化方法 ","date":"2025-06-12","objectID":"/%E5%BD%A2%E5%BC%8F%E5%8C%96%E6%96%B9%E6%B3%95/:0:0","tags":["cs课程"],"title":"形式化方法","uri":"/%E5%BD%A2%E5%BC%8F%E5%8C%96%E6%96%B9%E6%B3%95/"},{"categories":["课程"],"content":"课程大纲 image-20250628023843877 image-20250628024411057 ","date":"2025-06-12","objectID":"/%E5%BD%A2%E5%BC%8F%E5%8C%96%E6%96%B9%E6%B3%95/:1:0","tags":["cs课程"],"title":"形式化方法","uri":"/%E5%BD%A2%E5%BC%8F%E5%8C%96%E6%96%B9%E6%B3%95/"},{"categories":["课程"],"content":"数学基础 ","date":"2025-06-12","objectID":"/%E5%BD%A2%E5%BC%8F%E5%8C%96%E6%96%B9%E6%B3%95/:2:0","tags":["cs课程"],"title":"形式化方法","uri":"/%E5%BD%A2%E5%BC%8F%E5%8C%96%E6%96%B9%E6%B3%95/"},{"categories":["课程"],"content":"计算复杂性理论 研究的是哪些问题是可以被计算机计算的： P问题：存在多项式时间复杂度解法的问题（比如大家常刷的LeetCode算法题） NP问题：不确定能否找到多项式时间复杂度解法，但是有多项式时间复杂度的方法来验证答案是否正确的问题(就比如Q:打印出集合$A$的所有子集，现有方法似乎只有穷举法，$2^n$ 的时间复杂度，但是验证某个集合是否是集合$A$的子集可以很快判定出来，因此人们不禁乐观的想(^_^)是否只是人们没有发现多项式的解法，而非数学意义上完全不存在这样的多项式时间算法来求解这样的NP问题) NPC问题：NPC完全问题。NPC问题 $\\subseteq$ NP问题,而且对于任何 $\\forall x \\in $ NP问题,都可以在多项式时间内转换或归约成某一个NPC问题。 NPC问题是最近几十年对P?=NP问题比较大的理论突破。人们乐观的认为，只需要解决一个NPC问题，也就可以解决所有的NP问题。但是可惜的是，直到现在，人们还是没有解决出一个NPC问题。所以慢慢的更多的人感觉用永远也无法找到了。 以及证明任意一个NPC问题都可以解决所有的NP问题，但是NPC问题也有难度的区别，因此将目光聚焦于那些更简单的NPC问题会更简单。 ","date":"2025-06-12","objectID":"/%E5%BD%A2%E5%BC%8F%E5%8C%96%E6%96%B9%E6%B3%95/:2:1","tags":["cs课程"],"title":"形式化方法","uri":"/%E5%BD%A2%E5%BC%8F%E5%8C%96%E6%96%B9%E6%B3%95/"},{"categories":["课程"],"content":"上下文无关文法 是一套通过四元组来描述形式系统的符号工具。 四元组： G = {N、 T、 S、 P} N是非终结符的有限集合。 T是终结符的有限集合，且 $\\text{N} \\cap \\text{T} = \\varnothing$。 S是开始符号，且 $\\text{S} \\in \\text{N}$。 P是产生式的有限集合，每个产生式具有的形式如：$\\text{N} \\to \\alpha, \\alpha \\in (\\text{N} \\cup \\text{T})^*$ 下面我们来分析什么是上下文无关： 假设我们有产生式 $\\text{S} \\to \\text{a} \\mid \\text{b}$,那么如果我们遇到式子 $\\text{aS}$,那么可以替换为 $\\text{aS} \\to \\text{aa} \\mid \\text{ab}$,同理当我们遇到式子 $Sb$ 时，可以替换为 $\\text{Sb}\\to\\text{ab}\\mid\\text{bb}$。所以在上下文无关文法中，我们遇到 $\\text{S}$ 时，我们无需去关心 $\\text{S}$ 的左边和右边是什么符号（这里的a、b其实就是所谓的上下文），直接根据产生式去替换就行。 但是如果我们还有产生式 $\\text{aS}\\to aa$,那么下次当我们遇到式子 $\\text{aS}$ 时，不能直接去替换 $\\text{S}$，还得去研究 $\\text{S}$ 的上下文。这时候就是上下文有关了。 例1.1 给定文法G ​ $E ::= E + E \\mid E - E \\mid E * E \\mid E / E \\mid (E) \\mid n$ 其中，终结符 $T$ 的集合为 $\\lbrace +,-,*,/,n,()\\rbrace$, 并且符号 $n$ 表示整数； 非终结符 $N$ 的集合为 $\\lbrace E \\rbrace$； 解： 上面其实就是一个标准的上下文无关文法，他包含了我们之前说的四元组：G = {N、 T、 S、 P}，通常我们使用大写字母表示非终结符，小写字母表示终结符。这里的 $E$ 其实充当开始符号S的作用，不必拘泥于字母表示。 这个文法G可表示的集合为整数域上加减乘除的表达式 Q1： 判断表达式 $1+2*3$ 是否是文法G的元素？ $$ \\begin{aligned} E \u0026\\to E + E \\\\ \u0026\\to E + E * E \\\\ \u0026\\to n + n * n \\\\ \u0026\\to 1 + 2 * 3 \\\\ \\end{aligned} $$ 当然由于我们的文法G的规则不够完善，还未支持四则运算的优先级，所以上面的推导过程不是唯一的。 我们还可以用推导树来表示刚刚的推导过程： Q2： 怎么修改文法G的规则使得可以支持四则运算的优先级？ $$ \\begin{aligned} E \u0026::= E + T \\mid E - T \\mid T \\\\ T \u0026::= T * F \\mid T / F \\mid F \\\\ F \u0026::= (E) \\mid n \\\\ \\end{aligned} $$ 在《形式化方法》这门课中，上下文无关文法只是我们用来表达命题逻辑、谓词逻辑等等的一个最基本的表达形式，所以了解到这里就已经够了，如果想要更深入的进行学习，可以学习另一门课程《编译原理》。 ","date":"2025-06-12","objectID":"/%E5%BD%A2%E5%BC%8F%E5%8C%96%E6%96%B9%E6%B3%95/:2:2","tags":["cs课程"],"title":"形式化方法","uri":"/%E5%BD%A2%E5%BC%8F%E5%8C%96%E6%96%B9%E6%B3%95/"},{"categories":["课程"],"content":"结构化归纳法 归纳法(Induction)是一个非常强大的数学工具。 数学归纳法(Mathematical induction)：我们在高中阶段就已经学过了，他其实是建立在natural number上的一套普适原则。在高中阶段我们并没有研究数学归纳法的证明，其实这个涉及到了什么是natural number?我们需要使用纯数中的皮亚诺公理系统（Piano number)来证明这个定理。 结构化归纳法(Structural induction)：Do induction on any recursive defined structures。 良基归纳(Well-founded induction)：是基于 $2^{nd}$ 数学归纳法而推广到任意线性序的归纳法。 下面我们给出对于结构化归纳法的定义： 对于产生式： $$ A ::= \\alpha_1 \\mid \\dots \\mid \\alpha_m \\mid \\beta_1 A \\gamma_1 \\mid \\dots \\mid \\beta_n A \\gamma_n $$ 其中非终结符A在 $\\alpha_i、1 \\leq i \\leq m$ 中不出现。要证明某个命题P(A)成立，只要证明如下两个步骤： 基础步：证明命题 P 对 $\\alpha_i、1 \\leq i \\leq m$ 都成立； 归纳步：分别假设命题 P 对 $\\beta_i A \\gamma_i、1 \\leq i \\leq n$ 中的A成立，分别证明 $P(\\beta_i A \\gamma_i)$ 成立。 综合上述两个步骤，可证明命题P(A)成立。 例1.2 证明例1.1给定文法表示的集合A，左括号和右括号的数量相等 证明：设用符号(L(A))和(R(A))分别来表示集合A的左括号和右括号的数量。 归纳基础：首先对集合A的元素进行证明，可得 $L(n) = R(n) = 0$，成立。 归纳推理：设 $L(E) = R(E)$ 成立，则： $$ L(E{+}E) = L(E) + L(+) + L(E) = R(E) + R(+) + R(E) = R(E{+}E), $$ 成立，同理可证 $E - E、E * E、E / E$ 成立；对 $(E)$ 进行验证，可得： $$ L((E)) = 1 + L(E) = R(E) + 1 = R((E)), $$ 成立。所以，我们可以得出对于例（1.2）给定文法所表示的集合，具有左括号等于右括号的性质。证毕。 ","date":"2025-06-12","objectID":"/%E5%BD%A2%E5%BC%8F%E5%8C%96%E6%96%B9%E6%B3%95/:2:3","tags":["cs课程"],"title":"形式化方法","uri":"/%E5%BD%A2%E5%BC%8F%E5%8C%96%E6%96%B9%E6%B3%95/"},{"categories":["课程"],"content":"命题逻辑 ","date":"2025-06-12","objectID":"/%E5%BD%A2%E5%BC%8F%E5%8C%96%E6%96%B9%E6%B3%95/:3:0","tags":["cs课程"],"title":"形式化方法","uri":"/%E5%BD%A2%E5%BC%8F%E5%8C%96%E6%96%B9%E6%B3%95/"},{"categories":["课程"],"content":"语法规则 首先我们用之前学到的上下文无关文法，给出命题逻辑的语法规则： $$ P ::= \\top \\mid \\bot \\mid x \\mid P \\land P \\mid P \\lor P \\mid P \\to P \\mid \\lnot P $$ 符号 $\\top , \\bot , x$ 分别表示逻辑常量“真”，逻辑常量“假”，和原子命题变量。这三种语法形式都是基本的，因此我们可称它们为原子命题（其实就是上面的*终结符*）。 后面4个是通过连接词连接子命题，而构成复合命题。 ","date":"2025-06-12","objectID":"/%E5%BD%A2%E5%BC%8F%E5%8C%96%E6%96%B9%E6%B3%95/:3:1","tags":["cs课程"],"title":"形式化方法","uri":"/%E5%BD%A2%E5%BC%8F%E5%8C%96%E6%96%B9%E6%B3%95/"},{"categories":["课程"],"content":"证明系统 我们使用自然演绎系统这种形式化的逻辑证明方式系统来作为命题逻辑的证明系统。 首先我们需要先确定一些假定的推理规则，然后利用这些规则，在假定的一个真前提下，得出真结论。这里假定的真前提就是所谓的环境。（我们不关心这些前提实际的真假，只是在推理过程中假定他们为真） 定义 $2.1$（环境） 环境 $\\Gamma$ 是由$n，n\\ge 0$，个命题构成的命题列表 $$ \\Gamma = P_1, \\ldots, P_n $$ 特别的，若 $n=0$,我们称 $\\Gamma$ 为空环境。 定义 $2.2$(断言) 断言是由环境 $\\Gamma$，和命题 $P$ 构成的元组 $$ \\Gamma \\vdash P $$ $\\vdash $ 是推导符号，也即环境 $\\Gamma$ 为真可以断言得到命题 $P$ 为真。 定义 $2.3$(证明规则) 证明规则是形如 $$ \\frac{\\Gamma_1 \\vdash P_1 \\quad \\dots \\quad \\Gamma_n \\vdash P_n}{\\Gamma \\vdash P} \\ \\ \\ \\ (\\text{Rule-Name}) $$ 的一条公式，其中 $n \\ge 0$。 证明规则由三部分组成： 规则的前提：横线上方的 $n$ 条断言 规则的结论：横线下方唯一的断言 Rule-Name：规则的名字，唯一的表示了该规则 ","date":"2025-06-12","objectID":"/%E5%BD%A2%E5%BC%8F%E5%8C%96%E6%96%B9%E6%B3%95/:3:2","tags":["cs课程"],"title":"形式化方法","uri":"/%E5%BD%A2%E5%BC%8F%E5%8C%96%E6%96%B9%E6%B3%95/"},{"categories":["课程"],"content":"推导规则 首先我们来看看最简单的变量规则，它是一条公理，也就是这个规则结论的推出是不需要前提的： $$ \\frac{}{\\Gamma, P \\vdash P} \\ (\\mathrm{Var}) $$ 显然如果命题$P$在环境中出现，根据定义就可以推出$P$成立。 下面是真引入规则： $$ \\frac{}{\\Gamma \\vdash \\top} \\ (\\top I) $$ 它也是一条公理，表示在任意环境 $\\Gamma$ 中，命题 $\\top$ 都无条件成立。 接下来我们来看看假消除规则： $$ \\frac{\\Gamma \\vdash \\bot}{\\Gamma \\vdash P} \\ (\\bot E) $$ 可以理解为环境 $\\Gamma$ 能推出 “假”，即 $\\Gamma$ 中包含矛盾（比如同时有 $A$ 和 $\\neg A$），那么环境 $\\Gamma$ 能推出**任意命题** $P$（无论 $P$ 本身是否合理）。 逻辑意义：维护 “无矛盾则有效” 的体系，它揭示了 “矛盾会摧毁推理有效性” 这一本质，迫使使用者必须保证前提的一致性，否则推理将失去意义。 其他的规则我们也就不一一讲解了，下面给出完整的最基础的$14$条命题逻辑的推理规则： $$ \\frac{}{\\Gamma, P \\vdash P} \\ (\\mathrm{Var}) \\quad\\quad\\quad\\quad\\quad\\quad \\frac{}{\\Gamma \\vdash \\top} \\ (\\top I) $$ $$ \\frac{\\Gamma \\vdash \\bot}{\\Gamma \\vdash P} \\ (\\bot E) \\quad\\quad\\quad\\quad\\quad\\quad \\frac{\\Gamma \\vdash P \\quad\\quad \\Gamma \\vdash Q}{\\Gamma \\vdash P \\land Q} \\ (\\land I) $$ $$ \\frac{\\Gamma \\vdash P \\land Q}{\\Gamma \\vdash P} \\ (\\land E1) \\quad\\quad\\quad\\quad\\quad\\quad \\frac{\\Gamma \\vdash P \\land Q}{\\Gamma \\vdash Q} \\ (\\land E2) $$ $$ \\frac{\\Gamma \\vdash P}{\\Gamma \\vdash P \\lor Q} (\\lor I1) \\quad\\quad\\quad\\quad\\quad\\quad \\frac{\\Gamma \\vdash Q}{\\Gamma \\vdash P \\lor Q} (\\lor I2) $$ $$ \\frac{\\Gamma, P \\vdash Q}{\\Gamma \\vdash P \\to Q} (\\to I) \\quad\\quad\\quad\\quad \\frac{\\Gamma \\vdash P \\to Q \\quad\\quad \\Gamma \\vdash P}{\\Gamma \\vdash Q} (\\to E) $$ $$ \\frac{\\Gamma, P \\vdash \\perp}{\\Gamma \\vdash \\neg P} (\\neg I) \\quad\\quad\\quad\\quad\\quad\\quad\\quad \\frac{\\Gamma \\vdash P \\quad\\quad \\Gamma \\vdash \\neg P}{\\Gamma \\vdash \\perp} (\\neg E) $$ $$ \\frac{\\Gamma \\vdash P \\lor Q \\quad\\quad \\Gamma, P \\vdash R \\quad\\quad \\Gamma, Q \\vdash R}{\\Gamma \\vdash R} (\\lor E) \\quad\\quad\\quad \\frac{\\Gamma \\vdash \\neg \\neg P}{\\Gamma \\vdash P} (\\neg\\neg E) $$ 例2.1 根据上面的推导规则，画出命题 $\\vdash P \\to \\neg \\neg P$ 的证明树 从下往上根据上面的14条推理规则去找匹配的进行推导就行，最后推导到公理即可： $$ \\begin{array}{c} \\dfrac{ \\dfrac{ \\dfrac{ \\dfrac{}{P, \\neg P \\vdash P}\\text{(Var)} \\quad \\dfrac{}{P, \\neg P \\vdash \\neg P}\\text{(Var)} }{P, \\neg P \\vdash \\bot}(\\neg E) }{P \\vdash \\neg \\neg P}(\\neg I) }{\\vdash P \\to \\neg \\neg P}(\\to I) \\end{array} $$ ","date":"2025-06-12","objectID":"/%E5%BD%A2%E5%BC%8F%E5%8C%96%E6%96%B9%E6%B3%95/:3:3","tags":["cs课程"],"title":"形式化方法","uri":"/%E5%BD%A2%E5%BC%8F%E5%8C%96%E6%96%B9%E6%B3%95/"},{"categories":["课程"],"content":"SAT问题 SAT（布尔可满足性理论）：given a proposition P, is it satisfiable? 第一个NPC问题(Cook-Levin, 1971) 显然我们可以通过画真值表的方式来得到答案，但是时间复杂度是$O(2^n)$。 那么有没有更快一点的方式让计算机来解决SAT问题呢？ 有的有的兄弟，那就是就是DPLL算法： CNF（合取范式） 解析与传播 解析：决策 传播：布尔约束传播（BCP） 所有命题公式都可以转换成 CNF 的等价公式。在布尔逻辑中，如果一个公式公式(数理逻辑)是子句的，那么它是合取范式（CNF）的。作为规范形式，它在自动定理证明中有用。 例如，下列所有公式都是CNF: $$ \\begin{aligned} \u0026 A \\land B \\\\ \u0026 \\neg A \\land (B \\lor C) \\\\ \u0026 (A \\lor B) \\land (\\neg B \\lor C \\lor \\neg D) \\land (D \\lor \\neg E) \\\\ \u0026 (\\neg B \\lor C) \\\\ \\end{aligned} $$ 而下列不是: $$ \\begin{aligned} \u0026 \\neg (B \\lor C) \\\\ \u0026 (A \\land B) \\lor C \\\\ \u0026 A \\land (B \\lor (D \\land E)) \\\\ \\end{aligned} $$ 上述三个公式分别等价于合取范式的下列三个公式: $$ \\begin{aligned} \u0026 \\neg B \\land \\neg C \\\\ \u0026 (A \\lor C) \\land (B \\lor C) \\\\ \u0026 A \\land (B \\lor D) \\land (B \\lor E) \\\\ \\end{aligned} $$ 等价转换公式： $$ \\begin{aligned} \\mathcal{E}(\\top) \u0026= \\top \\\\ \\mathcal{E}(\\bot) \u0026= \\bot \\\\ \\mathcal{E}(p) \u0026= p \\\\ \\mathcal{E}(P \\land Q) \u0026= \\mathcal{E}(P) \\land \\mathcal{E}(Q) \\\\ \\mathcal{E}(P \\lor Q) \u0026= \\mathcal{E}(P) \\lor \\mathcal{E}(Q) \\\\ \\mathcal{E}(P \\to Q) \u0026= \\mathcal{E}(\\neg P) \\lor \\mathcal{E}(Q) \\\\ \\mathcal{E}(\\neg P) \u0026= \\neg \\mathcal{E}(P) \\\\ \\end{aligned} $$ $$ \\begin{aligned} \\mathcal{N}(\\top) \u0026= \\top \\\\ \\mathcal{N}(\\bot) \u0026= \\bot \\\\ \\mathcal{N}(p) \u0026= p \\\\ \\mathcal{N}(\\neg P) \u0026= \\neg \\mathcal{N}(P) \\\\ \\mathcal{N}(\\neg \\neg P) \u0026= \\mathcal{N}(P) \\\\ \\mathcal{N}(P \\land Q) \u0026= \\mathcal{N}(P) \\land \\mathcal{N}(Q) \\\\ \\mathcal{N}(P \\lor Q) \u0026= \\mathcal{N}(P) \\lor \\mathcal{N}(Q) \\\\ \\mathcal{N}(\\neg (P \\land Q)) \u0026= \\mathcal{N}(\\neg P) \\lor \\mathcal{N}(\\neg Q) \\\\ \\mathcal{N}(\\neg (P \\lor Q)) \u0026= \\mathcal{N}(\\neg P) \\land \\mathcal{N}(\\neg Q) \\\\ \\end{aligned} $$ $$ \\begin{aligned} \\mathcal{C}(\\top) \u0026= \\top \\\\ \\mathcal{C}(\\bot) \u0026= \\bot \\\\ \\mathcal{C}(p) \u0026= p \\\\ \\mathcal{C}(\\neg p) \u0026= \\neg \\mathcal{C}(p) \\\\ \\mathcal{C}(P \\land Q) \u0026= \\mathcal{C}(P) \\land \\mathcal{C}(Q) \\\\ \\mathcal{C}(P \\lor Q) \u0026= \\mathcal{D}\\bigl(\\mathcal{C}(P), \\mathcal{C}(Q)\\bigr) \\\\ \\mathcal{D}(P_1 \\land P_2, Q) \u0026= \\mathcal{D}(P_1, Q) \\land \\mathcal{D}(P_2, Q) \\\\ \\mathcal{D}(P, Q_1 \\land Q_2) \u0026= \\mathcal{D}(P, Q_1) \\land \\mathcal{D}(P, Q_2) \\\\ \\mathcal{D}(P, Q) \u0026= P \\lor Q \\\\ \\end{aligned} $$ 例2.2 转换命题 $$ (p_1 \\land \\neg \\neg p_2) \\lor (\\neg q_1 \\to q_2) $$ 为CNF命题。 消去蕴含。 $$ \\begin{aligned} \\mathcal{E}\\bigl(((p_1 \\land \\neg \\neg p_2) \\lor (\\neg q_1 \\to q_2))\\bigr) \u0026= \\mathcal{E}(p_1 \\land \\neg \\neg p_2) \\lor \\mathcal{E}(\\neg q_1 \\to q_2) \\\\ \u0026= \\bigl(\\mathcal{E}(p_1) \\land \\mathcal{E}(\\neg \\neg p_2)\\bigr) \\lor \\bigl(\\mathcal{E}(\\neg q_1) \\lor \\mathcal{E}(q_2)\\bigr) \\\\ \u0026= (p_1 \\land \\neg \\neg p_2) \\lor (\\neg \\neg q_1 \\lor q_2) \\\\ \\end{aligned} $$ 转换为NNF。 $$ \\begin{aligned} \\mathcal{N}\\bigl(((p_1 \\land \\neg \\neg p_2) \\lor (\\neg \\neg q_1 \\lor q_2))\\bigr) \u0026= \\mathcal{N}(p_1 \\land \\neg \\neg p_2) \\lor \\mathcal{N}(\\neg \\neg q_1 \\lor q_2) \\\\ \u0026= \\bigl(\\mathcal{N}(p_1) \\land \\mathcal{N}(\\neg \\neg p_2)\\bigr) \\lor \\bigl(\\mathcal{N}(\\neg \\neg q_1) \\lor \\mathcal{N}(q_2)\\bigr) \\\\ \u0026= (p_1 \\land p_2) \\lor (q_1 \\lor q_2) \\\\ \\end{aligned} $$ 等价转换为CNF $$ \\begin{aligned} \\mathcal{C}\\bigl(((p_1 \\land p_2) \\lor (q_1 \\lor q_2))\\bigr) \u0026= \\mathcal{D}\\bigl(\\mathcal{C}(p_1 \\land p_2), \\mathcal{C}(q_1 \\lor q_2)\\bigr) \\\\ \u0026= \\mathcal{D}(p_1 \\land p_2, \\mathcal{D}(q_1, q_2)) \\\\ \u0026= \\mathcal{D}\\bigl(p_1, \\mathcal{D}(q_1, q_2)\\bigr) \\land \\mathcal{D}\\bigl(p_2, \\mathcal{D}(q_1, q_2)\\bigr) \\\\ \u0026= \\mathcal{D}\\bigl(p_1, q_1 \\lor q_2\\bigr) \\land \\mathcal{D}\\bigl(q_2, q_1 \\lor q_2\\bigr) \\\\ \u0026= (p_1 \\lor q_1 \\lor q_2) \\land (p_2 \\lor q_1 \\lor q_2) \\\\ \\end{aligned} $$ ","date":"2025-06-12","objectID":"/%E5%BD%A2%E5%BC%8F%E5%8C%96%E6%96%B9%E6%B3%95/:3:4","tags":["cs课程"],"title":"形式化方法","uri":"/%E5%BD%A2%E5%BC%8F%E5%8C%96%E6%96%B9%E6%B3%95/"},{"categories":["课程"],"content":"构造逻辑 与经典命题逻辑的区别：是否接受排中律 $\\vdash P \\lor \\neg P$ ? 也就会导致我们无法使用反证法来证明命题成立。也就是我们再也无法通过证明 $\\neg P$ 成立来证明 $P$ 不成立。 ","date":"2025-06-12","objectID":"/%E5%BD%A2%E5%BC%8F%E5%8C%96%E6%96%B9%E6%B3%95/:4:0","tags":["cs课程"],"title":"形式化方法","uri":"/%E5%BD%A2%E5%BC%8F%E5%8C%96%E6%96%B9%E6%B3%95/"},{"categories":["课程"],"content":"语法规则 $$ P ::= p \\mid \\top \\mid \\bot \\mid x \\mid P \\land P \\mid P \\lor P \\mid P \\to P $$ $\\neg P$ 被替换为 $p \\to \\bot$，而不再出现。 ","date":"2025-06-12","objectID":"/%E5%BD%A2%E5%BC%8F%E5%8C%96%E6%96%B9%E6%B3%95/:4:1","tags":["cs课程"],"title":"形式化方法","uri":"/%E5%BD%A2%E5%BC%8F%E5%8C%96%E6%96%B9%E6%B3%95/"},{"categories":["课程"],"content":"证明系统 同命题逻辑。 ","date":"2025-06-12","objectID":"/%E5%BD%A2%E5%BC%8F%E5%8C%96%E6%96%B9%E6%B3%95/:4:2","tags":["cs课程"],"title":"形式化方法","uri":"/%E5%BD%A2%E5%BC%8F%E5%8C%96%E6%96%B9%E6%B3%95/"},{"categories":["课程"],"content":"推导系统 剔除了双重否定律以及$\\neg$的引入和消去规则，其他都同命题逻辑。 ","date":"2025-06-12","objectID":"/%E5%BD%A2%E5%BC%8F%E5%8C%96%E6%96%B9%E6%B3%95/:4:3","tags":["cs课程"],"title":"形式化方法","uri":"/%E5%BD%A2%E5%BC%8F%E5%8C%96%E6%96%B9%E6%B3%95/"},{"categories":["课程"],"content":"谓词逻辑 The Syntax: $$ \\begin{aligned} E \u0026::= x \\mid c \\mid f(E,\\dots,E) \\\\ R \u0026::= r(E,\\dots,E) \\\\ P \u0026::= R \\\\ \u0026\\phantom{::} \\mid \\top \\\\ % 用 \\phantom 占位 ::= 的空格 \u0026\\phantom{::} \\mid \\bot \\\\ \u0026\\phantom{::} \\mid P \\lor P \\\\ \u0026\\phantom{::} \\mid P \\land P \\\\ \u0026\\phantom{::} \\mid P \\rightarrow P \\\\ \u0026\\phantom{::} \\mid \\neg P \\\\ \u0026\\phantom{::} \\mid \\forall x, P \\\\ \u0026\\phantom{::} \\mid \\exists x, P \\\\ \\end{aligned} $$ $E$:表达式 $x$：变量 $c$：常量 $R$:关系 $r()$：关系算符 $P$：命题 Intuition: 我们把上面的这套公理化系统引入到数论中直观感受一下各项代表着什么： $$ \\begin{aligned} E \u0026::= x \\mid \\mathbb{Z} \\mid E+E \\mid E-E \\mid \\dots \\\\ R \u0026::= E\u003eE \\mid E=E \\mid E \\le E \\\\ P \u0026::= R \\\\ \u0026\\phantom{::} \\mid \\top \\\\ % 用 \\phantom 占位 ::= 的空格 \u0026\\phantom{::} \\mid \\bot \\\\ \u0026\\phantom{::} \\mid P \\lor P \\\\ \u0026\\phantom{::} \\mid P \\land P \\\\ \u0026\\phantom{::} \\mid P \\rightarrow P \\\\ \u0026\\phantom{::} \\mid \\neg P \\\\ \u0026\\phantom{::} \\mid \\forall x, P \\\\ \u0026\\phantom{::} \\mid \\exists x, P \\\\ \\end{aligned} $$ 很明显：上面这套谓词逻辑是数论的一种抽象，这种Syntax是由逻辑学派创建出来的。逻辑学已经有2000多年的历史了，最终确定下来这种形式，其实是对其中的抽象性和具体性的一种平衡。如果太讲究抽象性，那么就无法得出什么meaningful的结论，但如果太讲究具体性，就有可能会偏向于某一理论。 谓词逻辑其实就是从数论、集合论、矩阵理论等等中抽象出了一个共性语法规则，他的好处就是如果能正面共性成立，就无需去将每一个底层理论继续证明，就比如哥德尔不完备性定理就是在数理逻辑框架下证明，所以对于任意框架都成立。 ","date":"2025-06-12","objectID":"/%E5%BD%A2%E5%BC%8F%E5%8C%96%E6%96%B9%E6%B3%95/:5:0","tags":["cs课程"],"title":"形式化方法","uri":"/%E5%BD%A2%E5%BC%8F%E5%8C%96%E6%96%B9%E6%B3%95/"},{"categories":["课程"],"content":"推导规则 $$ \\frac{\\Gamma, x \\vdash P}{\\Gamma \\vdash \\forall x. P} \\ (\\forall I) \\quad \\quad \\quad \\quad \\quad\\quad \\quad\\quad \\frac{\\Gamma \\vdash \\forall x. P}{\\Gamma \\vdash P[x \\mapsto E]} \\ (\\forall E) $$ $$ \\frac{\\Gamma \\vdash P[x \\mapsto E]}{\\Gamma \\vdash \\exists x. P} \\ (\\exists I) \\quad \\quad \\quad \\frac{\\Gamma \\vdash \\exists x. P \\quad\\quad \\Gamma, x, P \\vdash Q}{\\Gamma \\vdash Q} \\ (\\exists E) $$ Bound free variables Bound variables （绑定变量）：默认只绑定最近的一个命题 Free variables （自由变量） $\\forall x, P(x,y)$中，$x$ 就是绑定变量，$y$ 就是自由变量。 其实就可以翻译成类似下面的code： int y = 10; int f(int x) { return p(x, y); } $\\alpha$ - 重命名 SAT SAT（可满足性理论）：given a proposition P, is it satisfiable? SAT for 命题逻辑: NPC问题。但是从实践上来说，使用DPLL等算法可以在很合理的时间内求解相当大规模的实际问题 SAT for 谓词逻辑: 不可判定/理论上证明不可能有算法可以在合理时间求解/不可解 这就引导我们去思考：有没有可能通过我们使用一些特殊的子集，对这个子集进行求解仍然是可解的呢？其实这就是下面我们要讲的theory theory SMT SMT(可解释性模理论)：Satisfiability modulo theory SAT + Theory Solvers = SMT SMT的意义在于：CS中的终极大杀器。针对非常非常复杂的问题（如NPC问题），有没有一套通用范式来解决这类难题吗？那就是SMT。如果一个问题很难，我不知道该怎么解，那就上SMT，大概率就有用；如果SMT都没用，那估计你用其他方法也解不了。 ","date":"2025-06-12","objectID":"/%E5%BD%A2%E5%BC%8F%E5%8C%96%E6%96%B9%E6%B3%95/:5:1","tags":["cs课程"],"title":"形式化方法","uri":"/%E5%BD%A2%E5%BC%8F%E5%8C%96%E6%96%B9%E6%B3%95/"},{"categories":["编程"],"content":"问题定位： PS C:\\Users\\god\u003e python -u \"c:\\Users\\god\\Desktop\\gold.py\" Traceback (most recent call last): File \"c:\\Users\\god\\Desktop\\gold.py\", line 1, in \u003cmodule\u003e import requests ModuleNotFoundError: No module named 'requests' 明明已经在conda中安装了 requests，却依旧报错找不到，下面给出解决方案： 使用 “Python: 清除工作区解释器设置” 命令以清除当前设置的解释器上下文。 步骤：1. 按 Ctrl+Shift+P 打开命令面板；2. 输入“Python: 清除工作区解释器设置”；3. 回车执行命令。 使用 “开发人员: 重新加载窗口” 命令重启 VS Code，从而刷新解释器上下文。 步骤：1. 按 Ctrl+Shift+P 打开命令面板；2. 输入“开发人员: 重新加载窗口”；3. 回车执行命令。 使用 “Python: 选择解释器” 命令重新选择正确的 Python 解释器。 步骤：1. 按 Ctrl+Shift+P 打开命令面板；2. 输入“Python: 选择解释器”；3. 回车执行命令。 ","date":"2025-04-25","objectID":"/vscode%E7%BC%BA%E5%B0%91module%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/:0:0","tags":["编程"],"title":"vscode缺少module解决方法","uri":"/vscode%E7%BC%BA%E5%B0%91module%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/"},{"categories":["健身"],"content":" 腿+肩 背+二头 胸+三头+腹 史密斯推肩 单侧15~17.5kg 高位下拉 递减组 平板卧推 单侧20kg触胸一次 蝴蝶机方向飞鸟 32kg 划船 上斜卧推 绳索侧拉 只能上两格重量 绳索下拉 递减组 绳索面拉 40kg ","date":"2025-01-07","objectID":"/%E8%87%AA%E7%94%A8%E5%81%A5%E8%BA%AB%E8%AE%A1%E5%88%92/:0:0","tags":["健身"],"title":"自用健身计划","uri":"/%E8%87%AA%E7%94%A8%E5%81%A5%E8%BA%AB%E8%AE%A1%E5%88%92/"},{"categories":["编程"],"content":"期末复习针对pdf提问prompt 由于12月22号就要开始考信息安全，本人12月21号才开始学习，直接看别人整理好的笔记复习感觉知识点不是很进脑子，于是想到了之前似乎也看到过一个类似的B站视频有人想做一个自我学习提升的gpt应用： image-20241221174515561 image-20241221175536519 有时间我也要做个自己的gpt（乐） 也就是利用费曼学习法：基于提问式，然后讲解自己理解并回答，从而达到检测自己学习效果的作用， 本来很难找到这种提问，但是现在 ai 的出现给了新的希望： image-20241221174908787 提示词： 你是一位费曼学习法的实践者和辅导专家，专注于通过提问来促进深度学习和理解。你的任务是针对我提供的学习资料，设计一系列问题，引导我进行自我检验，并通过你的反馈帮助我纠正错误，加深理解。 Action（行动）： 1. 接收并仔细阅读我提供的学习资料。 2. 根据资料内容，设计问题，确保问题能够有效检验我对关键概念和信息的掌握。 3. 提出第一个问题，并要求我给出回答，问题下面不应该给出答案，而是仅仅只有问题。 4. 等待我的回答，我还未回复就不要进行下面的任务。 5. 评估我的回答，如果发现错误或不准确，在纠正错误时，使用清晰、简洁的语言，给出提示，鼓励我通过自我修正来提高学习效果。 6. 继续提出下一个问题，直到所有问题都被提出并得到回答。 Purpose（目的）： 通过提问式学习，帮助我更好地理解学习资料，提升我的学习效果和批判性思维能力。 Expectation（期望）： 1. 每次只提出一个问题，确保问题与学习资料紧密相关。 2. 在我回答后，提供有建设性的反馈，指出错误并引导我理解正确答案。 3. 在纠正错误时，使用清晰、简洁的语言，避免直接给出资料中的正确答案。 4. 保持提问的连贯性和逻辑性，确保每个问题都能促进对资料内容的深入理解。 5. 鼓励我通过自我修正来提高学习效果，而不是依赖直接的答案。 ","date":"2024-12-21","objectID":"/%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E9%92%88%E5%AF%B9pdf%E6%8F%90%E9%97%AEprompt/:1:0","tags":["编程"],"title":"期末复习针对pdf提问prompt","uri":"/%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E9%92%88%E5%AF%B9pdf%E6%8F%90%E9%97%AEprompt/"},{"categories":["编程"],"content":"ChatGPT 费曼学习法教练 提示词(Prompts) 我想让你充当一个费曼方法教练。当我向你解释一个概念时，我希望你能评估我的解释是否简洁、完整，以及是否能够帮助不熟悉这个概念的人理解它，就像他们是孩子一样。如果我的解释没有达到这些期望，我希望你能向我提出问题，引导我完善我的解释，直到我完全理解这个概念。另一方面，如果我的解释符合要求的标准，我将感谢你的反馈，我将继续进行下一次解释。 ","date":"2024-12-21","objectID":"/%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E9%92%88%E5%AF%B9pdf%E6%8F%90%E9%97%AEprompt/:1:1","tags":["编程"],"title":"期末复习针对pdf提问prompt","uri":"/%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E9%92%88%E5%AF%B9pdf%E6%8F%90%E9%97%AEprompt/"},{"categories":["编程"],"content":".tmux.conf # 基本设置 set-option -g history-limit 100000 # 提高历史记录限制，适合查看长时间的输出 set-option -g mouse on # 启用鼠标支持 #set-option -g default-shell /usr/bin/bash # 默认使用 Bash，视情况而定 set-option -g prefix C-a # 更改前缀键为 Ctrl + a (如不习惯可改回 C-b) unbind C-b # 取消 Ctrl + b 作为前缀键 bind C-a send-prefix # 保留 Ctrl + a 为前缀键 # 窗格管理 bind '\"' split-window -v # 快速切换窗格 bind h select-pane -L # 切换到左侧窗格 bind j select-pane -D # 切换到下方窗格 bind k select-pane -U # 切换到上方窗格 bind l select-pane -R # 切换到右侧窗格 # 更改窗格大小 bind -r H resize-pane -L 5 # 左调整窗格大小 bind -r J resize-pane -D 5 # 下调整窗格大小 bind -r K resize-pane -U 5 # 上调整窗格大小 bind -r L resize-pane -R 5 # 右调整窗格大小 # 鼠标滚轮绑定 bind -n WheelUpPane if-shell -F '#{pane_in_mode}' 'send-keys -M' 'copy-mode -e' # 鼠标滚轮向上时进入复制模式 bind -n WheelDownPane send-keys -M # 鼠标滚轮向下时退出复制模式 # 复制模式和粘贴 unbind -T copy-mode-vi v # 取消 vi 风格的视觉模式 bind -T copy-mode-vi v send -X begin-selection # 按 v 开始选择 bind -T copy-mode-vi y send -X copy-selection # 按 y 复制内容 bind p paste-buffer # 前缀键 + p 粘贴内容 # 状态栏优化 set-option -g status-interval 2 # 每 2 秒刷新状态栏 set-option -g status-left \"#[fg=green](#S) \" # 显示会话名 set-option -g status-right \"\" # 不显示时间 # 改进外观 set-option -g status-bg black # 状态栏背景色 set-option -g status-fg green # 状态栏前景色 set-window-option -g window-status-current-style bg=blue,fg=white # 当前窗口的状态栏样式 # 快速重载配置文件 bind r source-file ~/.tmux.conf \\; display-message \"Tmux 配置已重载\" # 前缀键 + r 重载配置 .vimrc \" 启用混合行号 set number relativenumber \" 启用语法高亮 syntax on \" 自动检测文件类型，加载相应插件和缩进规则 filetype plugin indent on \" 设置缩进相关配置 set tabstop=4 \" 一个 tab 键对应 4 个空格 set shiftwidth=4 \" 自动缩进使用 4 个空格 set expandtab \" 将 tab 转换为空格 set autoindent \" 自动缩进 set smartindent \" 根据语法自动调整缩进 \" 搜索时忽略大小写，除非有大写字母 set ignorecase set smartcase \" 实时高亮搜索结果 set hlsearch \" 但一旦你移动光标，高亮将被自动取消 autocmd CursorMoved * :nohlsearch \" 输入搜索模式时增量显示匹配结果 set incsearch \" 显示光标当前位置的状态行 set ruler \" 启用状态栏 set laststatus=2 \" 启用命令行补全 set wildmenu \" 启用光标下方 8 行预留显示 set scrolloff=6 \" 高亮当前行 set cursorline \" 显示匹配的括号 set showmatch \" 启用多级撤销 set undofile set undodir=~/.vim/undodir \" 保存撤销历史的目录 \" 减少更新屏幕的时间间隔（更快的响应速度） set updatetime=300 \" 减少交换文件写入的频率 set lazyredraw ","date":"2024-12-19","objectID":"/%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6config%E6%B1%87%E6%80%BB/:0:0","tags":["编程"],"title":"常用配置文件config汇总","uri":"/%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6config%E6%B1%87%E6%80%BB/"},{"categories":["编程"],"content":" git pull --rebase：用于 GitHub 上有多余的提交没有被本地同步，而本地又有了新的commit，此时直接 git pull 会导致 git merge 导致历史树过于复杂。而 git pull –rebase 则可以将历史树变成线性的。 首先，它会从远程 main 分支拉取最新的提交。 然后，Git 会暂时保存你本地的更改（即你修改的文件），并应用远程仓库的更改。 最后，Git 会将你本地的更改（之前未推送的）重新应用到拉取下来的远程更改之后。 ​ 最后通过git rebase --continue结束 rebase状态才能继续git push更新到仓库。 git reset --hard commitId ","date":"2024-12-14","objectID":"/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:0:0","tags":["编程"],"title":"Git常用命令","uri":"/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["编程"],"content":"注意：有三级标题的知识点说明已经学完，如果只有二级标题说明这个知识点还未收录经典题目进行整理学习，敬请期待… 题目格式模板： ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:0:0","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"AcWing 题目描述 ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:0:1","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"1064. 小国王 xxx 输入格式 xxx 输出格式 xxx 数据范围 $0\u003cN≤1000$ 输入样例： 输出样例： 算法设计 xxx 完整 C++ 代码 xxx 算法设计 xxx 完整 C++ 代码 xxx 第一章 基础算法 ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:0:2","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"快速排序 ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:1:0","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"AcWing 785. 快速排序 题目描述 给定你一个长度为 $𝑛$ 的整数数列。 请你使用快速排序对这个数列按照从小到大进行排序。 并将排好序的数列按顺序输出。 输入格式 输入共两行，第一行包含整数 $n$。 第二行包含 $n$ 个整数（所有整数均在 $1∼10^9$ 范围内），表示整个数列。 输出格式 输出共一行，包含 $n$ 个整数，表示排好序的数列。 数据范围 $1≤𝑛≤100000$ 输入样例： 5 3 1 2 4 5 输出样例： 1 2 3 4 5 算法设计 下面给出y总的快排模板： void quick_sort(int q[], int l, int r) { if (l \u003e= r) return; int i = l - 1, j = r + 1, x = q[l + r \u003e\u003e 1]; while (i \u003c j) { do i ++ ; while (q[i] \u003c x); do j -- ; while (q[j] \u003e x); if (i \u003c j) swap(q[i], q[j]); } quick_sort(q, l, j); quick_sort(q, j + 1, r); } 完整 C++ 代码 #include \u003ciostream\u003e using namespace std; const int N = 1000010; int q[N]; void quick_sort(int q[], int l, int r) { if (l \u003e= r) return; int i = l - 1, j = r + 1, x = q[l + r \u003e\u003e 1]; while (i \u003c j) { do i ++ ; while (q[i] \u003c x); do j -- ; while (q[j] \u003e x); if (i \u003c j) swap(q[i], q[j]); } quick_sort(q, l, j); quick_sort(q, j + 1, r); } int main() { int n; scanf(\"%d\", \u0026n); for (int i = 0; i \u003c n; i ++ ) scanf(\"%d\", \u0026q[i]); quick_sort(q, 0, n - 1); for (int i = 0; i \u003c n; i ++ ) printf(\"%d \", q[i]); return 0; } ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:1:1","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"二分查找 ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:2:0","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"AcWing 789. 数的范围 题目描述 给定一个按照升序排列的长度为 $n$ 的整数数组，以及 $q$ 个查询。 对于每个查询，返回一个元素 $k$ 的起始位置和终止位置（位置从 $0$ 开始计数）。 如果数组中不存在该元素，则返回 -1 -1。 输入格式 第一行包含整数 $n$ 和 $q$，表示数组长度和询问个数。 第二行包含 $n$ 个整数（均在 $1∼10000$ 范围内），表示完整数组。 接下来 $q$ 行，每行包含一个整数 $k$，表示一个询问元素。 输出格式 共 $q$ 行，每行包含两个整数，表示所求元素的起始位置和终止位置。 如果数组中不存在该元素，则返回 -1 -1。 数据范围 $1≤n≤100000$ $1≤q≤10000$ $1≤k≤10000$ 输入样例： 6 3 1 2 2 3 3 4 3 4 5 输出样例： 3 4 5 5 -1 -1 算法设计 一般的二分查找问题其实都可以抽象成一个更具体的问题：如何满足条件的第一次出现和最后一次出现的元素下标？ 下面我们给出模板： bool check(int x) { // 坚持元素x是否满足条件 } // 模板1：求满足条件的第一次出现的元素下标 int bsearch_1(int* a, int l, int r) { while (l \u003c r) { int mid = l + r \u003e\u003e 1; if (check(a[mid])) r = mid; else l = mid + 1; } return l; } // 模板2：求满足条件的最后一次出现的元素下标 int bsearch_2(int* a, int l, int r) { while (l \u003c r) { int mid = l + r + 1 \u003e\u003e 1; // 这里要+1是因为l=mid，如何l+r\u003e\u003e1可能还是l，会死循环 if (check(a[mid])) l = mid; else r = mid - 1; } return l; } 注：模板中使用了右移运算 $»1$，而不是整数除法 $/ 2$。这是因为右移运算是向下取整，而整数除法是向 $0$ 取整，当二分区间出现负数时后者会出 bug。 那么对于本题来说，求升序排列数组中元素 $k$ 的起始位置和终止位置，也可以转化成刚刚一个更抽象的问题。 假设我们有下面数组： $$ \\begin{matrix}1,\\ 3,\\ \\underbrace{ 6,\\ 6, \\ 6,\\ 6, } \\ 8,\\ 9,\\ 9,\\ 10 \\end{matrix} $$ 我们需要找到元素 $6$ 出现的起始位置和终止位置。 显然，元素 $6$ 的起始位置其实可以看成是满足 $x \\ge 6$ 条件的第一次出现的元素下标 ： $$ \\begin{matrix} 1,\\ 3, \\ \\underbrace{6,\\ 6, \\ 6,\\ 6,\\ 8,\\ 9,\\ 9,\\ 10} \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ge6 \\end{matrix} $$ 所以我们使用模板1就可以求解。 求终止位置的思路类似，这里就不再赘述。 这里我们引入灵茶山艾府灵神的写法来作参考，因为这种写法和c++中STL中给出的lower_bound()和upper_bound()的思想一致，应用了循环不变量的核心思想。 下面我们先看看如何找到满足 $≥$target的第一次出现的元素下标： 关键： 循环不变量 $L-1$ 始终是红色(＜target) $R+1$ 始终是蓝色(≥target) lower_bound()模板如下： // 找到第一个≥target的下标 int lower_bound(vector\u003cint\u003e\u0026 nums, int target) { // 闭区间:[l, r] int l = 0, r = nums.size() - 1; while (l \u003c= r) // 区间不为空 { int mid = l + r \u003e\u003e 1; if (nums[mid] \u003c target) l = mid + 1; // 区间缩小为[mid + 1, r] else r = mid - 1; // 区间缩小为[l, mid - 1] } return l; } 根据循环不变量， $R+1$ 是我们要找的答案，又由于循环终止条件 $L=R+1$，故答案也可以直接用 $L$ 表示。 下面我们来讨论常见的四种形式：$\\ \\ge,\\ \\le,\\ \u003c$ 对于整数而言，其实这四种情况只需要实现 lower_bound() 都可以解决: $\\ge t$：lower_bound(t) $\u003et$：lower_bound(t + 1) $\\le t$：lower_bound(t + 1) - 1 $\u003ct$：lower_bound(t) - 1 完整 C++ 代码 #include\u003ciostream\u003e using namespace std; const int N = 1e5 + 10; int a[N]; void binarySearch(int* a, int n, int k) { int l = 0, r = n - 1; while (l \u003c r) { int mid = l + r \u003e\u003e 1; if (a[mid] \u003e= k) r = mid; else l = mid + 1; } if (a[l] != k) { cout \u003c\u003c -1 \u003c\u003c \" \" \u003c\u003c -1 \u003c\u003c endl; return; } else { cout \u003c\u003c l \u003c\u003c \" \"; int l = 0, r = n - 1; while (l \u003c r) { int mid = l + r + 1 \u003e\u003e 1; if (a[mid] \u003c= k) l = mid; else r = mid - 1; } cout \u003c\u003c l \u003c\u003c endl; } } int main() { int n, q; cin \u003e\u003e n \u003e\u003e q; for (int i = 0; i \u003c n; i++) cin \u003e\u003e a[i]; for (int i = 0; i \u003c q; i++) { int x; cin \u003e\u003e x; binarySearch(a, n, x); } } 拓展 ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:2:1","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"790. 数的三次方根 给定一个浮点数 $n$，求它的三次方根。 输入格式 共一行，包含一个浮点数 $n$。 输出格式 共一行，包含一个浮点数，表示问题的解。 注意，结果保留 $6$ 位小数。 数据范围 $−10000≤n≤10000$ 输入样例： 1000.00 输出样例： 10.000000 算法设计 这题是收录的小数二分的经典例题，小数二分比起整数二分来说要简单许多。 其实整数二分的模板为什么要分成两个，就是因为对于区间划分的时候，有时候需要 $l+r»1$ 进行下取整，有时候又需要 $l+r+1»1$ 进行上取整，才能得到 $\\text{mid}$ 值，这里因为我们的区间不是一个数组，而是数轴范围，所以这里 $l + r » 1$ 就可以直接作为我们划分依据，而无需取整。 这里我还想谈谈误差。由于计算机的二进制无法精确表示很多小数，就比如 $0.1$ 在计算机内部就无法被精确表示出来，$0.1$ 的二进制近似表示为 $0.000110011001100110011…$（无限循环），由于计算机的存储空间有限，所以只能截断这个无限循环的小数，导致了误差。 所以当我们运行下面的程序，便可以清晰的看出来确实是有误差，只是编译器默认会对 $\\text{double}$ 进行格式化输出，只显示足够接近真实值的小数位，隐藏了实际内部存储的误差。但当我们加参数让他多显示些小数位时便暴露出来了。 double a = 0.1; printf(\"%f\\n\", a); printf(\"%.20f\\n\", a); // 编译器输出： // 0.100000 // 0.10000000000000000555 所以此题我们在求 $n$ 的三次方根时，也需要将误差考虑进去， 这里我们给出一般经验：如果题目要求保留小数点后 $k$ 位，我们就使用 $1\\times 10^{-(k+2)}$ 作为误差，下面我们给出证明： 我们假设实际结果为 $0.123456 4555555555$。 直接保留 $6$ 位小数：$0.123456$ 先精确到 $7$ 位小数：$0.1234565$，再保留六位小数：$0.123457$ 先精确到 $8$ 位小数：$0,12345646$，再保留六位小数：$0.123456$ 因此使用 $k+2$ 位作为误差，可以使得 $k + 1$ 位是较为精准的，这样就不会因为进位影响到我们要求的第 $k$ 位了（当然误差位数越多越好了）。 当然这里还有个小细节： 不要想当然的把 $r = x$, 因为有可能 $x =0.001$，但是它的三次方根却是 $0.1$，即结果是大于 $x$ 的，所以应该严谨点写成 $x = \\max(1, x)$ 。但是我们这里就直接简单点把 $r$ 设置为 $x$ 的理论最大值。 当然有时候精度不好把控，可以干脆采用循环固定次数的二分方法，也是一种相当不错的策略。这种方法得到的结果的精度通常比刚刚直接设定误差更高。 代码见下面。 完整 C++ 代码 设定误差版本： #include\u003ciostream\u003e using namespace std; int main() { double x; cin \u003e\u003e x; double l = -10000, r = 10000; while (r - l \u003e 1e-8) { double mid = (l + r) / 2; // 这里要用double if (mid * mid * mid \u003e= x) r = mid; else l = mid; } printf(\"%.6f\", l); } 循环固定次数版本 #include\u003ciostream\u003e using namespace std; int main() { double x; cin \u003e\u003e x; double l = -10000, r = 10000; for (int i = 0; i \u003c 100; i ++) // 固定循环100次 { double mid = (l + r) / 2; // 这里要用double if (mid * mid * mid \u003e= x) r = mid; else l = mid; } printf(\"%.6f\", l); } ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:2:2","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"高精度 ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:3:0","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"AcWing 791. 高精度加法 题目描述 ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:3:1","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"791. 高精度加法 给定两个正整数（不含前导 $0$ ），计算它们的和。 输入格式 共两行，每行包含一个整数。 输出格式 共一行，包含所求的和。 数据范围 $1≤$ 整数长度 $≤100000$ 输入样例： 12 23 输出样例： 35 算法设计 下面给出大数加法算法模板 string addStrings(string num1, string num2) { int i = num1.size() - 1, j = num2.size() - 1; string res; int add = 0; while (i \u003e= 0 || j \u003e= 0 || add) { int x = i \u003e= 0 ? num1[i] - '0' : 0; int y = j \u003e= 0 ? num2[j] - '0' : 0; res += '0' + (x + y + add) % 10; add = (x + y + add) / 10; i --, j --; } reverse(res.begin(), res.end()); return res; } 完整 C++ 代码 ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:3:2","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"AcWing 5900. 高精度乘法 题目描述 ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:3:3","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"5900. 高精度乘法 输入两个高精度正整数 $M$ 和 $N$。 求这两个高精度数的积。 输入格式 第一行包含高精度正整数 $M$。 第二行包含高精度正整数 $N$。 输出格式 输出这两个高精度数的积。 数据范围 $M$ 和 $N$ 均小于 $100$ 位。 输入样例： 36 3 输出样例： 108 算法设计 普通竖式 以num1 = $123$ , num2 = $456$ 为例：我们遍历 num2 每一位与 num1 进行相乘，将每一步的结果进行累加，在这个过程如果相乘或者相加的结果大于等于$10$ ，我们都要去满 $10$ 进位，如下图所示： 这样模拟普通竖式计算的方法时间复杂度为 $O(n(m+n))$，我们可以考虑优化版的竖式计算。 优化竖式 其实在相乘或者相加计算过程的每一位，我们可以考虑先不去满 $10$ 进位，等到计算完所有的相乘结果以后，最终将其加到一块，再去满$10$ 进位 ，最后的结果和普通竖式 一样，但却可以大大简化我们的模拟过程。(如下图所示) 关键点：$C[i+j] = A[i] \\times B[j]$ 由此时间复杂度降低为 $O(mn)$，算法模板如下： string multiply(string num1, string num2) { vector\u003cint\u003e a, b; int n = num1.size(), m = num2.size(); for (int i = n - 1; i \u003e= 0; i --) a.push_back(num1[i] - '0'); for (int i = m - 1; i \u003e= 0; i --) b.push_back(num2[i] - '0'); vector\u003cint\u003e c(n + m, 0); for (int i = 0; i \u003c n; i ++) { for (int j = 0; j \u003c m; j ++) { c[i + j] += a[i] * b[j]; } } int add = 0; string ans; for (int i = 0; i \u003c m + n || add; i ++) { int x = c[i] + add; add = x / 10; ans += '0' + x % 10; } reverse(ans.begin(), ans.end()); int idx = 0; while (ans[idx] == '0' \u0026\u0026 idx \u003c ans.size() - 1) idx ++; ans = ans.substr(idx, ans.size() - idx); return ans; } 完整 C++ 代码 ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:3:4","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"枚举 ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:4:0","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"AcWing 92. 递归实现指数型枚举 题目描述 ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:4:1","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"92. 递归实现指数型枚举 从 $1∼n$ 这 $n$ 个整数中随机选取任意多个，输出所有可能的选择方案。 输入格式 输入一个整数 $n$。 输出格式 每行输出一种方案。 同一行内的数必须升序排列，相邻两个数用恰好 $1$ 个空格隔开。 对于没有选任何数的方案，输出空行。 本题有自定义校验器（SPJ），各行（不同方案）之间的顺序任意。 数据范围 $1≤n≤15$ 输入样例： 3 输出样例： 3 2 2 3 1 1 3 1 2 1 2 3 算法设计 所谓指数型枚举，其实就是对于每一个数都有选和不选两种情况，所以最终情况是 $2^n$ 种，所以叫他指数型。 这里其实用了一个第五章状态压缩 $\\text{DP}$ 中提到的二进制状态压缩的思想，将原本需要维护的一个 bool 数组优化成了一个二进制数。 完整 C++ 代码 #include \u003ciostream\u003e using namespace std; int n; void dfs(int u, int state) { if (u == n) { for (int k = 0; k \u003c n; k ++) if (state \u003e\u003e k \u0026 1) cout \u003c\u003c k + 1 \u003c\u003c \" \"; cout \u003c\u003c endl; return; } dfs(u + 1, state); // 不用第u个数 dfs(u + 1, state | (1 \u003c\u003c u)); // 用第u个数，就把第u个位置置成1 } int main() { cin \u003e\u003e n; dfs(0, 0); return 0; } ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:4:2","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"AcWing 93. 递归实现组合型枚举 题目描述 ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:4:3","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"93. 递归实现组合型枚举 从 $1∼n$ 这 $n$ 个整数中随机选出 $m$ 个，输出所有可能的选择方案。 输入格式 两个整数 $n,m$ ,在同一行用空格隔开。 输出格式 按照从小到大的顺序输出所有方案，每行 $1$ 个。 首先，同一行内的数升序排列，相邻两个数用一个空格隔开。 其次，对于两个不同的行，对应下标的数一一比较，字典序较小的排在前面（例如 1 3 5 7 排在 1 3 6 8 前面）。 数据范围 $n\u003e0,$ $0≤m≤n ,$ $n+(n−m)≤25$ 输入样例： 5 3 输出样例： 1 2 3 1 2 4 1 2 5 1 3 4 1 3 5 1 4 5 2 3 4 2 3 5 2 4 5 3 4 5 思考题：如果要求使用非递归方法，该怎么做呢？ 算法设计 组合型枚举的所有情况就包含在我们刚刚的指数型枚举的情况中，所以我们只需要在刚刚的指数型枚举的基础上加上剪枝操作即可。 当然还有非递归版本，也就是手动模拟递归栈。 就比如当第一轮 $\\text{dfs}$ 运行到第 $19$ 行dfs(u + 1, cnt + 1, state | (1 \u003c\u003c u))，那么系统会将当前当前的参数数和行号都压入栈中，然后再执行。 我们要做的其实就是手动写一个栈，每次将递归的参数压入栈，将刚刚的递归代码翻译成进栈操作即可。 完整 C++ 代码 递归版本代码： #include \u003ciostream\u003e using namespace std; int n, m; void dfs(int u, int cnt, int state) { if (cnt + n - u \u003c m) return; // 提前可行性剪枝：如果后续全选都不够m个，就可以提前退出了 if (cnt == m) { for (int k = 0; k \u003c n; k ++) if (state \u003e\u003e k \u0026 1) cout \u003c\u003c k + 1 \u003c\u003c \" \"; cout \u003c\u003c endl; return; } // 这里按照字典序来排，所以得换个顺序 dfs(u + 1, cnt + 1, state | (1 \u003c\u003c u)); // 用第u个数，就把第u个位置置成1 dfs(u + 1, cnt, state); // 不用第u个数 } int main() { cin \u003e\u003e n \u003e\u003e m; dfs(0, 0, 0); return 0; } 非递归版本代码： #include \u003ciostream\u003e #include \u003cstack\u003e using namespace std; int n, m; struct State { int pos, u, cnt, state; // pos：已经运行到的状态区域; u,cnt,state：递归参数 }; // void dfs(int u, int cnt, int state) // { // // 状态0区域： // if (cnt + n - u \u003c m) return; // if (cnt == m) // { // for (int k = 0; k \u003c n; k ++) // if (state \u003e\u003e k \u0026 1) // cout \u003c\u003c k + 1 \u003c\u003c \" \"; // cout \u003c\u003c endl; // return; // } // // 状态1区域： // dfs(u + 1, cnt + 1, state | (1 \u003c\u003c u)); // // 状态2区域： // dfs(u + 1, cnt, state); // } int main() { cin \u003e\u003e n \u003e\u003e m; stack\u003cState\u003e stk; // 模拟递归栈 stk.push({0, 0, 0, 0}); while (stk.size()) { auto cur = stk.top(); stk.pop(); switch (cur.pos) { case 0: // 如果对应区域0状态 // 把递归dfs里面区域1的代码翻译过来就可以了：return翻译成continue，变量改一下,递归调用变成进栈操作 if (cur.cnt + n - cur.u \u003c m) continue; if (cur.cnt == m) { for (int k = 0; k \u003c n; k ++) if (cur.state \u003e\u003e k \u0026 1) cout \u003c\u003c k + 1 \u003c\u003c \" \"; cout \u003c\u003c endl; continue; } stk.push({1, cur.u, cur.cnt, cur.state}); // 当前状态进栈 stk.push({0, cur.u + 1, cur.cnt + 1, cur.state | (1 \u003c\u003c cur.u)}); // dfs(u+1, cnt+1, state | (1 \u003c\u003c u)); continue; case 1: // 如果对应区域1状态 stk.push({2, cur.u, cur.cnt, cur.state}); // 当前状态进栈 stk.push({0, cur.u + 1, cur.cnt, cur.state}); // dfs(u+1, cnt, state); continue; case 2: // 如果对应区域2状态 continue; } } return 0; } ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:4:4","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"AcWing 94. 递归实现排列型枚举 题目描述 ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:4:5","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"94. 递归实现排列型枚举 把 $1∼n$ 这 $n$ 个整数排成一行后随机打乱顺序，输出所有可能的次序。 输入格式 一个整数 $n$。 输出格式 按照从小到大的顺序输出所有方案，每行 $1$ 个。 首先，同一行相邻两个数用一个空格隔开。 其次，对于两个不同的行，对应下标的数一一比较，字典序较小的排在前面。 数据范围 $1≤n≤9$ 输入样例： 3 输出样例： 1 2 3 1 3 2 2 1 3 2 3 1 3 1 2 3 2 1 算法设计 排列型枚举就不需要传入当前遍历到哪个数了，而是从 $0$ 开始继续遍历。 完整 C++ 代码 #include \u003ciostream\u003e #include \u003cvector\u003e using namespace std; int n; vector\u003cint\u003e ans; void dfs(int state) { if (ans.size() == n) { for (auto i : ans) cout \u003c\u003c i \u003c\u003c \" \"; cout \u003c\u003c endl; return; } for (int u = 0; u \u003c n; u ++) { if (!(state \u003e\u003e u \u0026 1)) { ans.push_back(u + 1); dfs(state | (1 \u003c\u003c u)); // 用第u个数，就把第u个位置置成1 ans.pop_back(); // 恢复现场 } } } int main() { cin \u003e\u003e n; dfs(0); return 0; } ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:4:6","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"前缀和 ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:5:0","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"AcWing 795. 前缀和 题目描述 输入一个长度为 $n$ 的整数序列。 接下来再输入 $m$ 个询问，每个询问输入一对 $l$, $r$。 对于每个询问，输出原序列中从第 $l$ 个数到第 $r$ 个数的和。 输入格式 第一行包含两个整数 $n$ 和 $m$。 第二行包含 $n$ 个整数，表示整数数列。 接下来 $m$ 行，每行包含两个整数 $l$ 和 $r$，表示一个询问的区间范围。 输出格式 共 $m$ 行，每行输出一个询问的结果。 数据范围 $1≤l≤r≤n$, $1≤n,m≤100000$, $−1000≤$ 数列中元素的值 $≤1000$ 输入样例： 5 3 2 1 3 6 4 1 2 1 3 2 4 输出样例： 3 6 10 算法设计 前缀和的思想用的挺多的,可以将多次的求一段连续区间和的时间复杂度从 $O(n^2)$ 优化到 $O(n)$，拓展题中添加了一道二维的前缀和，可以一块看看。 构造 $s_i=a_1+a_2+…+a_i$，通过提前预处理一个 $s$ 数组来存储累加和。 完整C++ 代码 #include \u003ciostream\u003e using namespace std; const int N = 100010; int n, m; int s[N]; int main() { cin \u003e\u003e n \u003e\u003e m; for (int i = 1; i \u003c= n; i++) { int a; cin \u003e\u003e a; s[i] = s[i - 1] + a; } while (m--) { int l, r; cin \u003e\u003e l \u003e\u003e r; cout \u003c\u003c s[r] - s[l - 1] \u003c\u003c endl; } return 0; } 拓展 ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:5:1","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"796. 子矩阵的和 输入一个 $n$ 行 $m$ 列的整数矩阵，再输入 $q$ 个询问，每个询问包含四个整数 $x1,y1,x2,y2$，表示一个子矩阵的左上角坐标和右下角坐标。 对于每个询问输出子矩阵中所有数的和。 输入格式 第一行包含三个整数 $n，m，q$。 接下来 $n$ 行，每行包含 $m$ 个整数，表示整数矩阵。 接下来 $q$ 行，每行包含四个整数 $x1,y1,x2,y2$，表示一组询问。 输出格式 共 $q$ 行，每行输出一个询问的结果。 数据范围 $1≤n,m≤1000$, $1≤q≤200000$, $1≤x1≤x2≤n$, $1≤y1≤y2≤m$, $−1000≤$矩阵内元素的值$≤1000$ 输入样例： 3 4 3 1 7 2 4 3 6 2 8 2 1 2 3 1 1 2 2 2 1 3 4 1 3 3 4 输出样例： 17 27 21 算法剖析 这是一道经典的二维前缀和模板题，这里的最终表达式有点像概率论里面那个二维联合分布函数的味道。 完整C++ 代码 #include \u003ciostream\u003e using namespace std; const int N = 1010; int n, m, q; int s[N][N]; int main() { cin \u003e\u003e n \u003e\u003e m \u003e\u003e q; for (int i = 1; i \u003c= n; i++) { for (int j = 1; j \u003c= m; j++) { int w; cin \u003e\u003e w; s[i][j] = s[i - 1][j] + (s[i][j - 1] - s[i - 1][j - 1]) + w; } } while (q--) { int x1, y1, x2, y2; cin \u003e\u003e x1 \u003e\u003e y1 \u003e\u003e x2 \u003e\u003e y2; cout \u003c\u003c s[x2][y2] - s[x1 - 1][y2] - s[x2][y1 - 1] + s[x1 - 1][y1 - 1] \u003c\u003c endl; } return 0; } ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:5:2","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"快速幂 ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:6:0","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"AcWing 875. 快速幂 题目描述 ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:6:1","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"875. 快速幂 给定 nn 组 ai,bi,piai,bi,pi，对于每组数据，求出 abiimodpiaibimodpi 的值。 输入格式 第一行包含整数 nn。 接下来 nn 行，每行包含三个整数 ai,bi,piai,bi,pi。 输出格式 对于每组数据，输出一个结果，表示 abiimodpiaibimodpi 的值。 每个结果占一行。 数据范围 1≤n≤1000001≤n≤100000, 1≤ai,bi,pi≤2×1091≤ai,bi,pi≤2×109 输入样例： 2 3 2 5 4 3 9 输出样例： 4 1 ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:6:2","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"差分 ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:7:0","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"AcWing 797. 差分 题目描述 有输入一个长度为 $n$ 的整数序列。 接下来输入 $m$ 个操作，每个操作包含三个整数 $l,r,c$，表示将序列中 $[l,r]$ 之间的每个数加上 $c$。 请你输出进行完所有操作后的序列。 输入格式 第一行包含两个整数 $n$ 和 $m$。 第二行包含 $n$ 个整数，表示整数序列。 接下来 $m$ 行，每行包含三个整数 $l，r，c$，表示一个操作。 输出格式 共一行，包含 $n$ 个整数，表示最终序列。 数据范围 $1≤n,m≤100000$, $1≤l≤r≤n$, $−1000≤c≤1000$, $−1000≤\\ $整数序列中元素的值$\\ ≤1000$ 输入样例： 6 3 1 2 2 1 2 1 1 3 1 3 5 1 1 6 1 输出样例： 3 4 5 3 4 2 算法设计 差分其实可以看作是前缀和操作的逆运算。 通过构造 $B$ 数组：使得：$a_i = b_1+b_2+…+b_i$，那么我们对 $B$ 数组进行一次前缀和操作就可以得到 $a_i$。那么就可以在 $O(n)$ 的时间由 $B$ 数组反推出 $A$ 数组。 $B$ 数组有一个好处，可以在 $O(1)$ 的时间里将 $[l, r]$ 中每一个数加上 $c$ ：通过令 $b_l + c,b_{r+1} - c$ 即可。 朴素解法 C++ 代码 由$\\begin{cases} a_i = b_1+b_2+…+b_i\\ a_{i-1} = b_1+b_2+…+b_{i-1} \\end{cases}$$\\Rightarrow b_i = a_{i}-a_{i-1}\\ \\ \\ \\ \\ (1)$ 直接利用公式 $(1)$ $b_i = a_{i}-a_{i-1}$ 来初始化 $B$ 数组。 #include \u003ciostream\u003e using namespace std; const int N = 100010; int n, m; int a[N], b[N], s[N]; int main() { cin \u003e\u003e n \u003e\u003e m; for (int i = 1;i \u003c= n; i++) { cin \u003e\u003e a[i]; b[i] = a[i] - a[i - 1]; } while (m--) { int l, r, c; cin \u003e\u003e l \u003e\u003e r \u003e\u003e c; b[l] += c; b[r + 1] -= c; } for (int i = 1; i \u003c= n; i++) { s[i] = s[i - 1] + b[i]; cout \u003c\u003c s[i] \u003c\u003c \" \"; } return 0; } 优美解法 C++ 代码 一开始 $A, B$ 数组初值都为0，已经满足差分定义了。 此时每次读取后更新A数组的值 $a_i$，其实就可以看作是对 $A$ 数组 $[i, i]$ 区间上的每一个数加上 $a_i$, 所以直接复用后面的差分代码即可完成对 $B$ 数组的初始化。 #include \u003ciostream\u003e using namespace std; const int N = 100010; int n, m; int a, b[N]; void insert(int l, int r, int c) { b[l] += c; b[r + 1] -= c; } int main() { cin \u003e\u003e n \u003e\u003e m; for (int i = 1;i \u003c= n; i++) { cin \u003e\u003e a; insert(i, i, a); // 点金之笔，代码复用 } while (m--) { int l, r, c; cin \u003e\u003e l \u003e\u003e r \u003e\u003e c; insert(l, r, c); } for (int i = 1; i \u003c= n; i++) { b[i] += b[i - 1]; // 直接偷懒不再用s数组来存前缀和了 cout \u003c\u003c b[i] \u003c\u003c \" \"; } return 0; } ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:7:1","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"双指针 ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:8:0","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"AcWing 800. 数组元素的目标和 题目描述 ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:8:1","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"800. 数组元素的目标和 给定两个升序排序的有序数组 $A$ 和 $B$，以及一个目标值 $x$。 数组下标从 $0$ 开始。 请你求出满足 $A[i]+B[j]=x$ 的数对 $(i,j)$。 数据保证有唯一解。 输入格式 第一行包含三个整数 $n,m,x$，分别表示 $A$ 的长度，$B$ 的长度以及目标值 $x$。 第二行包含 $n$ 个整数，表示数组 $A$。 第三行包含 $m$ 个整数，表示数组 $B$。 输出格式 共一行，包含两个整数 $i$ 和 $j$。 数据范围 数组长度不超过 $10^5$。 同一数组内元素各不相同。 $1≤$数组元素$≤10^9$ 输入样例： 4 5 6 1 2 4 7 3 4 6 8 9 输出样例： 1 1 算法设计 双指针是算法中降低时间复杂度的一个常用方法，可以把暴力解法的 $O(n^2)$ 降低至 $O(n)$。 其实它主要是利用每一次判断可以将 $n$ 种可能状态排除。 常用的双指针法有一下几类： 左右指针：两个指针，相向而走，中间相遇。 快慢指针：两个指针，有快有慢，同向而行。 灵活运用：两个指针，灵活运用，伺机而动。 对于本题，状态空间如图所示，有 $mn$ 个 $(i,j)$ 的状态： 由于 $A,B$ 都是升序排列的数组，所以有以下结论： 若 $A_i+B_j\u003ex$，显然 $A_{i+1}+B_j\u003ex$，所以对应于上图第 $j$ 列的状态可以被全部排除。 若 $A_i+B_j\u003cx$，显然 $A_{i}+B_{j-1}\u003cx$，所以对应于上图第 $i$ 行的状态也可以被全部排除。 由此可知最多进行 $n+m$ 次操作即可遍历所有的状态空间情况。 完整 C++ 代码 #include \u003ciostream\u003e using namespace std; const int N = 100010; int n, m, x; int a[N], b[N]; int main() { cin \u003e\u003e n \u003e\u003e m \u003e\u003e x; for (int i = 0; i \u003c n; i ++) cin \u003e\u003e a[i]; for (int i = 0; i \u003c m; i ++) cin \u003e\u003e b[i]; for (int i = 0, j = m - 1; ; ) { if (a[i] + b[j] \u003e x) j --; else if (a[i] + b[j] \u003c x) i ++; else { cout \u003c\u003c i \u003c\u003c ' ' \u003c\u003c j \u003c\u003c endl; return 0; } } } ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:8:2","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"滑动窗口 ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:9:0","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"LeetCode 1456. 定长子串中元音的最大数目 题目描述 ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:9:1","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"LeetCode 1456. 定长子串中元音的最大数目 给你字符串 s 和整数 k 。 请返回字符串 s 中长度为 k 的单个子字符串中可能包含的最大元音字母数。 英文中的 元音字母 为（a, e, i, o, u）。 示例 1： 输入：s = \"abciiidef\", k = 3 输出：3 解释：子字符串 \"iii\" 包含 3 个元音字母。 示例 2： 输入：s = \"aeiou\", k = 2 输出：2 解释：任意长度为 2 的子字符串都包含 2 个元音字母。 示例 3： 输入：s = \"leetcode\", k = 3 输出：2 解释：\"lee\"、\"eet\" 和 \"ode\" 都包含 2 个元音字母。 示例 4： 输入：s = \"rhythms\", k = 4 输出：0 解释：字符串 s 中不含任何元音字母。 示例 5： 输入：s = \"tryhard\", k = 4 输出：1 提示： $1 \u003c= s.length \u003c= 10^5$ $s$ 由小写英文字母组成 $1 \u003c= k \u003c= s.length$ 算法设计 ​ 这是一道经典的定长滑动窗口模板题，下面给出我对灵神的定长滑动窗口模板的修改版本，让他和不定长滑窗写法类似： //外层循环扩展右边界，内层循环扩展左边界 for (int l = 0, r = 0 ; r \u003c n ; r ++) { // 1. 先更新右指针 // 2. 窗口大小不足 k 跳过 if (r \u003c k - 1) continue; // 3. 区间[left,right]符合题意，统计相关信息 // 4. 调整左窗口 // 5. 拓展左边界 } 完整 C++ 代码 class Solution { public: bool check(char c) { if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') return true; return false; } int maxVowels(string s, int k) { int n = s.size(); int mx = 0; int cnt = 0; for (int l = 0, r = 0; r \u003c n; r ++) { // 右端点进入窗口 if (check(s[r])) cnt ++; // 窗口大小不足 k 跳过 if (r \u003c k - 1) continue; // 更新答案 mx = max(mx, cnt); // 左端点离开窗口 if (check(s[l])) cnt --; l ++; } return mx; } }; ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:9:2","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"LeetCode 3. 无重复字符的最长子串 题目描述 ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:9:3","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"3. 无重复字符的最长子串 给定一个字符串 $s$ ，请你找出其中不含有重复字符的 最长子串 的长度。 示例 1: 输入: s = \"abcabcbb\" 输出: 3 解释: 因为无重复字符的最长子串是 \"abc\"，所以其长度为 3。 示例 2: 输入: s = \"bbbbb\" 输出: 1 解释: 因为无重复字符的最长子串是 \"b\"，所以其长度为 1。 示例 3: 输入: s = \"pwwkew\" 输出: 3 解释: 因为无重复字符的最长子串是 \"wke\"，所以其长度为 3。 请注意，你的答案必须是 子串 的长度，\"pwke\" 是一个子序列，不是子串。 提示： $0 \u003c= s.length \u003c= 5 \\times 10^4$ $s$ 由英文字母、数字、符号和空格组成 算法设计 我的精神病一触即发 发布于 江苏(编辑过) 2024.07.31 我希望这种滑动窗口的模板题，你们不要再写的五花八门了。这是最简单的模板，拿走不谢。 模板： 注：2025.01.08 已经由我根据灵神题解更新了一下这个兄弟的模板，感觉更符合直觉写法 //外层循环扩展右边界，内层循环扩展左边界 for (int l = 0, r = 0 ; r \u003c n ; r ++) { // 1. 先更新右指针 while (l \u003c= r \u0026\u0026 check()) // 调整左指针 { // 2. 扩展左边界 } // 3. 区间[left,right]符合题意，统计相关信息 } 完整 C++ 代码 class Solution { public: int lengthOfLongestSubstring(string s) { unordered_map\u003cchar, int\u003e hash_c; int ans = 0; for (int l = 0, r = 0; r \u003c s.size(); r ++) { hash_c[s[r]] ++; // 先更新右指针 while (hash_c[s[r]] \u003e 1) // 调整左指针 hash_c[s[l]] --, l ++; ans = max(ans, r - l + 1); // 区间符合题意，统计相关信息 } return ans; } }; ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:9:4","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"位运算 ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:10:0","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"AcWing 801. 二进制中1的个数 题目描述 ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:10:1","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"801. 二进制中1的个数 给定一个长度为 $n$ 的数列，请你求出数列中每个数的二进制表示中 $1$ 的个数。 输入格式 第一行包含整数 $n$。 第二行包含 $n$ 个整数，表示整个数列。 输出格式 共一行，包含 $n$ 个整数，其中的第 $i$ 个数表示数列中的第 $i$ 个数的二进制表示中 $1$ 的个数。 数据范围 $1≤n≤100000,$ $0≤$数列中元素的值$≤10^9$ 输入样例： 5 1 2 3 4 5 输出样例： 1 1 2 1 2 算法设计 下面我给出下面常用的位运算代码模板： 求 $n$ 的第 $k$ 位数字： n \u003e\u003e k \u0026 1 $\\text{lowbit}$ 算法：其实是树状数组的基本操作，返回 $n$ 的最低位 $1$ 及其后面所有的 $0$ 构成的子串，如 $101000$ 返回 $1000$：lowbit(n) = n \u0026 (-n) = n \u0026 (~n + 1) 下面我们对 $\\text{lowbit}$ 运算给出证明： ​ 设 $n\u003e0$，$n$ 的第 $k$ 位为 $1$, $0∼k-1$ 位为 $0$。我们首先实现 $n=∼n$，也即将 $n$ 按位取反，此时 $n$ 的第 $k$ 位为 $0$, $0∼k-1$ 位为 $1$。我们再令 $n=n+1$，这时因为进位，第 $k$ 位变为 $1$, $0∼k-1$ 位都是 $0$，第 $k+1$ 到最高位都和原来的相反，所以此时再进行按位 $\u0026$，所得到的结果仅有第 $k$ 位为 $1$，其余位都是 $0$。 ​ 又由于补码定义：~n = -1 - n，也即-n = ~n + 1。 ​ 综上所述，证明完毕。 所以我们就能直接利用 $\\text{lowbit}$ 算法，每次让 $n - lowbit(n)$ 即可，$n$ 中 $1$ 的个数其实就是多少次能让 $n$ 变成 $0$ 。 完整 C++ 代码 #include \u003ciostream\u003e using namespace std; const int N = 100000; int lowbit(int x) // 返回最低位1及其后面所有的0构成的子串 { return x \u0026 -x; } int main() { int n; cin \u003e\u003e n; while (n --) { int x; cin \u003e\u003e x; int cnt = 0; while (x) cnt ++, x -= lowbit(x); cout \u003c\u003c cnt \u003c\u003c \" \"; } return 0; } ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:10:2","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"离散化 ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:11:0","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"区间合并 ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:12:0","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"AcWing 803. 区间合并 题目描述 ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:12:1","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"803. 区间合并 给定 $n$ 个区间 $[l_i,r_i]$，要求合并所有有交集的区间。 注意如果在端点处相交，也算有交集。 输出合并完成后的区间个数。 例如：$[1,3]$ 和 $[2,6]$ 可以合并为一个区间 $[1,6]$。 输入格式 第一行包含整数 $n$。 接下来 $n$ 行，每行包含两个整数 $l$ 和 $r$。 输出格式 共一行，包含一个整数，表示合并区间完成后的区间个数。 数据范围 $1≤n≤100000$, $−10^9≤l_i≤r_i≤10^9$ 输入样例： 5 1 2 2 4 5 6 7 8 7 9 输出样例： 3 算法设计 这题还是很基础的，算法就不再赘述了。 完整 C++ 代码 #include \u003ciostream\u003e #include \u003ccstring\u003e #include \u003calgorithm\u003e using namespace std; typedef pair\u003cint, int\u003e PII; const int N = 100010, INF = 0x3f3f3f3f; PII a[N]; int ans; int main() { int n; cin \u003e\u003e n; for (int i = 0; i \u003c n; i ++) cin \u003e\u003e a[i].first \u003e\u003e a[i].second; sort(a, a + n); int l = -INF, r = -INF; for (int i = 0; i \u003c n; i ++) { if (a[i].first \u003e r) { ans ++; l = a[i].first; r = a[i].second; } else r = max(r, a[i].second); } cout \u003c\u003c ans \u003c\u003c endl; return 0; } ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:12:2","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"构造 一种思维题，很像数学 ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:13:0","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"打表 第二章 数据结构 ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:14:0","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"滚动数组 ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:15:0","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"AcWing21. 斐波那契数列 题目描述 输入一个整数 $n$ ，求斐波那契数列的第 $n$ 项。 假定从 $0$ 开始，第 $0$ 项为 $0$。 输入格式 共一行，包含两个整数 $n$ 和 $k$ 。 输出格式 共一行，表示斐波那契数列的第 $n$ 项。 数据范围 $0 \\le n \\le39$, 输入样例： 36 输出样例： 14930352 算法设计 如果只需要使用到相邻 $n$ 个状态的值，那么只需要开 $n$ 层数组即可，其中状态使用 $f(i\\ %\\ n)$ 来表示即可 完整 C++ 代码 #include \u003ciostream\u003e using namespace std; int dp[3]; int n; int main() { cin \u003e\u003e n; dp[1] = 1; for (int i = 2; i \u003c= n; i++) { dp[i % 3] = dp[(i - 1) % 3] + dp[(i - 2) % 3]; } cout \u003c\u003c dp[n % 3] \u003c\u003c endl; return 0; } ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:15:1","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"单链表 ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:16:0","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"AcWing 826. 单链表 题目描述 ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:16:1","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"826. 单链表 实现一个单链表，链表初始为空，支持三种操作： 向链表头插入一个数； 删除第 $k$ 个插入的数后面的一个数； 在第 $k$ 个插入的数后插入一个数。 现在要对该链表进行 $M$ 次操作，进行完所有操作后，从头到尾输出整个链表。 注意:题目中第 $k$ 个插入的数并不是指当前链表的第 $k$ 个数。例如操作过程中一共插入了 $n$ 个数，则按照插入的时间顺序，这 $n$ 个数依次为：第 $1$ 个插入的数，第 $2$ 个插入的数，…第 $n$ 个插入的数。 输入格式 第一行包含整数 $M$，表示操作次数。 接下来 $M$ 行，每行包含一个操作命令，操作命令可能为以下几种： H x，表示向链表头插入一个数 $x$。 D k，表示删除第 $k$ 个插入的数后面的数（当 $k$ 为 $0$ 时，表示删除头结点）。 I k x，表示在第 $k$ 个插入的数后面插入一个数 $x$（此操作中 $k$ 均大于 $0$）。 输出格式 共一行，将整个链表从头到尾输出。 数据范围 $1≤M≤100000$ 所有操作保证合法。 输入样例： 10 H 9 I 1 1 D 1 D 0 H 6 I 3 6 I 4 5 I 4 5 I 3 4 D 6 输出样例： 6 4 6 5 算法设计 这里引用单链表这个知识点肯定不是想直接用结构体定义的单链表。 因为使用结构体的方法，每次都需要 $\\text{new}$ 一个新的结构体，这个操作是非常耗时的，对于 $\\text{ACM}$ 这种每次都要操作 $100000$ 级别数据量的情况下是非常慢的。因为我们需要使用数组来模拟链表。 首先我们来明确模板中各个数组含义： $\\text{head}$：头节点。 $e_i$：节点 $i$ 的值。 $ne_i$：节点 $i$ 的 $\\text{next}$ 指针指向的节点。 $\\text{idx}$：存储当前已经用到了哪个点。 image-20241214233109357 完整 C++ 代码 #include \u003ciostream\u003e using namespace std; const int N = 100010; int m; int head, e[N], ne[N], idx; // 初始化 void init() { head = -1; // 下标-1表示为空 idx = 0; } // 头插法插入 void add_to_head(int x) { e[idx] = x, ne[idx] = head, head = idx ++; } // 在下标为 k 的数后面插入一个数 x void add(int k, int x) { e[idx] = x, ne[idx] = ne[k], ne[k] = idx ++; } // 在下标为 k 的数后面删掉一个数 void remove(int k) { ne[k] = ne[ne[k]]; } int main() { cin \u003e\u003e m; init(); while (m-- ) { char op; cin \u003e\u003e op; if (op == 'H') { int x; cin \u003e\u003e x; add_to_head(x); } else if (op == 'D') { int k; cin \u003e\u003e k; if (!k) head = ne[head]; remove(k - 1); } else { int k, x; cin \u003e\u003e k \u003e\u003e x; add(k - 1, x); } } for (int i = head; i != -1; i = ne[i]) cout \u003c\u003c e[i] \u003c\u003c \" \"; // 标准的遍历方式 return 0; } ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:16:2","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"单调栈 ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:17:0","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"AcWing 830. 单调栈 题目描述 ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:17:1","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"830. 单调栈 给定一个长度为 $N$ 的整数数列，输出每个数左边第一个比它小的数，如果不存在则输出 $\\text{−}1$。 输入格式 第一行包含整数 $N$，表示数列长度。 第二行包含 $N$ 个整数，表示整数数列。 输出格式 共一行，包含 $N$ 个整数，其中第 $i$ 个数表示第 $i$ 个数的左边第一个比它小的数，如果不存在则输出 $−1$。 数据范围 $1≤N≤10^5$ $1≤$数列中元素$≤10^9$ 输入样例： 5 3 4 2 7 5 输出样例： -1 3 -1 2 2 算法设计 这道题就是收录的就算单调栈的经典模板，单调栈一般只会用来解决这种求左边或者右边第一个比它大或小的数。 分析方法还是先思考暴力解法：用一个栈把所有数都存下来。 但是这种时间复杂度是 $O(n^2)$，太暴力了。 下面分析如何优化，也就是思考哪些状态其实不用存储，比如对于输入样例中的 $3,4,2$，我们记下一个数是 $a$： 若 $a \u003e= 2$，显然 $2$ 就是我们要找的值。 若 $a \u003c2$，此时 $3,4$ 显然也不是我们要的值。 显然对于 $3,4$ 来说，只要 $2$ 存在的一天，$3,4$ 也就永无出头之日。因此只需要往栈中压入 $2$ 即可。 对于上面的例子我们进行数学抽象，对于数列中的 $a_i$ 和 $a_{i+1}$，若 $a_i\u003e=a_{i+1}$ 我们只需要存一个 $a_{i+1}$ 即可，最终构成的栈一定是一个严格单调递增的栈，所以我们叫它单调栈。 完整 C++ 代码 #include \u003ciostream\u003e #include \u003ccstring\u003e #include \u003calgorithm\u003e #include \u003cstack\u003e using namespace std; const int N = 100010; int a[N], s[N]; int main() { int n; cin \u003e\u003e n; for (int i = 0; i \u003c n; i ++) cin \u003e\u003e a[i]; vector\u003cint\u003e left(n, -1); stack\u003cint\u003e stk; for (int i = 0; i \u003c n; i ++) { while (!stk.empty() \u0026\u0026 a[i] \u003c= a[stk.top()]) stk.pop(); // 因为需要维护一个严格单调递增的栈 if (!stk.empty()) left[i] = stk.top(); // 如果栈没空说明有 stk.push(i); } for (int i = 0; i \u003c n; i ++) { if (left[i] == -1) cout \u003c\u003c -1 \u003c\u003c ' '; else cout \u003c\u003c a[left[i]] \u003c\u003c ' '; } return 0; } ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:17:2","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"单调队列 ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:18:0","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"AcWing 154. 滑动窗口 题目描述 ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:18:1","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"154. 滑动窗口 给定一个大小为 $n≤10^6$ 的数组。 有一个大小为 $k$ 的滑动窗口，它从数组的最左边移动到最右边。 你只能在窗口中看到 $k$ 个数字。 每次滑动窗口向右移动一个位置。 以下是一个例子： 该数组为 [1 3 -1 -3 5 3 6 7]，$k$ 为 $3$。 窗口位置 最小值 最大值 [1 3 -1] -3 5 3 6 7 -1 3 1 [3 -1 -3] 5 3 6 7 -3 3 1 3 [-1 -3 5] 3 6 7 -3 5 1 3 -1 [-3 5 3] 6 7 -3 5 1 3 -1 -3 [5 3 6] 7 3 6 1 3 -1 -3 5 [3 6 7] 3 7 你的任务是确定滑动窗口位于每个位置时，窗口中的最大值和最小值。 输入格式 输入包含两行。 第一行包含两个整数 $n$ 和 $k$，分别代表数组长度和滑动窗口的长度。 第二行有 $n$ 个整数，代表数组的具体数值。 同行数据之间用空格隔开。 输出格式 输出包含两个。 第一行输出，从左至右，每个位置滑动窗口中的最小值。 第二行输出，从左至右，每个位置滑动窗口中的最大值。 输入样例： 8 3 1 3 -1 -3 5 3 6 7 输出样例： -1 -3 -3 -3 3 3 3 3 5 5 6 7 算法设计 单调队列一般只用来求解一段连续区间内的最大最小值。 我们来分析输入样例的第一个区间 $[1,3,\\text{-}1], \\text{-}3, 5, 3 ,6, 7$： 如果我们要求的是最小值，如果按照暴力做法，需要将 $1,3,\\text{-}1$ 全都都入队列，但是仔细分析就可以发现，显然 $\\text{-}1$ 的出栈时间比 $1,3$ 更晚，还比 $1,3$ 更小，只要 $\\text{-}1$ 在的一天，$1,3$ 就没有出头之日，所以只需要记录 $\\text{-}1$ 一个数就可以将 $1,3,\\text{-}1$ 所有情况给囊括了。 所以可以更进一步推导出：求最小值我们构造出的队列永远是严格单调递增的，所以叫它单调队列。 如果滑动我们的窗口，进入窗口的元素是 $a$，我们假设队列元素分别为 $q_0,q_1,…q_j$： 若 $a \\le q_j$，此时不满足队列严格单调递增，我们需要先将所有 $q_j \\ge a$ 的元素出队，直到找到一个 $i$ ，使得 $q_i\u003ca$，我们再将元素 $a$ 入队作为新的队尾。 若 $a\u003eq_j$，直接将元素 $a$ 入队作为新的队尾。 每次滑动后，队列的队头元素就是我们要求的每个区间的最小值。 代码模板如下： // 存储递减序列 deque\u003cint\u003e que; for (int i = 0; i \u003c n; i ++) { // 1.构造递减序列 while (!que.empty() \u0026\u0026 nums[i] \u003e= nums[que.back()]) que.pop_back(); // 2.入队 que.push_back(i); // 3.记录答案 if (i \u003e= k-1) ans.push_back(nums[que.front()]); // 4.判断队首有没有出队 if (que.front() \u003c= i-k+1) que.pop_front(); } 同理可以求最大值，这里我们就不再赘述。 完整 C++ 代码 #include \u003ciostream\u003e using namespace std; const int N = 1000010; int a[N], q[N]; int main() { int n, k; cin \u003e\u003e n \u003e\u003e k; for (int i = 0; i \u003c n; i++) cin \u003e\u003e a[i]; int hh = 0, tt = -1; for (int i = 0; i \u003c n; i++) { if (hh \u003c= tt \u0026\u0026 i - k == q[hh]) hh++; // 首先判断有没有要出队的 while (hh \u003c= tt \u0026\u0026 a[i] \u003c= a[q[tt]]) tt--; // 构造递增序列 q[++ tt] = i; // 这里我们存的是下标，因为上面要判断有没有要出队的 if (i \u003e= k - 1) cout \u003c\u003c a[q[hh]] \u003c\u003c \" \"; } cout \u003c\u003c endl; hh = 0, tt = -1; for (int i = 0; i \u003c n; i++) { if (hh \u003c= tt \u0026\u0026 i - k == q[hh]) hh++; while (hh \u003c= tt \u0026\u0026 a[i] \u003e= a[q[tt]]) tt--; // 求最大值只有这里和求最小值不一样 q[++ tt] = i; if (i \u003e= k - 1) cout \u003c\u003c a[q[hh]] \u003c\u003c \" \"; } return 0; } ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:18:2","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"KMP KMP：一个人能走的多远不在于他在顺境时能走的多快，而在于他在逆境时多久能找到曾经的自己 ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:19:0","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"AcWing 831. KMP字符串 题目描述 给定一个字符串 $S$，以及一个模式串 $P$，所有字符串中只包含大小写英文字母以及阿拉伯数字。 模式串 $P$ 在字符串 $S$ 中多次作为子串出现。 求出模式串 $P$ 在字符串 $S$ 中所有出现的位置的起始下标。 输入格式 第一行输入整数 $N$，表示模式串 $P$ 的长度。 第二行输入字符串 $P$。 第三行输入整数 $M$，表示字符串 $S$ 的长度。 第四行输入字符串 $S$。 输出格式 共一行，输出所有出现位置的起始下标（下标从 $0$ 开始计数），整数之间用空格隔开。 数据范围 $ 1≤N≤10^5 $ $ 1≤M≤10^6 $ 输入样例： 3 aba 5 ababa 输出样例： 0 2 算法设计 $next[i]本质:模式串前i个字符的最长的一对相等的前后缀size(＝该前缀末端index)[下标从1开始]$ $如$:\"$abab$\", $size$=$2$ $每次循环开始的时候,j都=ne[i - 1]，下面分两种情况来讨论：$ $①.if;;p_{i}=p_{j+1}$ $;;;;;;;;;; ne[i] \\gets ne[i - 1] + 1$ $②.if;;p_{i} \\ne p_{j+1}$ $;;;;;;;;;; j \\gets ne[j],再重新开始判断if;(p_{i}=p_{j+1})$ // 求next数组过程:其实就是求最大前后缀长度，通过仿造下面KMP匹配的过程来求,可以将暴力求的o(n^2)复杂度降至o(n) for (int i = 2, j = 0; i \u003c= n; i++) // 注意这里i得从2开始,因为默认ne[1]=0,如果这里i从1开始,很明显会导致ne[1]=1,最终代码会出现TLE { while (j != 0 \u0026\u0026 p[i] != p[j + 1]) j = ne[j]; // 只要j没有退回起点,并且p[i]和p[j+1]不匹配,就可以通过next数组更新j if (p[i] == p[j + 1]) j++; // 如果最终p[i]和p[j+1]相等,那么最长前后缀size就可以+1 ne[i] = j; // 最后更新一下ne[i] } $每一次将字符串的s[i]和模式串的p[j + 1]进行匹配$ // KMP匹配过程:将s[i]与p[j + 1]进行匹配[当然这里为什么用j+1就说来话长了,毕竟当不匹配的时候是要对该下标前面的进行转移，所以与其用j-1，不如用j+1也就方便不越界了] for (int i = 1, j = 0; i \u003c= m; i++) { while (j != 0 \u0026\u0026 s[i] != p[j + 1]) j = ne[j]; // 只要j没有退回起点,并且s[i]和p[j+1]不匹配,就可以通过next数组更新j if (s[i] == p[j + 1]) j++; // 因为上面的循环结束有两种情况，1.j退回起点退无可退了，2.s[i]和p[j+1]终于匹配上了 if (j == n) { cout \u003c\u003c i - n \u003c\u003c \" \"; // 匹配成功,这里是根据题目要求的输出所有出现位置的起始下标（下标从0开始计数） j = ne[j]; // 此时依旧使用next数组来更新使得省去已知匹配的前后缀 } } $ \\text{KMP} 算法可以视作状态机模型:基于字符串p的\\text{KMP}自动机接受且仅接受以p为后缀的字符串，其接受状态为|p|。 $ $转移函数:$ $$ne(i, c) = \\begin{cases} i + 1, \u0026 \\text{if } p[i+1] = c \\ 0, \u0026 \\text{if } p[1] \\neq c \\land i = 0 \\ ne(\\pi(i), c), \u0026 \\text{if } p[i+1] \\neq c \\land i \u003e 0 \\end{cases}$$ 时间复杂度 $O(n+m)$ 完整 C++ 代码 #include \u003ciostream\u003e #include \u003ccstring\u003e using namespace std; const int N = 100010, M = 1000010; char p[N], s[M]; // pattern:模式串 int ne[N]; // next数组 int main() { int n, m; cin \u003e\u003e n \u003e\u003e p + 1 \u003e\u003e m \u003e\u003e s + 1; // 求next数组过程:其实就是求最大前后缀长度，通过仿造下面KMP匹配的过程来求,可以将暴力求的o(n^2)复杂度降至o(n) for (int i = 2, j = 0; i \u003c= n; i++) // 注意这里i得从2开始,因为默认ne[1]=0,如果这里i从1开始,很明显会导致ne[1]=1,最终代码会出现TLE { while (j != 0 \u0026\u0026 p[i] != p[j + 1]) j = ne[j]; // 只要j没有退回起点,并且p[i]和p[j+1]不匹配,就可以通过next数组更新j if (p[i] == p[j + 1]) j++; // 如果最终p[i]和p[j+1]相等,那么最长前后缀size就可以+1 ne[i] = j; // 最后更新一下ne[i] } // KMP匹配过程:将s[i]与p[j + 1]进行匹配[当然这里为什么用j+1就说来话长了,毕竟当不匹配的时候是要对该下标前面的进行转移，所以与其用j-1，不如用j+1也就方便不越界了] for (int i = 1, j = 0; i \u003c= m; i++) { while (j != 0 \u0026\u0026 s[i] != p[j + 1]) j = ne[j]; // 只要j没有退回起点,并且s[i]和p[j+1]不匹配,就可以通过next数组更新j if (s[i] == p[j + 1]) j++; // 因为上面的循环结束有两种情况，1.j退回起点退无可退了，2.s[i]和p[j+1]终于匹配上了 if (j == n) { cout \u003c\u003c i - n \u003c\u003c \" \"; // 匹配成功,这里是根据题目要求的输出所有出现位置的起始下标（下标从0开始计数） j = ne[j]; // 此时依旧使用next数组来更新使得省去已知匹配的前后缀 } } } ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:19:1","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"字典树 ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:20:0","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"AcWing 835. Trie字符串统计 题目描述 ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:20:1","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"835. Trie字符串统计 维护一个字符串集合，支持两种操作： I x 向集合中插入一个字符串 $x$； Q x 询问一个字符串在集合中出现了多少次。 共有 $N$ 个操作，所有输入的字符串总长度不超过 $10^5$，字符串仅包含小写英文字母。 输入格式 第一行包含整数 $N$，表示操作数。 接下来 $N$ 行，每行包含一个操作指令，指令为 I x 或 Q x 中的一种。 输出格式 对于每个询问指令 Q x，都要输出一个整数作为结果，表示 $x$ 在集合中出现的次数。 每个结果占一行。 数据范围 $1≤N≤2\\times 10^4$ 输入样例： 5 I abc Q abc Q ab I ab Q ab 输出样例： 1 0 1 算法设计 突然灵光一闪，好像本题给人一种 $\\text{Trie}$ 能做到的 $\\text{hash}$ 好像也能做到，但是其实 $\\text{Trie}$ 更宝贵的是,它存储了一个前缀匹配，比如在需要做到查询前缀为XXX的所有字符串的时候 $\\text{hash}$就束手无策了 字典树，英文名 $\\text{Trie}$。顾名思义，就是一个像字典一样的树，是一种可以快速插入和查询字符串的多叉树结构。 大家都知道一种数据结构设计的出现往往是为了解决特定的一类问题，$\\text{Trie}$ 的最基础的应用就是查找一个字符串是否在字典中出现过。暴力的做法的时间复杂度与字典大小成正比，但是字典树可以做到只与字符串长度有关，虽然比较废空间。 下面我们来明确模板中各个数组含义： $ne[p][c]$：存储从节点 $p$ 沿着 $c$ 这条边走到的子节点，边 $c$ 由 $26$ 个字母构成，所以每个节点最多有 $26$ 个子节点。 $cnt[p]$：以节点 $p$ 结尾的单词的插入次数。 $idx$：节点编号，存储当前已经用到了哪个点。 数组版本模板如下(速度更快)： const int N = 100010; struct Trie { int ne[N][26], cnt[N], idx; // 下标为0的节点用作根节点,如果ne[i][j]=0就表示没有子节点 Trie() { // 构造函数：这里需要全部初始话，不然可能力扣用例很奇怪过不了 memset(ne, 0, sizeof(ne)); memset(cnt, 0, sizeof(cnt)); idx = 0; } void insert(char* s) { int p = 0; // 从根节点开始走 for (int i = 0; i \u003c strlen(s); i ++) { int c = s[i] - 'a'; // 判断往哪走 if (!ne[p][c]) ne[p][c] = ++ idx; // 如果没有节点就新增节点 p = ne[p][c]; // 更新p节点 } cnt[p] ++; } int query(char* s) { int p = 0; // 从根节点开始走 for (int i = 0; i \u003c strlen(s); i ++) { int c = s[i] - 'a'; // 判断往哪走 if (!ne[p][c]) return 0; // 如果没有节点就停止 p = ne[p][c]; // 更新p节点 } return cnt[p]; } }; 链表版本： struct Trie { struct Node { Node* next[26] = {}; // 显式初始化为 nullptr int cnt = 0; }; Node* root = new Node(); void insert(string word) { int n = word.size(); Node* cur = root; for (int i = 0; i \u003c n; i ++) { if (cur-\u003enext[word[i] - 'a']) { Node* tmp = new Node(); cur-\u003enext[word[i] - 'a'] = tmp; } cur = cur-\u003enext[word[i] - 'a']; } cur-\u003ecnt ++; } bool search(string word) { int n = word.size(); Node* cur = root; for (int i = 0; i \u003c n; i ++) { if (cur-\u003enext[word[i] - 'a'] == nullptr) return false; cur = cur-\u003enext[word[i] - 'a']; } return cur-\u003ecnt \u003e 0; } bool startsWith(string prefix) { int n = prefix.size(); Node* cur = root; for (int i = 0; i \u003c n; i ++) { if (cur-\u003enext[prefix[i] - 'a'] == NULL) return false; cur = cur-\u003enext[prefix[i] - 'a']; } return true; } }; 完整 C++ 代码 #include \u003ciostream\u003e #include \u003ccstring\u003e using namespace std; const int N = 100010; // 所有输入的字符串总长度不超过10^5 char s[N]; struct Trie { int ne[N][26], cnt[N], idx; // 下标为0的节点用作根节点,如果ne[i][j]=0就表示没有子节点 Trie() { // 构造函数：这里需要全部初始话，不然可能力扣用例很奇怪过不了 memset(ne, 0, sizeof(ne)); memset(cnt, 0, sizeof(cnt)); idx = 0; } void insert(char* s) { int p = 0; // 从根节点开始走 for (int i = 0; i \u003c strlen(s); i ++) { int c = s[i] - 'a'; // 判断往哪走 if (!ne[p][c]) ne[p][c] = ++ idx; // 如果没有节点就新增节点 p = ne[p][c]; // 更新p节点 } cnt[p] ++; } int query(char* s) { int p = 0; // 从根节点开始走 for (int i = 0; i \u003c strlen(s); i ++) { int c = s[i] - 'a'; // 判断往哪走 if (!ne[p][c]) return 0; // 如果没有节点就停止 p = ne[p][c]; // 更新p节点 } return cnt[p]; } }; int main() { Trie t; // 创建trie对象 int n; cin \u003e\u003e n; while (n--) { char op; cin \u003e\u003e op \u003e\u003e s; if (op == 'I') t.insert(s); // 调用结构体的插入方法 else cout \u003c\u003c t.query(s) \u003c\u003c endl; // 调用结构体的查询方法 } return 0; } ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:20:2","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"并查集 ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:21:0","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"堆 ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:22:0","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"AcWing 839. 模拟堆 题目描述 ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:22:1","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"839. 模拟堆 维护一个集合，初始时集合为空，支持如下几种操作： I x，插入一个数 $x$； PM，输出当前集合中的最小值； DM，删除当前集合中的最小值（数据保证此时的最小值唯一）； D k，删除第 $k$ 个插入的数； C k x，修改第 $k$ 个插入的数，将其变为 $x$； 现在要进行 $N$ 次操作，对于所有第 $2$ 个操作，输出当前集合的最小值。 输入格式 第一行包含整数 $N$。 接下来 $N$ 行，每行包含一个操作指令，操作指令为 I x，PM，DM，D k 或 C k x 中的一种。 输出格式 对于每个输出指令 PM，输出一个结果，表示当前集合中的最小值。 每个结果占一行。 数据范围 $1≤N≤10^5$ $−10^9≤x≤10^9$ 数据保证合法。 输入样例： 8 I -10 PM I -10 D 1 C 2 8 I 6 PM DM 输出样例： -10 6 算法设计 堆是一棵完全二叉树的结构，下面我们以小根堆为例来分析如何用数组手写一个堆。 这里我们的数组下标从 $1$，这样节点 $i$ 的左孩子就是 $2i$，右孩子就是 $2i+1$。 小根堆需要满足的性质是每个点都小于它的左右孩子。 堆有两个基本方法：down(u)和up(u)： down(u)：将一个点往下移动到合适的位置，通过把一个点和他的左右孩子比较，然后和他最小的孩子，然后递归处理 up(u)：将一个点向上移动到合适的位置，通过把一个点和他的父节点比较，如果小于父节点就交换，然后递归处理 我们需要用这两个基本方法来实现以下堆的常用操作： push(x)：插入一个元素，把元素插到数组末尾，然后up(size)就行。 top()：返回当前堆中的最小值，就是heap[1]。 pop()：删除最小值，这里因为数组头部下标不能动，所以需要将数组末尾元素放到数组头，然后down(1)就行。 remove(u)：删除第 $u$ 个插入的元素，故技重施，为了维护数组下标的连续，不能直接删掉这个元素，而是需要将数组末尾元素放到这里，如果这里交换后变小了，还需要up(u)，如果变大了还需要down(u)。当然这里更复杂的是需要用一个数组来记录下第 $u$ 个插入的元素现在在哪里，因为up(u)和down(u)会交换元素顺序。 modify(u, x)：修改第 $u$ 个插入的元素， 如果这里修改后元素值变小了，还需要up(u)，如果变大了还需要down(u)。同理也需要记录。 注：由于 $4,5$ 两个操作需要记录第 $u$ 个插入的元素现在在哪，所以我们需要用两个映射数组 $ph_i$ 和 $hp_j$，来记录元素位置，$ph_i$ 存的是映射数组中第 $i$ 个元素现在在堆中位置下标，$hp_j$ 存的是堆中第 $j$ 个元素在映射数组中的位置下标。为什么需要两个映射数组呢，这其实就是因为我们要交换堆中的两个元素，需要知道这两个元素在映射数组中的下标，这样才能同步去更新映射数组，这时候为了速度就需要再存一个堆到映射数组的映射。 所以我们下面给出两个模板，第一个模板只实现了前三个操作，很简单，日常基本就够用了，虽然 $\\text{STL}$ 提供的版本就是这个版本。第二个模板实现了全部五个操作，但是更复杂，但是在后面学到优化 $\\text{Dijkstra}$ 的时候会用到。 下面我们有一个巧妙的建堆方式，可以将时间复杂度从将每一个数插入到堆中的 $O(nlogn)$ 降低到 $O(n)$。 只需要对数据从 $\\frac{n}{2}$ 往前进行 down(i)操作即可：for (int i = n \u003e\u003e 1; i \u003e 0; i --) down(i); 下面我们对这个建堆方式的时间复杂度进行证明： 对于这个堆来说，是一颗完全二叉树的结构，最后一层我们无需调整，因为已经是叶子节点了，我们只需要逐层向上做down(u)操作进行调整即可。 那么对于倒数第二层来说有 $\\frac{n}{4}$ 个节点，down(u)操作的时间复杂度是和高度有关，因此需要时间可以计为 $\\frac{n}{4} \\times 1$。同理对于倒数第三层来说，时间可以计为 $\\frac {n} {8} \\times 2$。 所以总共时间可以写为： $$ t = \\frac{n}{4}\\times1 + \\frac{n}{8}\\times2 + \\frac{n}{16}\\times3 + \\dots = n\\times(\\frac{1}{2^2} + \\frac{2}{2^3} + \\frac{3}{2^4} + \\dots) $$ 显然这是高中常见的等差乘等比的数列形式，只需要使用错位相减即可得到 $t\\approx n$，证毕。 下面我们给出普通版本小根堆的结构体模板以及实现了随机修改删除版本的堆的结构体模板 // 普通版本小根堆结构体模板 struct Heap { int h[100010], size; Heap() { memset(h, 0, sizeof h); size = 0; } void up(int u) { while (u \u003e\u003e 1 \u003e 0 \u0026\u0026 h[u] \u003c h[u \u003e\u003e 1]) { swap(h[u], h[u \u003e\u003e 1]); u = u \u003e\u003e 1; } } void down(int u) { // 找三个数最小值 int t = u; // 存的最小值编号 if (u * 2 \u003c= size \u0026\u0026 h[u * 2] \u003c h[t]) t = u * 2; if (u * 2 + 1 \u003c= size \u0026\u0026 h[u * 2 + 1] \u003c h[t]) t = u * 2 + 1; if (t != u) { swap(h[u], h[t]); down(t); // 继续递归处理 } } // 优化后的建队代码：时间复杂度是O(n),注意：传入的数组要从下标0开始 void build(int a[], int n) { copy(a, a + n, h + 1); size = n; for (int i = n \u003e\u003e 1; i \u003e 0; i --) down(i); } void push(int x) { h[++ size] = x; up(size); } int top() { return h[1]; } void pop() { h[1] = h[size --]; down(1); } }; // 支持随机修改删除版本的堆的结构体模板 struct Heap { int h[100010], ph[100010], hp[100010], size_h, size_ph; // ph,hp是映射数组 Heap() { memset(h, 0, sizeof h); memset(ph, 0, sizeof ph); memset(hp, 0, sizeof hp); size_h = 0, size_ph = 0; } // 同步映射交换 void heap_swap(int i, int j) { swap(h[i], h[j]); swap(ph[hp[i]], ph[hp[j]]); swap(hp[i], hp[j]); } void up(int u) { while (u \u003e\u003e 1 \u003e 0 \u0026\u0026 h[u] \u003c h[u \u003e\u003e 1]) { heap_swap(u, u \u003e\u003e 1); u = u \u003e\u003e 1; } } void down(int u) { // 找三个数最小值 int t = u; // 存的最小值编号 if (u * 2 \u003c= size_h \u0026\u0026 h[u * 2] \u003c h[t]) t = u * 2; if (u * 2 + 1 \u003c= size_h \u0026\u0026 h[u * 2 + 1] \u003c h[t]) t = u * 2 + 1; if (t != u) { heap_swap(u, t); down(t); // 继续递归处理 } } // 优化后的建队代码：时间复杂度是O(n),注意：传入的数组要从下标0开始 void build(int a[], int n) { copy(a, a + n, h + 1); for (int i = 1; i \u003c= n; i ++) ph[i] = hp[i] = i; size_h = n, size_ph = n; for (int i = n \u003e\u003e 1; i \u003e 0; i --) down(i); } void push(int x) { h[++ size_h] = x; ph[++ size_ph] = size_h; hp[size_h] = size_ph; up(size_h); } int top() { return h[1]; } void pop() { heap_swap(1, size_h --); down(1); } // 删除第u个插入的元素 void remove(int u) { u = ph[u]; heap_swap(u, size_h --); // !!! 这里直接写成heap_swap(ph[u], size_h --),up(ph[u]), down(ph[u]);是错误的，因为ph[u]的值会变在heap_swap之后 up(u), down(u); // 本来是需要判断交换后变大还是变小来判断需要什么操作，我们这里为了简单直接两个都做了,最多只会执行其中一个 } // 修改第u个插入的元素 void modify(int u, int x) { u = ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:22:2","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"树状数组 线段树能解决超多有关区间的问题，还有一些不这么明显的区间问题（废话）。像什么单点修改，单点查询，区间修改，区间查询都不在话下，应用范围比树状数组广，变通性极强（树状数组能解决的问题线段树都能解决，但是后者能解决的一些问题树状数组还是搞不了的，但是树状数组时空常数小，代码量少，还不容易写错）。 所以直接学线段树了（乐） ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:23:0","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"线段树 ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:24:0","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"AcWing 1275. 最大数 题目描述 ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:24:1","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"1275. 最大数 给定一个正整数数列 $a_1,a_2,…,a_n$，每一个数都在 $0∼p−1$ 之间。 可以对这列数进行两种操作： 添加操作：向序列后添加一个数，序列长度变成 $n+1$； 询问操作：询问这个序列中最后 $L$ 个数中最大的数是多少。 程序运行的最开始，整数序列为空。 一共要对整数序列进行 $m$ 次操作。 写一个程序，读入操作的序列，并输出询问操作的答案。 输入格式 第一行有两个正整数 $m,p$，意义如题目描述； 接下来 $m$ 行，每一行表示一个操作。 如果该行的内容是 Q L，则表示这个操作是询问序列中最后 $L$ 个数的最大数是多少； 如果是 A t，则表示向序列后面加一个数，加入的数是 $(t+a)\\ \\text{mod}\\ p$。其中，$t$ 是输入的参数，$a$ 是在这个添加操作之前最后一个询问操作的答案（如果之前没有询问操作，则 $a=0$）。 第一个操作一定是添加操作。对于询问操作，$L\u003e0$ 且不超过当前序列的长度。 输出格式 对于每一个询问操作，输出一行。该行只有一个数，即序列中最后 $L$ 个数的最大数。 数据范围 $1≤m≤2×10^5,$ $1≤p≤2×10^9,$ $0≤t\u003cp$ 输入样例： 10 100 A 97 Q 1 Q 1 A 17 Q 2 A 63 Q 1 Q 1 Q 3 A 99 输出样例： 97 97 97 60 60 97 样例解释 最后的序列是 $97,14,60,96$。 算法设计 我们收录的这题是线段树的模板题，是想引入线段树的各种操作。 pushup()：用子节点信息更新父节点信息 build()：将一段区间初始化成线段树 modify()：修改；如果修改的是单点，那很简单无需懒标记；如果修改的是区间，那就需要pushdown()操作，非常复杂 query()：查询某一段区间信息 pushdown()：需要使用懒标记，很复杂 我们来详细分析一下query(l,r)会遇到的情况，记当前递归到的区间为 $[T_l,T_r]$： 若 $[T_l,T_r] \\subseteq [l,r]$，直接返回即可。 若 $[T_l,T_r] \\cap [l,r] \\ne \\varnothing$，递归遍历和 $[l,r]$ 又交集的左子区间或又子区间。 若 $[T_l,T_r] \\cap [l,r] = \\varnothing$，由上面两步可知，不会碰到这种情况的，所以这种情况其实不存在。 可以证明只需要 $O(logn)$ 的时间就可以查询结束，这里就留给大家自己去证明。 下面我们给出线段树结构体模板： // 只支持区间单点修改的无懒标记版本的线段树结构体模板 struct SegmentTree { struct Node { int l, r; int v; // 根据问题去确定value的含义 } tr[4 * 200010]; // 需要开4倍区间大小的空间 SegmentTree() // 结构体初始化 { memset(tr, 0, sizeof tr); } void pushup(int u) // 由子节点信息更新父节点信息 { tr[u].v = max(tr[u * 2].v, tr[u * 2 + 1].v); // 根据题意去调整更新策略 } void build(int u, int l, int r) { tr[u] = {l, r}; if (l == r) return; int mid = l + r \u003e\u003e 1; build(u * 2, l, mid), build(u * 2 + 1, mid + 1, r); // 递归建左右孩子 } int query(int u, int l, int r) { if (tr[u].l \u003e= l \u0026\u0026 tr[u].r \u003c= r) return tr[u].v; // 全包含的情况 int mid = tr[u].l + tr[u].r \u003e\u003e 1; int res = 0; if (l \u003c= mid) res = max(res, query(u * 2, l, r)); if (r \u003e= mid + 1) res = max(res, query(u * 2 + 1, l, r)); return res; } void modify(int u, int k, int v) { if (tr[u].l == k \u0026\u0026 tr[u].r == k) tr[u].v = v; else { int mid = tr[u].l + tr[u].r \u003e\u003e 1; if (k \u003c= mid) modify(u * 2, k, v); else modify(u * 2 + 1, k, v); pushup(u); } } }; 来不及更新支持区间修改的有懒标记版本的线段树结构体模板，因为今天是一年的ddl了 ——2024.12.31 23:05 完整 C++ 代码 #include \u003ciostream\u003e #include \u003ccstring\u003e #include \u003calgorithm\u003e using namespace std; // 只支持区间单点修改的无懒标记版本的线段树结构体模板 struct SegmentTree { struct Node { int l, r; int v; // 根据问题去确定value的含义 } tr[4 * 200010]; // 需要开4倍区间大小的空间 SegmentTree() // 结构体初始化 { memset(tr, 0, sizeof tr); } void pushup(int u) // 由子节点信息更新父节点信息 { tr[u].v = max(tr[u * 2].v, tr[u * 2 + 1].v); // 根据题意去调整更新策略 } void build(int u, int l, int r) { tr[u] = {l, r}; if (l == r) return; int mid = l + r \u003e\u003e 1; build(u * 2, l, mid), build(u * 2 + 1, mid + 1, r); // 递归建左右孩子 } int query(int u, int l, int r) { if (tr[u].l \u003e= l \u0026\u0026 tr[u].r \u003c= r) return tr[u].v; // 全包含的情况 int mid = tr[u].l + tr[u].r \u003e\u003e 1; int res = 0; if (l \u003c= mid) res = max(res, query(u * 2, l, r)); if (r \u003e= mid + 1) res = max(res, query(u * 2 + 1, l, r)); return res; } void modify(int u, int k, int v) { if (tr[u].l == k \u0026\u0026 tr[u].r == k) tr[u].v = v; else { int mid = tr[u].l + tr[u].r \u003e\u003e 1; if (k \u003c= mid) modify(u * 2, k, v); else modify(u * 2 + 1, k, v); pushup(u); } } }; int main() { int n = 0, last = 0; int m, p; cin \u003e\u003e m \u003e\u003e p; SegmentTree segmentTree; segmentTree.build(1, 1, m); while (m --) { char op[2]; int L, t; cin \u003e\u003e op; if (!strcmp(op, \"Q\")) cin \u003e\u003e L, last = segmentTree.query(1, n - L + 1, n), cout \u003c\u003c last \u003c\u003c endl; else cin \u003e\u003e t, segmentTree.modify(1, ++ n, ((long long)t + last) % p); } return 0; } ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:24:2","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"平衡树 ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:25:0","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"AC自动机 ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:26:0","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"Dancing Links 第三章 搜索与图论 ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:27:0","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"DFS ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:28:0","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"AcWing 843. n-皇后问题 题目描述 ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:28:1","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"843. n-皇后问题 $n$-皇后问题是指将 $n$ 个皇后放在 $n×n$ 的国际象棋棋盘上，使得皇后不能相互攻击到，即任意两个皇后都不能处于同一行、同一列或同一斜线上。 1_597ec77c49-8-queens.png 现在给定整数 $n$，请你输出所有的满足条件的棋子摆法。 输入格式 共一行，包含整数 $n$。 输出格式 每个解决方案占 $n$ 行，每行输出一个长度为 $n$ 的字符串，用来表示完整的棋盘状态。 其中 . 表示某一个位置的方格状态为空，Q 表示某一个位置的方格上摆着皇后。 每个方案输出完成后，输出一个空行。 注意：行末不能有多余空格。 输出方案的顺序任意，只要不重复且没有遗漏即可。 数据范围 $1≤n≤9$ 输入样例： 4 输出样例： .Q.. ...Q Q... ..Q. ..Q. Q... ...Q .Q.. 算法设计 首先我们来比较一下深度优先搜索和广度优先搜索这两种方式： 数据结构 空间 性质 $\\text{DFS}$ $\\text{Stack}$ 递归耗空间 无“最短路” $\\text{BFS}$ $\\text{Queue}$ 迭代省空间 “最短路\"性质 这题是一道 $\\text{DFS}$ 的经典模板题。 $\\text{DFS}$ 有两步关键点：回溯，剪枝。 回溯其实就是 $\\text{DFS}$ 的本身的一个特性，因为它每次都是先访问到搜索树的叶节点，然后返回再访问上一层节点，所以这就是一步回溯的操作，回溯需要恢复现场。 剪枝说的就是 $\\text{DFS}$ 又名暴搜，其实本质上就是把每一种可能性都枚举了，但是在我们探索的过程中，其实就可以进行判断，如果可以确定这条路走不通，也就无需访问这条路径的叶子节点，可以减少很多时间，也被称为剪去搜索树的整个分枝。 同时由于每个点只能被走一次，所以无论是 $\\text{DFS}$ 还是 $\\text{BFS}$，我们基本都要开一个 $\\text{bool}$ 类型的 $st$ 数组来存储哪些点已经被我们走过了。 有了上面的一些基础知识，下面我们来分析这道题： 此题 $\\text{DFS}$ 在探索时中传入的 $u$ 是当前处理的行号，因为每行只会放置一个皇后，因此就无需再开一个 $\\text{row[N]}$ 来记录行信息，而这里对于放置的每个皇后后记录它所在正对角线和反对角线的方法很特殊。 我们可以使用编程坐标系来求解，也即行方向为 $x$ 方向，列方向为 $y$ 方向，所以此时我们传入的 $u$ 即 $x$ 坐标，$i$ 也就是 $y$ 坐标。 所以对于放置的每一个皇后，经过它的正对角线方程为 $y=x+b_1$，反对角线方程为 $y = -x + b_2$，所以 $\\begin{cases} b_1 = y-x \\ b_2 = y+x \\end{cases} $ 故我们只需要记录一下所谓的每次放置的皇后所在对角线的 $b_1$ 点和 $b_2$ 点即可。 不过这里还有一个小细节，我们在计算$b_1=y-x$ 时，会有时候算出负值来，但是我们的数组下标不能有负值，所以这里我们直接记录 $b_1+n$ 即可保证合法，同时我们这里的正负对角线数组要开成 $2N$ 大小才能正确。 所以最终我们记录的是 $\\begin{cases} b_1+n = y-x+n \\ b_2 = y+x \\end{cases} $ 完整 C++ 代码 #include \u003ciostream\u003e using namespace std; const int N = 10, M = 2 * N; int n; char g[N][N]; bool col[N], dg[M], udg[M]; // col：记录列情况，dg：正对角线，udg：反对角线 // dfs和bfs基本都要开一个bool数组用来标记走过哪些点，因为 void dfs(int u) { if (u == n) { for (int i = 0; i \u003c n; i++) cout \u003c\u003c g[i] \u003c\u003c endl; cout \u003c\u003c endl; return; } for (int i = 0; i \u003c n; i ++) { if (!col[i] \u0026\u0026 !dg[i - u + n] \u0026\u0026 !udg[i + u]) // 剪枝 { g[u][i] = 'Q'; col[i] = dg[i - u + n] = udg[i + u] = true; dfs(u + 1); col[i] = dg[i - u + n] = udg[i + u] = false; // 回溯：恢复现场 g[u][i] = '.'; } } } int main() { cin \u003e\u003e n; for (int i = 0; i \u003c n; i ++) for (int j = 0; j \u003c n; j ++) g[i][j] = '.'; dfs(0); return 0; } ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:28:2","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"AcWing 165. 小猫爬山 题目描述 ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:28:3","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"165. 小猫爬山 翰翰和达达饲养了 $N$ 只小猫，这天，小猫们要去爬山。 经历了千辛万苦，小猫们终于爬上了山顶，但是疲倦的它们再也不想徒步走下山了（呜咕\u003e_\u003c）。 翰翰和达达只好花钱让它们坐索道下山。 索道上的缆车最大承重量为 $W$，而 $N$ 只小猫的重量分别是 $C_1、C_2…C_N$。 当然，每辆缆车上的小猫的重量之和不能超过 $W$。 每租用一辆缆车，翰翰和达达就要付 $1$ 美元，所以他们想知道，最少需要付多少美元才能把这 $N$ 只小猫都运送下山？ 输入格式 第 $1$ 行：包含两个用空格隔开的整数，$N$ 和 $W$。 第 $2∼N+1$ 行：每行一个整数，其中第 $i+1$ 行的整数表示第 $i$ 只小猫的重量 $C_i$。 输出格式 输出一个整数，表示最少需要多少美元，也就是最少需要多少辆缆车。 数据范围 $1≤N≤18$, $1≤C_i≤W≤10^8$ 输入样例： 5 1996 1 2 1994 12 29 输出样例： 2 算法设计 这是收录的算法提高课的一道经典题目，比起刚刚的一道 $\\text{DFS}$ 的算法思想要更复杂，因为需要更加细化剪枝的策略。 $\\text{DFS}$ 的题目一般的剪枝模型有以下 $5$ 方面： 优化搜索顺序 首先如果不使用剪枝，那么无论搜索顺序如何，结果都是一样的 但是当有剪枝操作存在的时候，就会存在以下结论：在大部分情况，我们应该优先搜索分支较少的节点。 排除等效冗余 也即尽量少重复搜索。如果不考虑顺序，尽量使用组合枚举的方式来搜索 可行性剪枝 如果在搜索的过程中就发现不合法，就可以提前退出了 最优性剪枝 如果在搜索的过程中发现无论如何都会比当前已经搜到的最优解差，就可以提前退出了 记忆化搜索($\\text{DP}$) 详细请看第五章记忆化搜索章节 下面我们来分析这道题： 注：此题不优化搜索顺序会 $\\text{TLE}$。 我们从上面的剪枝模型入手： 优化搜索顺序✔：我们首先把最重的猫放进某辆车里面，那么后续还能放进这辆车的猫的情况自然就少了 排除等效冗余✔：使用了组合型枚举的方式 可行性剪枝✔：我们发现放猫进某辆车就超重了，自然就不合法可以提前退出了 最优性剪枝✔：我们发现当前这种情况需要的车已经比已经搜到的最优解多了，就可以提前退出了 记忆化搜索($\\text{DP}$)✖：主要在 $\\text{DP}$ 里面用的比较多，这里没用到 完整 C++ 代码 #include \u003ciostream\u003e #include \u003ccstring\u003e #include \u003calgorithm\u003e using namespace std; const int N = 20; int n, v; int w[N], s[N]; int ans = N; // 最坏情况每只猫一辆车 void dfs(int u, int k) // 第u只猫，当前的车的数量是k { // 4.最优性剪枝 if (k \u003e= ans) return; if (u == n) { ans = k; return; } for (int i = 0; i \u003c k; i ++) // 枚举放哪辆车上 { // 3.可行性剪枝 if (s[i] + w[u] \u003c= v) { s[i] += w[u]; dfs(u + 1, k); s[i] -= w[u]; // 恢复现场 } } s[k] = w[u]; // 新开一辆车来 dfs(u + 1, k + 1); s[k] = 0; // 恢复现场 } int main() { cin \u003e\u003e n \u003e\u003e v; for (int i = 0; i \u003c n; i ++) cin \u003e\u003e w[i]; // 1.优化搜索顺序 sort(w, w + n); reverse(w, w + n); dfs(0, 0); cout \u003c\u003c ans \u003c\u003c endl; return 0; } ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:28:4","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"BFS vector\u003cvector\u003cint\u003e\u003e levelOrder(TreeNode* root) { //use queue (non-recursion) vector\u003cvector\u003cint\u003e\u003e result; queue\u003cTreeNode*\u003e que; if(root) que.push(root); while(!que.empty()) { //Note: the Size is key int size = que.size(); vector\u003cint\u003e temp; while(size --) { TreeNode* cur = que.front(); temp.push_back(cur-\u003eval); que.pop(); if(cur-\u003eleft) que.push(cur-\u003eleft); if(cur-\u003eright) que.push(cur-\u003eright); } result.push_back(temp); } return result; } ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:29:0","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"树与图 ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:30:0","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"AcWing 846. 树的重心 题目描述 ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:30:1","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"846. 树的重心 给定一颗树，树中包含 $n$ 个结点（编号 $1∼n$）和 $n−1$ 条无向边。 请你找到树的重心，并输出将重心删除后，剩余各个连通块中点数的最大值。 重心定义：重心是指树中的一个结点，如果将这个点删除后，剩余各个连通块中点数的最大值最小，那么这个节点被称为树的重心。 输入格式 第一行包含整数 $n$，表示树的结点数。 接下来 $n−1$ 行，每行包含两个整数 $a$ 和 $b$，表示点 $a$ 和点 $b$ 之间存在一条边。 输出格式 输出一个整数 $m$，表示将重心删除后，剩余各个连通块中点数的最大值。 数据范围 $1≤n≤10^5$ 输入样例 9 1 2 1 7 1 4 2 8 2 5 4 3 3 9 4 6 输出样例： 4 算法设计 这里插一个知乎回答： 至于ACwing的课程质量，虽然有一些答主在批评，但实际上我给学弟学妹选资料的时候看过，总体还是不错的。基本上每道题和知识点都论证和解释的很细，而且现场手打代码AC我觉得挺好的。虽然题都是经典板子题，但是个人认为对初学者是必要的学习经过，不算缺点。我讨厌的问题就是不愿意用STL，存图还要用链式前向星。都什么时代了，没必要吧。 链式前向星快1.5倍，但是debug起来更麻烦。1.5的常数在acm里一般可以忽略。现在都开O2优化了，用vector更方便 所以好像y总这种写法没有太大必要（乐） 由于树是一种特殊的图，而无向边的图相当于画有两条有向边的图，所以我们只需要抽象出有向图的模板即可解决树和图的基本问题。 有向图一般有邻接矩阵和邻接表两种存储方式。 由于邻接矩阵对于稀疏图的效果不是很好，因此在 ACM 中我们一般不会使用，而是改用邻接表来存储。 首先我们来明确模板中各个数组含义： $h_i$：指向第 $i$ 个链表的头节点。 $e_i$：存储节点 $i$ 的值。 $ne_i$：存储节点 $i$ 的 $\\text{next}$ 指针指向的节点。 $\\text{idx}$：存储当前已经用到了哪个点。 $\\text{st}$：记录搜索过程中已经走过哪些点了，因为这里把无向边替换成两条有向边，如果不记录就会回头，造成死循环。 这里的定义其实就和第二章单链表给出的模板基本一样，只是单链表只有一个头我们直接用 $\\text{head}$ 就可以了，这里有多个头所以我们使用 $h$ 数组来表示某个头节点。 下面我们给出有向图的 $\\text{DFS}$ 的代码框架： const int N = 100010, M = N * 2; int h[N], e[M], ne[M], idx; bool st[N]; // dfs和bfs基本都要开一个bool数组用来标记走过哪些点，因为每个点只能被遍历一次 // 插入一条 a-\u003eb 的边 void add(int a, int b) { e[idx] = b, ne[idx] = h[a], h[a] = idx ++; } void dfs(int u) { st[u] = true; // 标记一下该点已经被走过了 for (int i = h[u]; i != -1; i = ne[i]) // 和遍历单链表是一模一样的 { int j = e[i]; if (!st[j]) dfs(j); } } int main() { memset(h, -1, sizeof h); // 仿造链表初始化，将所以h都初始化为-1 } 这里我们给出更易于理解和好写的vector版本，速度稍微慢一丢丢 vector\u003cvector\u003cint\u003e\u003e h(n); for (auto\u0026 e : edges) { int x = e[0], y = e[1]; h[x].push_back(y), h[y].push_back(x); // 无向图建图法 } 下面我们来分析这道题，这道题是要求重心，所以我们需要思考：如何求删除某个点后剩余各个连通块中点数？ 这个问题直接用 $DFS$ 就可以解决： 如图，我们思考一个一般性的情况：如果我们此时需要计算删除点 $4$ 之后剩余的 $1,2,3$ 号连通块的点数。 对于连通块 $2$ 和 $3$，我们可以通过 $\\text{DFS}$ 在回溯的过程中将连通块 $\\text{size}$ 返回，这样就可以知道连通块 $2$ 和 $3$ 的点数，但是对于连通块 $1$ 来说，无法通过返回值来求出来，这里我们可以使用一个技巧：$s_1=n-(sum_4)$。毕竟总节点数我们是知道的，所以只需要用总节点数减去节点 $4$ 这棵子树的总结点数就可以得到了。 完整 C++ 代码 #include \u003ciostream\u003e #include \u003ccstring\u003e #include \u003calgorithm\u003e using namespace std; const int N = 100010, M = N * 2; int n; int h[N], e[M], ne[M], idx; bool st[N]; // dfs和bfs基本都要开一个bool数组用来标记走过哪些点，因为每个点只能被遍历一次 int ans = N; // 记录一下全局的最小值 // 插入一条 a-\u003eb 的边 void add(int a, int b) { e[idx] = b, ne[idx] = h[a], h[a] = idx ++; } // 返回以u为根的子树中点的数量 int dfs(int u) { st[u] = true; // 标记一下该点已经被走过了 int sum = 1; // 记录当前子树的大小 int res = 0; // 把这个点删除后每一个连通块大小的最大值 for (int i = h[u]; i != -1; i = ne[i]) // 和遍历单链表是一模一样的 { int j = e[i]; if (!st[j]) { int s = dfs(j); sum += s; res = max(res, s); } } res = max(res, n - sum); // 上面连通块这种情况单独处理 ans = min(ans, res); return sum; } int main() { cin \u003e\u003e n; memset(h, -1, sizeof h); // 仿造链表初始化，将所以h都初始化为-1 for (int i = 0; i \u003c n; i ++) { int a, b; cin \u003e\u003e a \u003e\u003e b; add(a, b); add(b, a); // 无向图视为两条有向边 } dfs(1); // 这里从节点几开始搜都是可以的 cout \u003c\u003c ans \u003c\u003c endl; return 0; } ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:30:2","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"模拟退火 ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:31:0","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"AcWing 3167. 星星还是树 题目描述 ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:31:1","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"3167. 星星还是树 在二维平面上有 $n$ 个点，第 $i$ 个点的坐标为 $(x_i,y_i)$。 请你找出一个点，使得该点到这 $n$ 个点的距离之和最小。 该点可以选择在平面中的任意位置，甚至与这 $n$ 个点的位置重合。 输入格式 第一行包含一个整数 $n$。 接下来 $n$ 行，每行包含两个整数 $x_i,y_i$，表示其中一个点的位置坐标。 输出格式 输出最小距离和，答案四舍五入取整。 数据范围 $1≤n≤100,$ $0≤x_i,y_i≤10000$ 输入样例： 4 0 0 0 10000 10000 10000 10000 0 输出样例： 28284 ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:31:2","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"爬山法 第四章 数学知识 ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:32:0","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"质数 ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:33:0","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"约数 ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:34:0","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"中国剩余定理 ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:35:0","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"求组合数 ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:36:0","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"容斥原理 ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:37:0","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"博弈论 第五章 动态规划 ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:38:0","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"DP问题初始化方式 （小于等于，等于，大于） dp[i]:表示当体积≤i的所有情况集合下的最大价值[如AcWing2. 01背包问题等] // dp[0] = 0; // 这种情况就是最基本的背包问题，无需特意初始化，只需要初值都是0就可以 ...... for (int j = m; j \u003e= v; j--) // 计算时严格保证任意状态下背包体积 \u003e= 0 { dp[j] = max(dp[j], dp[j - v] + w); } ...... cout \u003c\u003c dp[m] \u003c\u003c endl; // 最大值就是简单的dp[m] dp[i]:表示当体积==i的所有情况集合下的最大价值[如AcWing12. 背包问题求具体方案等] memset(dp, -0x3f, sizeof dp); // 初始化为∞（如果题目求max，就用-∞，求min，就用+∞） dp[0] = 0; // 对dp[0]作为起始点单独初始化,求最大价值就初始化为0，求方案数就初始化为1 ...... for (int j = m; j \u003e= v; j--) // 计算时严格保证任意状态下背包体积 \u003e= 0 { dp[j] = max(dp[j], dp[j - v] + w); } ...... int res = 0; // 注意这里是体积恰好为i的情况，所以最大值就不只是简单的dp[m] for (int i = 0; i \u003c= m; i++) res = max(res, dp[i]); // 需要一层循环求结果 cout \u003c\u003c res \u003c\u003c endl; dp[i]:表示当体积≥i的所有情况集合下的最小价值[如AcWing1020. 潜水员等] memset(dp, 0x3f, sizeof dp); // 初始化为∞（如果题目求max，就用+∞，求min，就用-∞） dp[0] = 0; // 对dp[0]作为起始点单独初始化,求最大价值就初始化为0，求方案数就初始化为1 ...... for (int j = m; j \u003e= 0; j--) // 计算时任意状态下背包的体积允许 \u003c 0 { dp[j][k] = min(dp[j][k], dp[max(0, j-v1)][max(0, k-v2)]+w); } ...... cout \u003c\u003c dp[m][n] \u003c\u003c endl; // 最大值需要自己判断，可能还是dp[m][n] ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:39:0","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"数字三角形模型 数字三角形模型应该算是dp中最简单的模型了 ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:40:0","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"AcWing 1018. 最低通行费 题目描述 一个商人穿过一个 $N×N$ 的正方形的网格，去参加一个非常重要的商务活动。 他要从网格的左上角进，右下角出。 每穿越中间 $1$ 个小方格，都要花费 $1$ 个单位时间。 商人必须在 $(2N−1)$ 个单位时间穿越出去。 而在经过中间的每个小方格时，都需要缴纳一定的费用。 这个商人期望在规定时间内用最少费用穿越出去。 请问至少需要多少费用？ 注意：不能对角穿越各个小方格（即，只能向上下左右四个方向移动且不能离开网格）。 输入格式 第一行是一个整数，表示正方形的宽度 $N$。 后面 $N$ 行，每行 $N$ 个不大于 $100$ 的正整数，为网格上每个小方格的费用。 输出格式 输出一个整数，表示至少需要的费用。 数据范围 $0\u003cN≤100$ 输入样例： 5 1 4 6 8 10 2 5 7 15 17 6 8 9 18 20 10 11 12 19 21 20 23 25 29 33 输出样例： 109 算法设计 这题说的看起来很复杂，商人必须在 $(2N−1)$ 个单位时间穿越出去，其实用贪心发现最快方式也就是每次只往右或者下走，时间正好是 $(2N−1)$ 所以这题其实就是一道数字三角形的简单模板 完整 C++ 代码 #include \u003ciostream\u003e #include \u003calgorithm\u003e #include \u003ccstring\u003e using namespace std; const int N = 110; int n; int w[N][N]; int dp[N][N]; int main() { cin \u003e\u003e n; for (int i = 1; i \u003c= n; i++) for (int j = 1; j \u003c= n; j++) cin \u003e\u003e w[i][j]; memset(dp, 0x3f, sizeof dp); // 求min就设置无穷大，方便后面就不用写if判断语句了 dp[0][1] = 0; for (int i = 1; i \u003c= n; i++) for (int j = 1; j \u003c= n; j++) dp[i][j] = w[i][j] + min(dp[i - 1][j], dp[i][j - 1]); cout \u003c\u003c dp[n][n] \u003c\u003c endl; return 0; } ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:40:1","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"最长上升子序列模型 ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:41:0","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"AcWing 895. 最长上升子序列 题目描述 给定一个长度为 $N$ 的数列，求数值严格单调递增的子序列的长度最长是多少。 输入格式 第一行包含整数 $N$。 第二行包含 $N$ 个整数，表示完整序列。 输出格式 输出一个整数，表示最大长度。 数据范围 $0\u003cN≤1000$ $−10^9≤$ 数列中的数 $≤109$ 输入样例： 7 3 1 2 1 8 5 6 输出样例： 4 算法设计 $f_i$ 表示所有以第 $i$ 个数结尾的上升子序列中的最大值 完整C++ 代码 #include \u003ciostream\u003e #include \u003calgorithm\u003e using namespace std; const int N = 1010; int a[N], dp[N]; int main() { int n; cin \u003e\u003e n; for (int i = 1; i \u003c= n; i++) cin \u003e\u003e a[i]; for (int i = 1; i \u003c= n; i++) { dp[i] = 1; for (int j = 1; j \u003c i; j++) { if (a[i] \u003e a[j]) dp[i] = max(dp[i], dp[j] + 1); } } int res = 0; for (int i = 1; i \u003c= n; i++) res = max(res, dp[i]); cout \u003c\u003c res \u003c\u003c endl; return 0; } ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:41:1","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"背包模型 ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:42:0","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"AcWing 2. 01背包问题 题目描述 ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:42:1","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"2. 01背包问题 有 $N$ 件物品和一个容量是 $V$ 的背包，每件物品只能使用一次。 第 $i$ 件物品的体积是 $v_i$，价值是 $w_i$。 求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。 输出最大价值。 输入格式 第一行两个整数, $N$，$V$，用空格隔开，分别表示物品数量和背包容积。 接下来有 $N$ 行，每行两个整数 $v_i$,$w_i$，用空格隔开，分别表示第 $i$ 件物品的体积和价值。 输出格式 输出一个整数，表示最大价值。 数据范围 $0\u003cN,V≤1000$ $0\u003cv_i,w_i≤1000$ 输入样例： 4 5 1 2 2 4 3 4 4 5 输出样例： 8 算法设计 背一下01背包的代码模板就行 完整 C++ 代码 #include \u003ciostream\u003e #include \u003calgorithm\u003e using namespace std; const int N = 1010; int v[N], w[N]; int dp[N][N]; int main() { int nn, vv; cin \u003e\u003e nn \u003e\u003e vv; for (int i = 1; i \u003c= nn; i ++) cin \u003e\u003e v[i] \u003e\u003e w[i]; for (int i = 1; i \u003c= nn; i ++) { for (int j = 1; j \u003c= vv; j ++) { // 如果没有将第i件物品装入背包 dp[i][j] = dp[i-1][j]; // 如果将第i件物品装入背包 if (j \u003e= v[i]) dp[i][j] = max(dp[i][j], dp[i-1][j-v[i]] + w[i]); } } cout \u003c\u003c dp[nn][vv] \u003c\u003c endl; } ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:42:2","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"AcWing 3. 完全背包问题 题目描述 ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:42:3","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"3. 完全背包问题 有 $N$ 件物品和一个容量是 $V$ 的背包，每种物品都有无限件可用。 第 $i$ 件物品的体积是 $v_i$，价值是 $w_i$。 求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。 输出最大价值。 输入格式 第一行两个整数, $N$，$V$，用空格隔开，分别表示物品数量和背包容积。 接下来有 $N$ 行，每行两个整数 $v_i$,$w_i$，用空格隔开，分别表示第 $i$ 件物品的体积和价值。 输出格式 输出一个整数，表示最大价值。 数据范围 $0\u003cN,V≤1000$ $0\u003cv_i,w_i≤1000$ 输入样例： 4 5 1 2 2 4 3 4 4 5 输出样例： 10 算法设计 背一下完全背包的代码模板就行 完整 C++ 代码 暴力版本 $O(n^3)$ #include \u003ciostream\u003e #include \u003calgorithm\u003e using namespace std; const int N = 1010; int v[N], w[N]; int dp[N][N]; int main() { int nn, vv; cin \u003e\u003e nn \u003e\u003e vv; for (int i = 1; i \u003c= nn; i ++) cin \u003e\u003e v[i] \u003e\u003e w[i]; for (int i = 1; i \u003c= nn; i ++) { for (int j = 1; j \u003c= vv; j ++) { // 如果没有将第i件物品装入背包 dp[i][j] = dp[i-1][j]; // 如果将第i件物品装入背包 for (int k = 1; k * v[i] \u003c= j; k ++) dp[i][j] = max(dp[i][j], dp[i-1][j-k*v[i]] + k*w[i]); } } cout \u003c\u003c dp[nn][vv] \u003c\u003c endl; } 优化后 $O(n^2)$ #include \u003ciostream\u003e #include \u003calgorithm\u003e using namespace std; const int N = 1010; int v[N], w[N]; int dp[N][N]; int main() { int nn, vv; cin \u003e\u003e nn \u003e\u003e vv; for (int i = 1; i \u003c= nn; i ++) cin \u003e\u003e v[i] \u003e\u003e w[i]; for (int i = 1; i \u003c= nn; i ++) { for (int j = 1; j \u003c= vv; j ++) { // 如果没有将第i件物品装入背包 dp[i][j] = dp[i-1][j]; // 如果将第i件物品装入背包 // dp[i][j] = j, j - v + w, j - 2v + 2w, j - 3v + 3w, ... // = (j - v) + w, (j - v) - v + 2w, (j - v) - 2v + 3w, ... // = dp[i][j - v] + w if (j \u003e= v[i]) dp[i][j] = max(dp[i][j], dp[i][j-v[i]] + w[i]); } } cout \u003c\u003c dp[nn][vv] \u003c\u003c endl; } ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:42:4","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"AcWing 4. 多重背包问题 I 题目描述 有 $N$ 种物品和一个容量是 $V$ 的背包。 第 $i$ 种物品最多有 $s_i$ 件，每件体积是 $v_i$，价值是 $w_i$。 求解将哪些物品装入背包，可使物品体积总和不超过背包容量，且价值总和最大。 输出最大价值。 输入格式 第一行两个整数，$N$, $V$，用空格隔开，分别表示物品种数和背包容积。 接下来有 $N$ 行，每行三个整数 $v_i$, $w_i$, $s_i$，用空格隔开，分别表示第 $i$ 种物品的体积、价值和数量。 输出格式 输出一个整数，表示最大价值。 数据范围 $0\u003cN,V≤100$ $0\u003cv_i, w_i, s_i≤100$ 输入样例： 4 5 1 2 3 2 4 1 3 4 3 4 5 2 输出样例： 10 算法设计 背一下完全背包的代码模板就行，这题的数据来看时间复杂度 $O(n^3)$ 就可以ac 完整 C++ 代码 #include \u003ciostream\u003e #include \u003calgorithm\u003e using namespace std; const int N = 1010; int v[N], w[N], s[N]; int dp[N][N]; int main() { int nn, vv; cin \u003e\u003e nn \u003e\u003e vv; for (int i = 1; i \u003c= nn; i ++) cin \u003e\u003e v[i] \u003e\u003e w[i] \u003e\u003e s[i]; for (int i = 1; i \u003c= nn; i ++) { for (int j = 1; j \u003c= vv; j ++) { // 如果没有将第i件物品装入背包 dp[i][j] = dp[i-1][j]; // 如果将第i件物品装入背包 for (int k = 1; k * v[i] \u003c= j \u0026\u0026 k \u003c= s[i]; k ++) dp[i][j] = max(dp[i][j], dp[i-1][j-k*v[i]] + k*w[i]); } } cout \u003c\u003c dp[nn][vv] \u003c\u003c endl; } ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:42:5","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"AcWing 5. 多重背包问题 II 题目描述 有 $N$ 种物品和一个容量是 $V$ 的背包。 第 $i$ 种物品最多有 $s_i$ 件，每件体积是 $v_i$，价值是 $w_i$。 求解将哪些物品装入背包，可使物品体积总和不超过背包容量，且价值总和最大。 输出最大价值。 输入格式 第一行两个整数，$N$, $V$，用空格隔开，分别表示物品种数和背包容积。 接下来有 $N$ 行，每行三个整数 $v_i$, $w_i$, $s_i$，用空格隔开，分别表示第 $i$ 种物品的体积、价值和数量。 输出格式 输出一个整数，表示最大价值。 数据范围 $0\u003cN≤1000$ $0\u003cV≤2000$ $0\u003cv_i, w_i, s_i≤2000$ 提示： 本题考查多重背包的二进制优化方法。 输入样例： 4 5 1 2 3 2 4 1 3 4 3 4 5 2 输出样例： 10 算法设计 一个非常简洁的二进制优化自用板子 根据y总讲的AcWing7. 混合背包问题整理的板子，相当简洁还省空间 空间复杂度无需$O(n \\log n)$,降为$O(max(n, log s))$ 时间复杂度还是$O(n^2log n)$ 完整 C++ 代码 #include \u003ciostream\u003e using namespace std; const int N = 2010; int dp[N]; int main() { int n, m; cin \u003e\u003e n \u003e\u003e m; for (int i = 1; i \u003c= n; i++) { int v, w, s; cin \u003e\u003e v \u003e\u003e w \u003e\u003e s; for (int k = 1; k \u003c= s; k *= 2) // 把s拆成二进制形式，如 10 = 2^0 + 2^1 + 2^2 + 3 { for (int j = m; j \u003e= k * v; j--) // 对上面的分开形式进行01背包 { dp[j] = max(dp[j], dp[j - k * v] + k * w); } s -= k; } if (s) { // 处理刚刚拆开的二进制的最后一位 for (int j = m; j \u003e= s * v; j--) { dp[j] = max(dp[j], dp[j - s * v] + s * w); } } } cout \u003c\u003c dp[m] \u003c\u003c endl; return 0; } ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:42:6","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"状态机模型 ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:43:0","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"AcWing 1058. 股票买卖 V 题目描述 给定一个长度为 $N$ 的数组，数组中的第 $i$ 个数字表示一个给定股票在第 $i$ 天的价格。 设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）: 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。 卖出股票后，你无法在第二天买入股票 (即冷冻期为 $1$ 天)。 输入格式 第一行包含整数 $N$，表示数组长度。 第二行包含 $N$ 个不超过 $10000$ 的正整数，表示完整的数组。 输出格式 输出一个整数，表示最大利润。 数据范围 $1≤N≤10^5$ 输入样例： 5 1 2 3 0 2 输出样例： 3 算法设计 状态分为：1. 手中有货，2. 手中无货的第 $1$ 天，3. 手中无货的第 $\\ge2$ 天 完整C++ 代码 #include \u003ciostream\u003e #include \u003ccstring\u003e using namespace std; const int N = 100010, INF = 0x3f3f3f3f; int dp[N][3]; // dp[i][0]:有货, dp[i][1]:手中无货的第1天, dp[i][2]:手中无货的第≥2天 int main() { int n; cin \u003e\u003e n; memset(dp, -0x3f, sizeof dp); dp[0][2] = 0; for (int i = 1; i \u003c= n; i++) { int w; cin \u003e\u003e w; dp[i][0] = max(dp[i - 1][0], dp[i - 1][2] - w); dp[i][1] = dp[i - 1][0] + w; dp[i][2] = max(dp[i - 1][2], dp[i - 1][1]); } cout \u003c\u003c max(dp[n][1], dp[n][2]) \u003c\u003c endl; return 0; } ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:43:1","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"状态压缩DP ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:44:0","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"AcWing 1064. 小国王 题目描述 ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:44:1","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"1064. 小国王 在 $n×n$ 的棋盘上放 $k$ 个国王，国王可攻击相邻的 $8$ 个格子，求使它们无法互相攻击的方案总数。 输入格式 共一行，包含两个整数 $n$ 和 $k$ 。 输出格式 共一行，表示方案总数，若不能够放置则输出$0$。 数据范围 $1 \\le n \\le10$, $0 \\le k \\le n^2$ 输入样例： 3 2 输出样例： 16 算法设计 这是收录的一道经典的**连通性状态压缩 $\\text{DP}$ **。 这里的状态压缩，其实指的就是二进制状态压缩，是指将一个长度为 $m$ 的 $\\text{bool}$ 数组只需要用一个 $m$ 位的二进制整数表示并存储即可。这里当 $m \u003c 32$ 时，可以直接用一个 $\\text{int}$ 来存储，如果 $m$ 较大，就需要使用 $\\text{int}$ 数组或者 $\\text{C++\\ STL}$ 提供的 $\\text{bitset}$。 $f(i,j,s)$:所有只摆在前$i$行，已经摆了$j$个国王，并且第$i$行摆放的状态是$s$的所有方案的集合。 首先我们来看看暴力一点的做法，虽然我们提前对符合条件的值进行了预处理，但是依旧会超时。因为我们最后还是在最后状态转移阶段还是在遍历每一个二进制数，虽然判断其合法性的操作提前进行了预处理来降低了部分时间复杂度，但是依旧需要$O(N \\times K \\times 2^n \\times 2^n)$,在这一题大概是$10^9$,会超时。 暴力做法 C++ 代码 #include \u003ciostream\u003e #include \u003ccstring\u003e using namespace std; const int N = 12, M = N * N, S = 1 \u003c\u003c N; int dp[N][M][S]; bool st[S]; int cnt[S]; int main() { int n, m; cin \u003e\u003e n \u003e\u003e m; dp[0][0][0] = 1; for (int i = 0; i \u003c 1 \u003c\u003c n; i++) { st[i] = true; int num = 0; for (int u = 0; u \u003c n; u++) { if (i \u003e\u003e u \u0026 1) { num++; if (num \u003e 1) st[i] = false; } else num = 0; } if (num \u003e 1) st[i] = false; } for (int i = 0; i \u003c 1 \u003c\u003c n; i++) { for (int u = 0; u \u003c n; u++) { if (i \u003e\u003e u \u0026 1) cnt[i]++; } } for (int i = 1; i \u003c= n; i++) { for (int j = 0; j \u003c= m; j++) { for (int k = 0; k \u003c 1 \u003c\u003c n; k++) { for (int u = 0; u \u003c 1 \u003c\u003c n; u++) { if (k \u0026 u) continue; if (!st[k | u]) continue; if (cnt[k] \u003c= j) dp[i][j][k] += dp[i - 1][j - cnt[k]][u]; } } } } int res = 0; for (int i = 0; i \u003c 1 \u003c\u003c n; i++) res += dp[n][m][i]; cout \u003c\u003c res \u003c\u003c endl; return 0; } 进一步思考：如果我们把所有可能符合的值在预处理阶段存下来，那么我们在最终状态转移的时候，岂不是其实只需要在这些值里进行遍历，那么时间复杂度就可以进一步降低。 优化版本 C++ 代码 #include \u003ciostream\u003e #include \u003ccstring\u003e #include \u003cvector\u003e using namespace std; const int N = 12, S = N * N, M = 1 \u003c\u003c N; int n, m; long long dp[N][S][M]; int cnt[M]; vector\u003cint\u003e state; vector\u003cint\u003e head[M]; bool check(int state) { for (int u = 0; u \u003c n; u++) { if ((state \u003e\u003e u \u0026 1) \u0026\u0026 (state \u003e\u003e u + 1 \u0026 1)) return false; } return true; } int count(int state) { int res = 0; for (int u = 0; u \u003c n; u++) if (state \u003e\u003e u \u0026 1) res++; return res; } int main() { cin \u003e\u003e n \u003e\u003e m; dp[0][0][0] = 1; for (int i = 0; i \u003c 1 \u003c\u003c n; i++) { if (check(i)) { state.push_back(i); // 预处理出来所有的不存在连续两个1的可能情况，后续只对这些情况进行循环 cnt[i] = count(i); // 预处理出1的个数 } } for (int i = 0; i \u003c state.size(); i++) { for (int j = 0; j \u003c state.size(); j++) { int a = state[i]; int b = state[j]; if ((a \u0026 b) == 0 \u0026\u0026 check(a | b)) // ！！！:这里写成if ((a \u0026 b == 0) \u0026\u0026 check(a | b))是错误的，因为优先级 { head[a].push_back(b); } } } for (int i = 1; i \u003c= n; i++) { for (int j = 0; j \u003c= m; j++) { for (int a = 0; a \u003c state.size(); a++) { for (int b = 0; b \u003c head[state[a]].size(); b++) { int c = cnt[state[a]]; if (j \u003e= c) dp[i][j][state[a]] += dp[i - 1][j - c][head[state[a]][b]]; } } } } long long res = 0; for (int i = 0; i \u003c 1 \u003c\u003c n; i++) res += dp[n][m][i]; cout \u003c\u003c res \u003c\u003c endl; // 或是更简单的在上一步循环时到 i\u003c=n+1 结束，此时 res=dp[n+1][0]; return 0; } ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:44:2","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"AcWing 91. 最短Hamilton路径 题目描述 ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:44:3","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"91. 最短Hamilton路径 给定一张 $n$ 个点的带权无向图，点从 $0∼n−1$ 标号，求起点 $0$ 到终点 $n−1$ 的最短 Hamilton 路径。 Hamilton 路径的定义是从 $0$ 到 $n−1$ 不重不漏地经过每个点恰好一次。 输入格式 第一行输入整数 $n$。 接下来 $n$ 行每行 $n$ 个整数，其中第 $i$ 行第 $j$ 个整数表示点 $i$ 到 $j$ 的距离（记为 $a[i,j]$）。 对于任意的 $x,y,z$，数据保证 $a[x,x]=0，a[x,y]=a[y,x]$ 并且 $a[x,y]+a[y,z]≥a[x,z]$。 输出格式 输出一个整数，表示最短 Hamilton 路径的长度。 数据范围 $1≤n≤20$ $0≤a[i,j]≤10^7$ 输入样例： 5 0 2 4 5 1 2 0 6 5 3 4 6 0 8 3 5 5 8 0 5 1 3 3 5 0 输出样例： 18 算法设计 这是收录的一道经典的集合类状态压缩 $\\text{DP}$。 完整 C++ 代码 ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:44:4","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"区间DP ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:45:0","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"AcWing 282. 石子合并 题目描述 282. 石子合并 设有 $N$ 堆石子排成一排，其编号为 $1,2,3,…,N$。 每堆石子有一定的质量，可以用一个整数来描述，现在要将这 $N$ 堆石子合并成为一堆。 每次只能合并相邻的两堆，合并的代价为这两堆石子的质量之和，合并后与这两堆石子相邻的石子将和新堆相邻，合并时由于选择的顺序不同，合并的总代价也不相同。 例如有 $4$ 堆石子分别为 1 3 5 2， 我们可以先合并 $1、2$ 堆，代价为 $4$，得到 4 5 2， 又合并 $1、2$ 堆，代价为 $9$，得到 9 2 ，再合并得到 $11$，总代价为 $4+9+11=24$； 如果第二步是先合并 $2、3$堆，则代价为 $7$，得到 4 7，最后一次合并代价为 $11$，总代价为 $4+7+11=22$。 问题是：找出一种合理的方法，使总的代价最小，输出最小代价。 输入格式 第一行一个数 $N$ 表示石子的堆数 $N$。 第二行 $N$ 个数，表示每堆石子的质量(均不超过 $1000$)。 输出格式 输出一个整数，表示最小代价。 数据范围 $1≤n≤300$ 输入样例： 4 1 3 5 2 输出样例： 22 算法设计 这是区间 $\\text{DP}$ 的一道经典的模板题，一般有两种解法： 迭代式：适合对于一维的情况 for (int len = 2; len \u003c= n; len++) // 一般就是先枚举区间长度len for (int L = 1; L + len - 1 \u003c= n; L++) // 然后枚举左端点 { R = L + len - 1; // 就可以推出右端点 } 记忆化搜索：主要针对二维及以上的情况 对于此题来说，$f_{i,j}$ 表示所有将 $[i, j]$ 这个区间中的石子合并成一堆的方案的所有集合中的最小代价。 如果直接对 $i, j$ 进行从 $1∼n$ 进行迭代的话是错误的，因为这里的状态转移过程是将左右两堆已经合并好的合并成一个大堆，所以得先合并小堆。 所以区间 $ \\text{DP}$ 这里比较特殊，我们对区间长度 $\\text{len}$ 进行遍历，这样大区间就会依赖于小区间计算出来的结果。 完整C++ 代码 #include \u003ciostream\u003e #include \u003ccstring\u003e using namespace std; const int N = 310, INF = 0x3f3f3f3f; int n; int s[N], dp[N][N]; int main() { cin \u003e\u003e n; for (int i = 1; i \u003c= n; i++) { cin \u003e\u003e s[i]; s[i] += s[i - 1]; } for (int len = 2; len \u003c= n; len++) for (int l = 1; l + len - 1 \u003c= n; l++) { int r = l + len - 1; dp[l][r] = INF; for (int d = l; d + 1 \u003c= r; d++) // 假设将区间划分成[l, d] 和 [d + 1, r] { dp[l][r] = min(dp[l][r], dp[l][d] + dp[d + 1][r] + (s[r] - s[l - 1])); } } // 或者下面初始化写法: // memset(dp, INF, sizeof dp); // for (int len = 1; len \u003c= n; len++) // for (int l = 1; l + len - 1 \u003c= n; l++) // { // int r = l + len - 1; // if (len == 1) dp[l][r] = 0; // 长度为1不需要代价 // else // { // for (int d = l; d + 1 \u003c= r; d++) // 假设将区间划分成[l, d] 和 [d + 1, r] // dp[l][r] = min(dp[l][r], dp[l][d] + dp[d + 1][r] + (s[r] - s[l - 1])); // } // } cout \u003c\u003c dp[1][n] \u003c\u003c endl; } 拓展 本题其实是还有一道变式 ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:45:1","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"320. 能量项链 题目描述 在 $\\text{Mars}$ 星球上，每个 $\\text{Mars}$ 人都随身佩带着一串能量项链，在项链上有 $N$ 颗能量珠。 能量珠是一颗有头标记与尾标记的珠子，这些标记对应着某个正整数。 并且，对于相邻的两颗珠子，前一颗珠子的尾标记一定等于后一颗珠子的头标记。 因为只有这样，通过吸盘（吸盘是 $\\text{Mars}$ 人吸收能量的一种器官）的作用，这两颗珠子才能聚合成一颗珠子，同时释放出可以被吸盘吸收的能量。 如果前一颗能量珠的头标记为 $m$，尾标记为 $r$，后一颗能量珠的头标记为 $r$，尾标记为 $n$，则聚合后释放的能量为 $m×r×n$（$\\text{Mars}$ 单位），新产生的珠子的头标记为 $m$，尾标记为 $n$。 需要时，$\\text{Mars}$ 人就用吸盘夹住相邻的两颗珠子，通过聚合得到能量，直到项链上只剩下一颗珠子为止。 显然，不同的聚合顺序得到的总能量是不同的，请你设计一个聚合顺序，使一串项链释放出的总能量最大。 例如：设 $N=4$，$4$ 颗珠子的头标记与尾标记依次为 $(2，3)(3，5)(5，10)(10，2)$。 我们用记号 $⊕$ 表示两颗珠子的聚合操作，$(j⊕k)$ 表示第 $j$，$k$ 两颗珠子聚合后所释放的能量。则第 $4、1$ 两颗珠子聚合后释放的能量为：$(4⊕1)=10×2×3=60$。 这一串项链可以得到最优值的一个聚合顺序所释放的总能量为 $((4⊕1)⊕2)⊕3)=10×2×3+10×3×5+10×5×10=710$。 输入格式 输入的第一行是一个正整数 $N$，表示项链上珠子的个数。 第二行是 $N$ 个用空格隔开的正整数，所有的数均不超过 $1000$，第 $i$ 个数为第 $i$ 颗珠子的头标记，当 $i\u003cN$ 时，第 $i$ 颗珠子的尾标记应该等于第 $i+1$ 颗珠子的头标记，第 $N$ 颗珠子的尾标记应该等于第 $1$ 颗珠子的头标记。 至于珠子的顺序，你可以这样确定：将项链放到桌面上，不要出现交叉，随意指定第一颗珠子，然后按顺时针方向确定其他珠子的顺序。 输出格式 输出只有一行，是一个正整数 $E$，为一个最优聚合顺序所释放的总能量。 数据范围 $4≤N≤100$, $1≤E≤2.1×10^9$ 输入样例： 4 2 3 5 10 输出样例： 710 算法设计 这题主要的变化在两个部分： 环形合并 这一题咋一看就和石子合并这一题基本一样，但是是个环形，所以这题可以简单思考为如何断链成一排石子。 很朴素的想法是，枚举每一个可能的断链点，如 $1,2…n$, 然后分别使用石子合并模板。 不好的消息是这种做法的时间复杂度是 $O(n^4)$, 这题给的 $n$ 范围在 $200$ 以内，会 $\\text{TLE}$。 此题的通解是： $$ \\begin{matrix} 1\\ \\underbrace{ 2\\ \\ 3\\dots \\ n\\ \\ 1}\\ 2\\dots n \\ len=n \\to \\text{可以看作是环在 1,2 处断链} \\end{matrix} $$ ​ 即我们只需要构造一个长度为 $2n$ 的石子合并问题即可，后面 $n$ 堆的石子和前面 $n$ 堆石子完全一样，直接使用石子合并模板对这 $2n$ 堆石子进行求 $\\max$ 和 $\\min$ 即可。时间复杂度也从 $O(n^4)$ 降到 $O(n^3)$。 聚合操作 这里的聚合操作不是简单的石子合并了，有点像矩阵的味道。 对于样例，$(2，3)(3，5)(5，10)(10，2)\\to2,\\ 3,\\ 5,\\ 10,\\ 2$ 将这 $4$ 颗能量珠抽象为 $5$ 个数，然后对这 $5$ 个数套用石子合并模板。 注意这里状态计算的时候，和石子合并不同，石子合并是将 $[l,r]$ 分成 $[l,d]$ 和 $[d+1, r]$ 两个区间；但是这里是划分成$[l,d]$ 和 $[d, r]$ 两个区间,这里的划分点 $d$ 是共用的: $$ \\begin{matrix} \\underbrace{ 2,\\ 3,} \\underbrace{ \\ 5,\\ 10,\\ 2} \\ [2,3]\\ \\ \\ \\ [3,2] \\end{matrix} $$ 以及这里的区间长度最少从 $3$ 开始，因为 $\\text{len}=2$ 时只是一颗能量珠，不需要合并，可以省去一次判断。 以及最终的区间长度应该是 $n+1$。 完整C++代码 #include \u003ciostream\u003e using namespace std; const int N = 300; int n; int w[N], dp[N][N]; int main() { cin \u003e\u003e n; for (int i = 1; i \u003c= n; i++) { cin \u003e\u003e w[i]; w[i + n] = w[i]; } for (int len = 3; len \u003c= n + 1; len++) // 注意这里len得从3开始，且取到n+1 for (int l = 1; l + len - 1 \u003c= n * 2; l++) { int r = l + len - 1; for (int d = l + 1; d \u003c r; d++) { dp[l][r] = max(dp[l][r], dp[l][d] + dp[d][r] + w[l] * w[d] * w[r]); } } int res = 0; for (int i = 1; i \u003c= n; i++) { int j = i + n; // 注意这里是因为区间长度为n+1 res = max(res, dp[i][j]); } cout \u003c\u003c res \u003c\u003c endl; return 0; } ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:45:2","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"AcWing 479. 加分二叉树 题目描述 ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:45:3","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"479. 加分二叉树 设一个 $n$ 个节点的二叉树 tree 的中序遍历为（$1,2,3,…,n$），其中数字 $1,2,3,…,n$ 为节点编号。 每个节点都有一个分数（均为正整数），记第 $i$ 个节点的分数为 $d_i$，tree 及它的每个子树都有一个加分，任一棵子树 subtree（也包含 tree 本身）的加分计算方法如下： subtree 的左子树的加分 $×$ subtree 的右子树的加分 $+$ subtree 的根的分数 若某个子树为空，规定其加分为 $1$。 叶子的加分就是叶节点本身的分数，不考虑它的空子树。 试求一棵符合中序遍历为（$1,2,3,…,n$）且加分最高的二叉树 tree。 要求输出： （1）tree 的最高加分 （2）tree 的前序遍历 输入格式 第 $1$ 行：一个整数 $n$，为节点个数。 第 $2$ 行：$n$ 个用空格隔开的整数，为每个节点的分数（$0\u003c$分数$\u003c100$）。 输出格式 第 $1$ 行：一个整数，为最高加分（结果不会超过int范围）。 第 $2$ 行：$n$ 个用空格隔开的整数，为该树的前序遍历。如果存在多种方案，则输出字典序最小的方案。 数据范围 $n\u003c30$ 输入样例： 5 5 7 1 2 10 输出样例： 145 3 1 2 4 5 算法设计 这里选这题作为模板是因为这是一道求区间 $\\text{DP}$ 具体方案的题目，和之前的石子合并求最大最小代价是不一样的。 求区间 $\\text{DP}$ 具体方案的通用做法是： 通过使用 $g_{i,j}$ 记录区间 $[i,j]$ 中最大价值时的划分点 $d$ ，在使用完区间合并模板后，只需要使用一次 $\\text{dfs}$ 即可找到每一次最大价值的划分点。 完整C++ 代码 #include \u003ciostream\u003e #include \u003ccstring\u003e #include \u003calgorithm\u003e using namespace std; const int N = 50, INF = 0x3f3f3f3f; int n; int w[N]; int dp[N][N], g[N][N]; void dfs(int l, int r) { if (l \u003e r) return; int d = g[l][r]; cout \u003c\u003c d \u003c\u003c \" \"; dfs(l, d - 1); dfs(d + 1, r); } int main() { cin \u003e\u003e n; for (int i = 1; i \u003c= n; i++) cin \u003e\u003e w[i]; memset(dp, -INF, sizeof dp); for (int len = 1; len \u003c= n; len++) for (int l = 1; l + len - 1 \u003c= n; l++) { int r = l + len - 1; if (len == 1) // 这题因为对len=1情况特殊规定了，所以得使用模板的第2种写法 { dp[l][r] = w[l]; g[l][r] = l; } else for (int d = l; d \u003c= r; d++) { int left = dp[l][d - 1], right = dp[d + 1][r]; if (d == l) // 题目种 left = 1; if (d == r) right = 1; if (dp[l][r] \u003c left * right + w[d]) { dp[l][r] = left * right + w[d]; g[l][r] = d; } } } cout \u003c\u003c dp[1][n] \u003c\u003c endl; dfs(1, n); return 0; } ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:45:4","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"树形DP ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:46:0","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"AcWing 1072. 树的最长路径 题目描述 ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:46:1","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"1072. 树的最长路径 给定一棵树，树中包含 $n$ 个结点（编号$1∼n$）和 $n−1$ 条无向边，每条边都有一个权值。 现在请你找到树中的一条最长路径。 换句话说，要找到一条路径，使得使得路径两端的点的距离最远。 注意：路径中可以只包含一个点。 输入格式 第一行包含整数 $n$。 接下来 $n−1$ 行，每行包含三个整数 $a_i,b_i,c_i$，表示点 $a_i$ 和 $b_i$ 之间存在一条权值为 $c_i$ 的边。 输出格式 输出一个整数，表示树的最长路径的长度。 数据范围 $1≤n≤10000$, $1≤ai,bi≤n$, $−10^5≤ci≤10^5$ 输入样例： 6 5 1 6 1 4 5 6 3 9 2 6 8 6 1 7 输出样例： 22 算法设计 首先我们先来证明图论中的一个经典结论：对于没有负边权的树，如何找树的直径？ 任取一点作为起点，找到距离该点最远的一个点 $u$。 再找到距离 $u$ 最远的一点 $v$。 此时 $uv$ 就是我们要找的一条直径。 也即我们只需要使用两次 $\\text{BFS}$ 在$O(n)$的时间复杂度里便可找到我们需要的直径。 下面我们对这个经典结论进行证明： 其实这个证明等价于证明 $1$ 中我们所找到的 $u$ 是某条直径的一个端点。 我们假设任意选取的一个起点为 $a$，反证法假设 $u$ 不是任意一条直径的一条端点，我们假设有一条直径 $bc$。 $bc$ 和 $au$ 没有交点。由于树的定义，这两条线一定是连通的，我们假设 $au$ 中存在一点 $x$ 与 $bc$ 中的 $y$ 存在一条路径 $xy$。根据定义 $u$ 是我们找到的距离 $a$ 最远的一个点，易得 $xu \\ge xy+yc$，所以 $xu+xy \\ge yc$，故 $byxu \\ge byc$，又由 $byc$ 是直径，所以 $byxu$ 一定也是直径，所以 $u$ 一定是直径的一个端点。 $bc$ 和 $au$ 没有交点。我们假设交点为 $x$，即我们有 $bxc$ 和 $axu$ 两条直线。根据定义 $u$ 是我们找到的距离 $a$ 最远的一个点，易得 $xu \\ge xc$，所以 $bxu \\ge bxc$，又由 $bxc$ 是直径，所以 $bxu$ 一定也是直径，所以 $u$ 一定是直径的一个端点。 综上所述，$u$ 一定是某条直径的一个端点。 对于本题来说，边权可以为负，故证明中的第一种情况里的由 $xu \\ge xy+yc$ 便推不出 $xu+xy \\ge yc$ 来了，所以两次 $\\text{BFS}$ 无法得到我们要的直径了。所以我们需要使用更一般的方法：树形 DP 来求解此题。 本质上 DP 只是对暴搜的一种优化：减少重复计算。 这里就是通过将所有路径的值存到这条路径所经过的所有点中最高的那个点里，下面我们该如何更新经过每个点的路径的最大值呢？ 我们将这个问题抽象出一个一般模型，如图所示，假设我们需要求出经过点 $u$ 的路径的最大值？ 我们可以通过 $\\text{DFS}$ 的返回值来分别得到点 $u$ 在子树 $1,2,3$ 中的往下走的一个最大的路径长度，然后通过 $d_i=s_i+w_i$ 便可得到这些子树上的经过 $u$ 的最长路径 $d_i$，然后通过统计出这些最长路径中的最大值 $m_1$ 和次大值 $m_2$（需要 $\u003e0$），$m_1 + m_2$ 就是我们要求的经过点 $u$ 的路径的最大值。 这里求最大值 $m_1$ 和次大值 $m_2$ 可以使用一个技巧： $m_1, m_2$ 初值设置为 $0$（可以保证后续更新后的 $m_1,m_2$ 也是 $\u003e0$ 的）。 如果每次算出来的 $d \\ge m_1$，我们就令 $m_2 = m_1$，$m_1 = d$。（这里更新顺序不能反） 如果每次算出来的 $d \u003c m_1$，但是 $d \u003em_2$，我们就令 $m_2=d$。 以及这里使用了 $\\text{st}$ 数组来确保每个点只走一次，有种 DP 减少重复计算的味道在里面。 完整 C++ 代码 这里我们可以通过每次 dfs 的时候传入一个 father 来避免递归回节点本身，下面代码便是这种写法 #include \u003ciostream\u003e #include \u003ccstring\u003e #include \u003calgorithm\u003e using namespace std; const int N = 10010, M = N * 2; int n; int h[N], w[M], e[M], ne[M], idx; int ans; void add(int a, int b, int c) { e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++; } // 返回过根节点的最长路径 int dfs(int u, int father) // 传入father来避免回头 { int m1 = 0, m2 = 0; for (int i = h[u]; i != -1; i = ne[i]) { int j = e[i]; if (j == father) continue; // 如果回头了，就退出 int d = dfs(j, u)+ w[i]; if (d \u003e= m1) m2 = m1, m1 = d; // 注意这里不能m1 = d, m2 = m1, else if (d \u003e m2) m2 = d; } ans = max(ans, m1 + m2); return m1; } int main() { cin \u003e\u003e n; for (int i = 1; i \u003c= n; i++) h[i] = -1; for (int i = 1; i \u003c n; i++) { int a, b, c; cin \u003e\u003e a \u003e\u003e b \u003e\u003e c; add(a, b, c); add(b, a, c); } dfs(1, -1); // 初始时没有父节点，就传入-1表示 cout \u003c\u003c ans \u003c\u003c endl; return 0; } 当然也可以仿造我们第三章树与图这章的写法，使用 $\\text{st}$ 数组来防止走回头路： #include \u003ciostream\u003e #include \u003ccstring\u003e #include \u003calgorithm\u003e using namespace std; const int N = 10010, M = N * 2; int n; int h[N], w[M], e[M], ne[M], idx; bool st[N]; int ans; void add(int a, int b, int c) { e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++; } // 返回过根节点的最长路径 int dfs(int u) { st[u] = true; int m1 = 0, m2 = 0; for (int i = h[u]; i != -1; i = ne[i]) { int j = e[i]; if (!st[j]) { int d = dfs(j)+ w[i]; if (d \u003e= m1) m2 = m1, m1 = d; // 注意这里不能m1 = d, m2 = m1, else if (d \u003e m2) m2 = d; } } ans = max(ans, m1 + m2); return m1; } int main() { cin \u003e\u003e n; for (int i = 1; i \u003c= n; i++) h[i] = -1; for (int i = 1; i \u003c n; i++) { int a, b, c; cin \u003e\u003e a \u003e\u003e b \u003e\u003e c; add(a, b, c); add(b, a, c); } dfs(1); cout \u003c\u003c ans \u003c\u003c endl; return 0; } 拓展 刚刚的一道题其实是利用子节点信息去逐步更新父节点信息，但是还有一些更变态的题目还需要再利用父节点信息去更新子节点信息，我们一起来看看下面收录的这道题吧。 ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:46:2","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"1073. 树的中心 给定一棵树，树中包含 n 个结点（编号11~nn）和 n−1n−1 条无向边，每条边都有一个权值。 请你在树中找到一个点，使得该点到树中其他结点的最远距离最近。 输入格式 第一行包含整数 nn。 接下来 n−1n−1 行，每行包含三个整数 ai,bi,ciai,bi,ci，表示点 aiai 和 bibi 之间存在一条权值为 cici 的边。 输出格式 输出一个整数，表示所求点到树中其他结点的最远距离。 数据范围 1≤n≤100001≤n≤10000, 1≤ai,bi≤n1≤ai,bi≤n, 1≤ci≤1051≤ci≤105 输入样例： 5 2 1 1 3 2 1 4 3 1 5 1 1 输出样例： 2 算法设计 y总在树形依赖 DP 这一块讲的不太行。我在知乎上也看到了有人说教材选自2017年的蓝书有点落伍了，一次这里的解法有点落后了，所以就不进行更新了，以后有时间再看看其他更新的视频来更新这里【插个眼】 完整 C++ 代码 xxx ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:46:3","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"数位DP ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:47:0","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"AcWing 1082. 数字游戏 题目描述 ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:47:1","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"1082. 数字游戏 科协里最近很流行数字游戏。 某人命名了一种不降数，这种数字必须满足从左到右各位数字呈非下降关系，如 $123$，$446$。 现在大家决定玩一个游戏，指定一个整数闭区间 $[a,b]$，问这个区间内有多少个不降数。 **注意：**不降数不能包含前导零。 输入格式 输入包含多组测试数据。 每组数据占一行，包含两个整数 $a$ 和 $b$。 输出格式 每行给出一组测试数据的答案，即 $[a,b]$ 之间有多少不降数。 数据范围 $1≤a≤b≤2^{31}−1$ 输入样例： 1 9 1 19 输出样例： 9 18 算法设计 数位 $\\text{DP}$ 常用思考方式： 利用前缀的思想：$[x,y] = f_y-f_{x-1}$ 从树的角度来考虑 image-20241218222708268 下面给出一般性的数位 $\\text{DP}$ 的模板： const int N = 15; int K, B; int dp[N][N]; void init() // 提前预处理一些信息 { // 如组合数等 } int count(int n) { if (!n) return 1; // 特判边界，这里可能是0或者1，依具体题目而定 vector\u003cint\u003e nums; while (n) nums.push_back(n % B), n /= B; int res = 0; // 最终结果 int last = 0; // 一些前缀信息:不用问题含义不一样 for (int i = nums.size() - 1; i \u003e= 0; i--) // 从最高位往最低位枚举 { int x = nums[i]; // 具体计算 // ... if (i == 0 \u0026\u0026 xxxxxx) res += 1; // 特判一下上面图片中最右下角的a0 last = xxx; // 更新 } return res; } int main() { init(); int l, r; cin \u003e\u003e l \u003e\u003e r \u003e\u003e K \u003e\u003e B; cout \u003c\u003c count(r) - count(l - 1) \u003c\u003c endl; } 完整 C++ 代码 #include \u003ciostream\u003e #include \u003cvector\u003e using namespace std; const int N = 15; int dp[N][N]; // f[i,j]表示一共有i位且最高数为j的不降数的个数 void init() { for (int j = 0; j \u003c= 9; j ++) dp[1][j] = 1; for (int i = 2; i \u003c N; i ++) for (int j = 0; j \u003c= 9; j ++) for (int k = j; k \u003c= 9; k++) dp[i][j] += dp[i - 1][k]; } int count(int n) { if (!n) return 1; // 特判边界 vector\u003cint\u003e nums; while (n) nums.push_back(n % 10), n /= 10; int res = 0; // 最终结果 int last = 0; // 一些前缀信息:上一位数是几 for (int i = nums.size() - 1; i \u003e= 0; i--) // 从最高位往最低位枚举 { int x = nums[i]; for (int j = last; j \u003c x; j ++) // 处理左分支 res += dp[i + 1][j]; if (x \u003c last) break; // 处理右分支 if (i == 0) res ++; last = x; } return res; } int main() { init(); int l, r; while (cin \u003e\u003e l \u003e\u003e r) cout \u003c\u003c count(r) - count(l - 1) \u003c\u003c endl; return 0; } ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:47:2","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"记忆化搜索 ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:48:0","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"AcWing 901. 滑雪 题目描述 ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:48:1","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"901. 滑雪 给定一个 $R$ 行 $C$ 列的矩阵，表示一个矩形网格滑雪场。 矩阵中第 $i$ 行第 $j$ 列的点表示滑雪场的第 $i$ 行第 $j$ 列区域的高度。 一个人从滑雪场中的某个区域内出发，每次可以向上下左右任意一个方向滑动一个单位距离。 当然，一个人能够滑动到某相邻区域的前提是该区域的高度低于自己目前所在区域的高度。 下面给出一个矩阵作为例子： 1 2 3 4 5 16 17 18 19 6 15 24 25 20 7 14 23 22 21 8 13 12 11 10 9 在给定矩阵中，一条可行的滑行轨迹为 $24−17−2−1$。 在给定矩阵中，最长的滑行轨迹为 $25−24−23−…−3−2−1$，沿途共经过 $25$ 个区域。 现在给定你一个二维矩阵表示滑雪场各区域的高度，请你找出在该滑雪场中能够完成的最长滑雪轨迹，并输出其长度(可经过最大区域数)。 输入格式 第一行包含两个整数 $R$ 和 $C$。 接下来 $R$ 行，每行包含 $C$ 个整数，表示完整的二维矩阵。 输出格式 输出一个整数，表示可完成的最长滑雪长度。 数据范围 $1≤R,C≤300$, $0≤$矩阵中整数$≤10000$ 输入样例： 5 5 1 2 3 4 5 16 17 18 19 6 15 24 25 20 7 14 23 22 21 8 13 12 11 10 9 输出样例： 25 算法设计 此题是记忆化搜索的一道模板题，这道题用常规的迭代式 dp 写法，会发现状态转移不好写，也就是所有状态的起点不知道在哪。 当遇到这种情况或者循环太复杂如 $f_{i,j,k,m,n}$，常规情况需要写五层循环转移状态，会发现很不好写，如果用记忆化搜索来写会发现会很容易翻译成代码。记忆化搜索其实就是递归式的 dp 写法。 完整 C++ 代码 #include \u003ciostream\u003e #include \u003ccstring\u003e using namespace std; const int N = 310; int n, m; int w[N][N], dp[N][N]; int dx[4] = {-1, 0, 1, 0}, dy[4] = {0, 1, 0, -1}; int dfs(int x, int y) { int \u0026v = dp[x][y]; if (v == -1) return v; // 说明还没走过这个状态 v = 1; // v可以只走当前格子，就是1 for (int i = 0; i \u003c 4; i++) { int a = x + dx[i]; int b = y + dy[i]; if (a \u003e= 1 \u0026\u0026 a \u003c= n \u0026\u0026 b \u003e= 1 \u0026\u0026 b \u003c= m \u0026\u0026 w[x][y] \u003c w[a][b]) v = max(v, dfs(a, b) + 1); } return v; } int main() { cin \u003e\u003e n \u003e\u003e m; for (int i = 1; i \u003c= n; i++) for (int j = 1; j \u003c= m; j++) cin \u003e\u003e w[i][j]; memset(dp, -1, sizeof dp); // 首先把每个状态初始化为-1，表示未被算过 int res = 0; for (int i = 1; i \u003c= n; i++) for (int j = 1; j \u003c= m; j++) res = max(res, dfs(i, j)); cout \u003c\u003c res \u003c\u003c endl; return 0; } 第六章 贪心 ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:48:2","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"区间问题 ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:49:0","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"AcWing 905. 区间选点 题目描述 ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:49:1","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"905. 区间选点 给定 $N$ 个闭区间 $[a_i,b_i]$，请你在数轴上选择尽量少的点，使得每个区间内至少包含一个选出的点。 输出选择的点的最小数量。 位于区间端点上的点也算作区间内。 输入格式 第一行包含整数 $N$，表示区间数。 接下来 $N$ 行，每行包含两个整数 $a_i,b_i$，表示一个区间的两个端点。 输出格式 输出一个整数，表示所需的点的最小数量。 数据范围 $1≤N≤10^5,$ $−10^9≤a_i≤b_i≤10^9$ 输入样例： 3 -1 1 2 4 3 5 输出样例： 2 算法设计 贪心问题一般有一个很简单的套路：通过每一步选取局部最优，最终得到的就是全局最优。然后我们只需要去证明这个做法得到的是最优解就可以了。 我们可以通过构造一个特殊的情况，在这种情况下也得满足最优，所以我们可以先从这种情况下的局部最优出发，寻找猜想。 y总在视频中点评认为贪心题目是难度最变态的算法题了 首先我们来考虑一个比较极端的情况，如果要求下图三个区间的最少点： 对于这种情况，很明显，这三个区间只需要选出图中 $a$ 这个一个点即可，这就是所谓的局部最优，然后这个局部最优位于区间的右端点，很明显如果只有这三个区间，那么最优解一定在区间右端，所以做法中一定要选取右端点。所以我们大胆猜想，小心论证。 本题猜想做法如下： 首先将所有区间按右端排序。 遍历区间，若当前区间还未有选出的点，就选区间右端作为点。 下面只需要证明这个做法是最优解： 首先由于我们的做法肯定是一种合法方案，下面利用反证法证明：如果我们的做法不是最优解，那么我们构造两个区间来讨论。 如果这两个区间有交点，那么我们做法只需要一个点就可以满足条件，已经是最优了。 如果这两个区间没交点，那么按照我的做法需要两个点才可以满足条件，但是理论上不可能有小于两个点的做法，所以我们的做法得出来的点数一定小于等于最优解。 所以综上所述，我们的贪心做法就是最优解。 完整 C++ 代码 #include \u003ciostream\u003e #include \u003calgorithm\u003e using namespace std; typedef pair\u003cint, int\u003e PII; const int N = 100010, INF = 0x3f3f3f3f; PII a[N]; int ans; int main() { int n; cin \u003e\u003e n; for (int i = 0; i \u003c n; i ++) cin \u003e\u003e a[i].first \u003e\u003e a[i].second; sort(a, a + n, [](const PII \u0026a, const PII \u0026b) { return a.second \u003c b.second; // 使用 lambda 函数根据 second 排序 }); int r = -INF; for (int i = 0; i \u003c n; i ++) { if (a[i].first \u003e r) { ans ++; r = a[i].second; } } cout \u003c\u003c ans \u003c\u003c endl; return 0; } ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:49:2","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"AcWing 906. 区间分组 题目描述 ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:49:3","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"906. 区间分组 给定 $N$ 个闭区间 $[a_i,b_i]$，请你将这些区间分成若干组，使得每组内部的区间两两之间（包括端点）没有交集，并使得组数尽可能小。 输出最小组数。 输入格式 第一行包含整数 $N$，表示区间数。 接下来 $N$ 行，每行包含两个整数 $a_i,b_i$，表示一个区间的两个端点。 输出格式 输出一个整数，表示最小组数。 数据范围 $1≤N≤10^5,$ $−10^9≤a_i≤b_i≤10^9$ 输入样例： 3 -1 1 2 4 3 5 输出样例： 2 算法设计 这题一开始的想法很简单，既然是贪心，那我就套用 AcWing 908. 最大不相交区间数量 的做法，使用局部最优的思想，首先在所有区间上找到最大不相交区间，然后把这部分区间删除，再在剩余区间上重复上面操作，最后的最大不相交区间就是重复上面操作最终将所有区间都删除的操作次数。 但是 $\\text{unluckily}$，上面的贪心做法不是最优解，下面我给出一组反例： $[1,3],[1,4],[5,6],[4,7]$。 对于上面的情况来说，算法得到的结果是 $3$，但是显然我们可以找到数量为 $2$ 的分组。 当然收录的这道题，我们有非常经典的贪心做法，需要记住： 首先将所有组按左端点从小到大排序 从前往后处理每一个区间，记当前区间的左端点为 $L$，每个组的右端点的最大值为 $M_r$，判断是否能放到某个组中（$L \u003e M_r$) 如果存在这样的组，随便挑一个组将他放进去，并更新当前组的 $M_r$（这里可以用堆来维护所有组的最小值） 如果不存在这样的组，就 $\\text{new}$ 一个组，再将其放进去，并更新此时的 $M_r$ 下面我们给出上面贪心做法是最优解的证明： 还是反证法：我们假设在处理第 $i$ 个区间时，我们的贪心做法和最优解产生了分歧，若此时我们已经有 $j$ 个组，此时按照我们的贪心做法需要再开一个新的组，但是最优解其实可以继续把这个区间放进前面的组中。对于这种情况下，显然，根据我们的做法可知：当前区间一定都和这 $j$ 个组中的区间有交集，也即存在至少 $j+1$ 个区间存在交集，所以至少需要 $j+1$ 个组才能满足题意，所以可以继续把这个区间放进前面的组中的最优解不存在。 综上所述，证明完毕。 理解了上面的做法，其实就可以把它翻译成代码了，y总的常规做法需要使用一个小根堆来加速每次对于 $L$ 和 $M_r$ 大小的比对，下面我们介绍一篇题解分享中的更快更简洁的优美解法： 大家可以把这个问题想象成活动安排问题 有若干个活动，第i个活动开始时间和结束时间是 $[s_i,f_i]$，同一个教室安排的活动之间不能交叠，求要安排所有活动，至少需要几个教室？ 有时间冲突的活动不能安排在同一间教室，与该问题的限制条件相同，即最小需要的教室个数即为该题答案。 我们可以把所有开始时间和结束时间排序，一个活动开始时，分配一间教室，一个活动结束时，释放一间教室，这样所需的教室数量上下浮动，而浮动过程中的最大值就是所需教室数量的最小值 没结束就不释放，结束了就把对应的教室释放，不用管释放的是哪一间教室 这种解法的思想其实也是可以理解为按照我们上面的做法做的，这里的每间教室就对应了每一组。 完整 C++ 代码 暴力解法代码： #include \u003ciostream\u003e #include \u003calgorithm\u003e #include \u003cqueue\u003e using namespace std; const int N = 100010; int n; struct Range { int l, r; bool operator\u003c (const Range \u0026w)const // 因为要排序，所以重载一下小于号 { return l \u003c w.l; } }range[N]; int main() { int n; cin \u003e\u003e n; for (int i = 0; i \u003c n; i ++) { int l, r; cin \u003e\u003e l \u003e\u003e r; range[i] = {l ,r}; } sort(range, range + n); priority_queue\u003cint, vector\u003cint\u003e, greater\u003cint\u003e\u003e heap; // 用堆来判断是否能放到某个组中 for (int i = 0; i \u003c n; i ++) { if (heap.empty() || heap.top() \u003e= range[i].l) // 不能放：需要开新组 heap.push(range[i].r); else // 可以放：直接把他放到最小值组里面去 { int t = heap.top(); heap.pop(); heap.push(range[i].r); } } cout \u003c\u003c heap.size() \u003c\u003c endl; return 0; } 优美解法代码： #include \u003ciostream\u003e #include \u003ccstring\u003e #include \u003calgorithm\u003e using namespace std; const int N = 100010; int a[N], b[N]; int ans, cnt; int main() { int n; cin \u003e\u003e n; for (int i = 0; i \u003c n; i ++) cin \u003e\u003e a[i] \u003e\u003e b[i]; sort(a, a + n), sort(b, b + n); // 分别对左右端点进行排序 for (int i = 0, j = 0; i \u003c n; ) // 归并排序的思想 { if (a[i] \u003c= b[j]) // 这里取等号是因为有交点的也不能被放在同一个组里 cnt ++, i ++; else cnt --, j ++; ans = max(ans, cnt)； } cout \u003c\u003c ans \u003c\u003c endl; return 0; } ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:49:4","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"推公式 ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:50:0","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"AcWing 125. 耍杂技的牛 题目描述 ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:50:1","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"125. 耍杂技的牛 农民约翰的 $N$ 头奶牛（编号为 $1\\dots N$）计划逃跑并加入马戏团，为此它们决定练习表演杂技。 奶牛们不是非常有创意，只提出了一个杂技表演： 叠罗汉，表演时，奶牛们站在彼此的身上，形成一个高高的垂直堆叠。 奶牛们正在试图找到自己在这个堆叠中应该所处的位置顺序。 这 $N$ 头奶牛中的每一头都有着自己的重量 $W_i$ 以及自己的强壮程度 $S_i$。 一头牛支撑不住的可能性取决于它头上所有牛的总重量（不包括它自己）减去它的身体强壮程度的值，现在称该数值为风险值，风险值越大，这只牛撑不住的可能性越高。 您的任务是确定奶牛的排序，使得所有奶牛的风险值中的最大值尽可能的小。 输入格式 第一行输入整数 $N$，表示奶牛数量。 接下来 $N$ 行，每行输入两个整数，表示牛的重量和强壮程度，第 $i$ 行表示第 $i$ 头牛的重量 $W_i$ 以及它的强壮程度 $S_i$。 输出格式 输出一个整数，表示最大风险值的最小可能值。 数据范围 $1≤N≤50000$, $1≤W_i≤10,000$, $1≤S_i≤1,000,000,000$ 输入样例： 3 10 3 2 5 3 3 输出样例： 2 算法设计 我们首先将牛进行堆叠，从上往下进行依次编号，定义第 $i$ 头牛的重量为 $W_i$，强壮程度为 $S_i$。 牛 风险值 $i$ $\\sum_{j=1}^{i-1} w_j - s_i$ $i+1$ $\\sum_{j=1}^{i} w_j - s_{i+1}$ 我们假设需要交换这两个才能得到最优解，即： 牛 交换前风险值 交换后风险值 $i$ $\\sum_{j=1}^{i-1} w_j - s_i$ $\\sum_{j=1}^{i-1} w_j + w_{i+1} - s_i$ $i+1$ $\\sum_{j=1}^{i} w_j - s_{i+1}$ $\\sum_{j=1}^{i-1} w_j - s_{i+1}$ 进一步化简式子得： 牛 交换前风险值 交换后风险值 $i$ $- s_i$ $ w_{i+1} - s_i$ $i+1$ $w_i - s_{i+1}$ $- s_{i+1}$ 首先我们观察到：交换这头牛并不会带来前后其他牛的风险值的变化 $i$ 之前的牛并不涉及牛 $i$ 和 $i+1$ 的重量 $ i $ 之后的牛只涉及到牛 $i$ 和 $i+1$ 的总重量 由于$ w_{i+1} - s_i \u003e s_i$，如果我们使用贪心的思想，假设 $ w_{i+1} - s_i\u003ew_i - s_{i+1}$，此时交换后的牛 $i$ 的风险值同时大于交换前的牛 $i$ 和 $i+1$ 的风险值，那么交换后的风险值的最大值肯定大于交换前，所以此时我们不应该交换。 通过等价变换，原不等式 $ w_{i+1} - s_i\u003ew_i - s_{i+1}$ 可改写为 $w_{i+1} +s_{i+1}\u003ew_i + s_i $。 由此可得只需要满足：如果将牛按照 $w_i + s_i $ 排序后堆叠，小的值在上面，即可使得所有牛的风险值中的最大值尽可能的小。 下面我们对上面的结论进行证明： 假设我们贪心得到的做法不是最优解，那么将牛进行堆叠，一定存在某一次操作，最优解是需要将更小的 $w_i + s_i $ 堆在更大的 $w_{i+1} +s_{i+1}$ 下面，那么如果此时我们将牛 $i$ 和 $i+1$ 进行交换，那么由之前的证明可知，一定会增加这两头牛的风险值中的最大值，那么此时最优解得到的最大值一定大于我们贪心得到的最大值，故与最优解的定义矛盾。 综上可得将牛按照 $w_i + s_i $ 排序后堆叠是最优解。 完整 C++ 代码 #include \u003ciostream\u003e #include \u003calgorithm\u003e using namespace std; typedef pair\u003cint, int\u003e PII; const int N = 50010; PII cow[N]; int main() { int n; cin \u003e\u003e n; for (int i = 0; i \u003c n; i++) { int w, s; cin \u003e\u003e w \u003e\u003e s; cow[i] = {w + s, s}; } sort(cow, cow + n); // 可以用反证法证明所有牛按照w+s从小到大排序来安排是最优解 int sum = 0; int res = -1e9; for (int i = 0; i \u003c n; i++) { res = max(res, sum - cow[i].second); sum += cow[i].first - cow[i].second; } cout \u003c\u003c res \u003c\u003c endl; return 0; } 第七章 时空复杂度分析 ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:50:2","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"由数据范围反推算法复杂度以及算法内容 一般 $\\text{ACM}$ 或者笔试题的时间限制是 $1$ 秒或 $2$ 秒， 在这种情况下，$\\text{C}$++ 代码中的操作次数控制在 $10^7 \\sim 10^8$ 为最佳。 下面给出在不同数据范围下，代码的时间复杂度和算法该如何选择: $n \\le 30$,指数级别,dfs+剪枝，状态压缩dp $n \\le 10^2 =\u003eO(n^3)$，floyd，dp，高斯消元 $n \\le 10^3 =\u003e O(n^2)$，$O(n^2log n)$，dp，二分，朴素版Dikstra、朴素版Prim、Bellman-Ford $n \\le 10^4 =\u003e O(n\\sqrt{n})$，块状链表、分块、莫队 $n \\le 10^5 =\u003eO(nlogn)=\u003e$各种sort，线段树、树状数组、setmap、heap、拓扑排序、dikstratheap、prim+heap、Kruskal、spfa、求凸包、求半平面交、二分、CDQ分治、整体二分、后缀数组、树链剖分、动态树 $n\\le 10^6 =\u003eO(n)$,以及常数较小的 $O(nlogn)$ 算法 $=\u003e$ 单调队列、hash、双指针扫描、BFS、并查集、kmp、AC自动机，常数比较小的 $O(nlogn)$ 的做法: sort、树状数组、heap、dikstra、spfa $n \\le 10^7 =\u003eO(n)$，双指针扫描、kmp、AC自动机、线性筛素数 $n \\le 10^9=\u003eO(\\sqrt n)$，判断质数 $n \\le 10^{18} =\u003eO(logn)$，最大公约数，快速幂，数位DP $n\\le 10^{1000} =\u003e O((logn)^2)$，高精度加减乘除. $n\\le 10^{100000} =\u003e 0(logk \\ast loglogk)$，$k$表示位数，高精度加减、FFT/NTT 题外话 ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:51:0","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"论递归算法的数学原理 ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:52:0","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"论递归算法的数学原理 作者：yxc , 2022-08-27 17:34:55 , 所有人可见 , 阅读 3646 想必很多同学在接触递归算法的时候都会很困惑，比如归并排序，为什么下面的代码可以将一个序列排好序呢？ 今天突然发现，**递归过程的本质就是数学归纳法！**我们再刨根问底一下，数学归纳法的正确性又源自于什么呢？答案就是：数学归纳法是一个公理，只有满足数学归纳法的数集才是我们平时用到的自然数集！ 所以，递归过程的正确性是个公理！这也是为什么我们对递归很困惑的原因了。 接下来以归并排序为例，我们用数学归纳法来证明其正确性。 首先当序列长度小于等于 $1$ 的时候，序列有序，成立。 假设对于任意序列长度小于 $𝑛$ 的序列，merge_sort(l, r) 都能将序列排好序。 那么我们证明对于任意序列长度等于 $n$ 的序列，merge_sort(l, r)也可以将序列排好序。 我们再来看merge_sort这个函数： 图中红色框起来的部分，根据归纳假设，[l, mid]和[mid + 1, r]的长度都小于 $n$，所以merge_sort函数可以将其排好序。 然后左右两个有序序列，通过二路归并算法，就可以合并成一个有序序列了，因此对于当前长度为 $n$ 的区间，merge_sort也可以将其排好序。证毕。 所以对于任意自然数长度的区间，merge_sort()都可以将其排好序 37 评论 yxc 2022-08-27 17:41 回复 今天突然发现数学归纳法才是算法的根本。DP问题都可以用闫氏DP分析法分析，而闫氏DP分析法的正确性，也是用数学归纳法来证明hh ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:52:1","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"算法竞赛进阶指南 ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:53:0","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"0xFF 前言—如何阅读本书 探究一门学问有单个层次：求其解，知其原因，究其思维之本。也就是所谓的“怎么做” “为什么这么做是对的” “怎样想到这么做的”。 在思维的迷宫里，有的人凭天生的灵感直奔终点；有的人以持久的勤勉，铸造出适合自己的罗盘；有的人迷失了方向，宣告失败。 ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:53:1","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"李煜东知乎回答 算法竞赛的知识迭代非常快（尤其是近几年），我已经很多年不做算法题了，对于加入最新的知识点、更新题库，也实在是力不从心。我觉得日后更新更好的算法竞赛书出来，蓝书自然会被淘汰，一个时代的人写的书只服务于当初那个时代，这也是很正常的事。不过我个人对于如何讲解算法知识，为那些比较困惑的同学指点迷津，还是有一些心得。我在大学期间，感觉很多教授/大神讲课都是自己知道为什么，能跟你讲清楚，但不能告诉你“怎么才能想到这一点”，还是要靠自己去体会。至于如何加速这个体会的过程，这是我写书希望完成的事情。 作者：李煜东 链接：https://www.zhihu.com/question/593371905/answer/2968691334 来源：知乎 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 ","date":"2024-12-09","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/:54:0","tags":["算法","编程"],"title":"算法学习自用板子","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%94%A8%E6%9D%BF%E5%AD%90/"},{"categories":["编程"],"content":"云服务器笔记 阿里云地址 创建工作用户并赋予sudo权限 登录到新服务器。打开Terminal，然后： ssh user@hostname // 例如：ssh lx@66.166.166.166 user: 用户名(如root) hostname: IP地址或域名(如xxx.xxx.xxx.xxx) 第一次登录时会提示： The authenticity of host '66.188.185.66 (66.188.185.66)' can't be established. ED25519 key fingerprint is SHA256:SZfhynS8auEJWvEIyecTGm8m8VeflY1g+s8gzJ88PRI. This key is not known by any other names Are you sure you want to continue connecting (yes/no/[fingerprint])? 输入yes，然后回车即可。 这样会将该服务器的信息记录在~/.ssh/known_hosts文件中。 然后输入密码即可登录到远程服务器中。 默认登录端口号为22。如果想登录某一特定端口： ssh user@hostname -p 22 登录成功后，创建lx用户： adduser lx # 创建用户lx usermod -aG sudo lx # 给用户lx分配sudo权限 切换到lx用户： su lx #切换到lx用户 下次就可以直接ssh到新用户 lx 来登录到您的云服务器（实现多用户使用同一云服务器） 配置别名和免密登录方式 按Ctrl+d或者输入exit退回本地的Terminal，在自己电脑端配置lx用户的别名和免密登录 别名 创建文件 ~/.ssh/config。 然后在文件中输入： Host myserver1 HostName xxx.xxx.xxx.xxx # IP地址或域名 User lx # 用户名 # Port 20000 这里我们没有修改端口号，所以不用加，但是后面的docker连接就需要加了 Host myserver2 HostName xxx.xxx.xxx.xxx # IP地址或域名 User root # 用户名 之后再使用服务器时，可以直接使用别名myserver1、myserver2。 免密登录 本地主机创建密钥： ssh-keygen 然后一直回车即可。 执行结束后，~/.ssh/目录下会多两个文件： id_rsa：私钥 id_rsa.pub：公钥 之后想免密码登录哪个服务器，就将公钥传给哪个服务器即可。 例如，想免密登录myserver1服务器。则将公钥中的内容，复制到myserver1中的~/.ssh/authorized_keys文件里即可。 也可以使用如下命令一键添加公钥到服务器端： ssh-copy-id myserver1 简易安全配置 查看登录日志文件 sudo vim /var/log/auth.log 不出意外会看到很多类似如下的日志 Failed password for root from 183.146.30.163 port 22537 ssh2 Failed password for invalid user admin from 183.146.30.163 port 22545 ssh2 Invalid user tester from 101.254.217.219 port 56540 pam_unix(sshd:auth): check pass; user unknown pam_unix(sshd:auth): authentication failure; logname= uid=0 euid=0 tty=ssh ruser= rhost=103.61.8.34 然后可以统计有多少人在暴力破解root密码错误登录，展示错误次数和ip sudo grep \"Failed password for root\" /var/log/auth.log | awk '{print $11}' | sort | uniq -c | sort -nr | more 统计有多少暴力猜用户名的 sudo grep \"Failed password for invalid user\" /var/log/auth.log | awk '{print $13}' | sort | uniq -c | sort -nr | more 禁止SSH的root用户登录 修改 /etc/ssh/sshd_config文件 首先创建一下文件的备份 sudo cp /etc/ssh/sshd_config /etc/ssh/sshd_config.bak 禁止以root用户身份通过 SSH 登录 PermitRootLogin no 设置SSH单次登录限制 LogLevel INFO #将LogLevel设置为INFO,记录登录和注销活动 MaxAuthTries 3 #限制单次登录会话的最大身份验证尝试次数 LoginGraceTime 20 #缩短单次的登录宽限期，即ssh登录必须完成身份验证的时间 单位是秒 重启ssh服务 sudo service ssh restart 禁用密码登陆，使用RSA私钥登录 ssh-keygen #在客户端生成密钥 ssh-copy-id myserver1 #将公钥添加至服务端 还需要配置服务端 我们向/etc/ssh/sshd_config写入以下内容： PasswordAuthentication no #禁止密码认证 PermitEmptyPasswords no #禁止空密码用户登录 重启ssh服务 sudo service ssh restart docker配置和语法教程 安装tmux和docker 登录自己的服务器，然后安装tmux： sudo apt-get update sudo apt-get install tmux 将本地配置通过scp传到新服务器上： scp .vimrc .tmux.conf .bashrc server_name: # server_name需要换成自己配置的别名（！！！注意目的地址后面要有冒号：） 打开tmux。(养成好习惯，所有工作都在tmux里进行，防止意外关闭终端后，工作进度丢失) tmux操作小tips：按住shift就可以选择文本，然后Ctrl-insert进行复制，Shift-insert进行粘贴 然后在tmux中根据docker安装教程安装docker即可。 将当前用户添加到docker用户组 为了避免每次使用docker命令都需要加上sudo权限，可以将当前用户加入安装中自动创建的docker用户组(可以参考[官方文档](Post-installation steps | Docker Docs))： sudo usermod -aG docker $USER # 这里USER不用改成lx，因为$USER会自动修改成当前的用户名 执行完此操作后，需要退出服务器，再重新登录回来，才可以省去sudo权限。 镜像（images） docker pull ubuntu:20.04：拉取一个镜像 docker images：列出本地所有镜像 docker image rm ubuntu:20.04 或 docker rmi ubuntu:20.04：删除镜像ubuntu:20.04 docker [container] commit CONTAINER IMAGE_NAME:TAG：创建某个container的镜像 docker save -o ubuntu_20_04.tar ubuntu:20.04：将镜像ubuntu:20.04导出到本地文件ubuntu_20_04.tar中 docker load -i ubuntu_20_04.tar：将镜像ubuntu:20.04从本地文件ubuntu_20_04.tar中加载出来 容器(container) docker [container] create -it ubuntu:20.04：利用镜像ubuntu:20.04创建一个容器 docker ps -a：查看本地的所有容器 docker [container] start CONTAINER：启动容器 docker [container] stop CONTAINER：停止容器 docker [container] restart CONTAINER：重启容器 docker [contaienr] run -itd ubuntu:20.04：创建并启动一个容器 docker [container] attach CONTAINER：进入容器 先按Ctrl-p，再按Ctrl-q可以挂起容器 docker [container] exec CONTAINER COMMAND：在容器中执行命令 docker [container] rm CONTAINER：删除容器 docker container prune：删除所有已停止的容器 docker export -o xxx.tar CONTAINER：将容器CONTAINER导出到本地文件xxx.tar中 docker import xxx.tar image_name:tag：将本地文件xxx.tar导入成镜像，并将镜像命名为image_name:tag docker export/import与docker sav","date":"2024-11-12","objectID":"/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AC%94%E8%AE%B0/:1:0","tags":["编程"],"title":"云服务器笔记","uri":"/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AC%94%E8%AE%B0/"},{"categories":["编程"],"content":"tmux语法 ","date":"2024-11-11","objectID":"/tmux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:1:0","tags":["编程"],"title":"tmux常用命令","uri":"/tmux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["编程"],"content":"功能： 分屏。 允许断开Terminal连接后，继续运行进程。 ","date":"2024-11-11","objectID":"/tmux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:1:1","tags":["编程"],"title":"tmux常用命令","uri":"/tmux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["编程"],"content":"结构： 一个tmux可以包含多个session，一个session可以包含多个window，一个window可以包含多个pane。 类似于下面的逻辑： tmux: session 0: window 0: pane 0 pane 1 pane 2 ... window 1 window 2 ... session 1 session 2 ... ","date":"2024-11-11","objectID":"/tmux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:1:2","tags":["编程"],"title":"tmux常用命令","uri":"/tmux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["编程"],"content":"操作： 我大概按照自己的使用频率，从高到底列举了大部分日常使用中用到的操作： (1) tmux：新建一个session，其中包含一个window，window中包含一个pane，pane里打开了一个shell对话框。 (2) tmux a：打开之前挂起的session。 (3) 按下ctrl + a后手指松开，然后按d：挂起当前session。 (4) Ctrl + d：关闭当前pane；如果当前window的所有pane均已关闭，则自动关闭window；如果当前session的所有window均已关闭，则自动关闭session。（按下Ctrl + a 后手指松开，然后按 x 也可以实现关闭pane的效果） (5) 按下Ctrl + a后手指松开，然后按%：将当前pane左右平分成两个pane。 (6) 按下Ctrl + a后手指松开，然后按\"（注意是双引号\"）：将当前pane上下平分成两个pane。 (7) 鼠标点击可以选pane。 (8) 鼠标拖动pane之间的分割线，可以调整分割线的位置。 (9) 按下ctrl + a后手指松开，然后按z：将当前pane全屏/取消全屏。 (10) 在tmux中选中文本时，需要按住shift键。（仅支持Windows和Linux，不支持Mac，不过该操作并不是必须的，因此影响不大） (11) tmux中复制/粘贴文本的通用方式（需要提前按住shift键进行选中文本）： 复制：Ctrl+Insert 粘贴：Shift+Insert (12) 按下ctrl + a后手指松开，然后按方向键：选择相邻的pane。 (13) 按住ctrl + a的同时按方向键，可以调整pane之间分割线的位置。 (14) 按下ctrl + a后手指松开，然后按s：选择其它session。 方向键 —— 上：选择上一项 session/window/pane 方向键 —— 下：选择下一项 session/window/pane 方向键 —— 右：展开当前项 session/window 方向键 —— 左：闭合当前项 session/window (15) 按下Ctrl + a后手指松开，然后按c：在当前session中创建一个新的window。 (16) 按下Ctrl + a后手指松开，然后按w：选择其他window，操作方法与(12)完全相同。 (17) 按下Ctrl + a后手指松开，然后按PageUp：翻阅当前pane内的内容。 (18) 鼠标滚轮：翻阅当前pane内的内容。 有时候会突然遇到屏幕被限制在了一个很小的范围内，其他的地方全部变成了点 “.”,这是因为用不同的电脑或者终端打开过同一窗口，导致分辨率不一致，可以通过命令tmux a -d -t [YOUR TMUX NAME]来进入tmux ","date":"2024-11-11","objectID":"/tmux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:1:3","tags":["编程"],"title":"tmux常用命令","uri":"/tmux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["编程"],"content":"vim语法 功能： (1) 命令行模式下的文本编辑器。 (2) 根据文件扩展名自动判别编程语言。支持代码缩进、代码高亮等功能。 (3) 使用方式：vim filename ​ 如果已有该文件，则打开它。 ​ 如果没有该文件，则打开个一个新的文件，并命名为filename 模式： (1) 一般命令模式 ​ 默认模式。命令输入方式：类似于打游戏放技能，按不同字符，即可进行不同操作。可以复制、粘贴、删除文本等。 (2) 编辑模式 ​ 在一般命令模式里按下i，会进入编辑模式。 ​ 按下ESC会退出编辑模式，返回到一般命令模式。 (3) 命令行模式 ​ 在一般命令模式里按下:/?三个字母中的任意一个，会进入命令行模式。命令行在最下面。 ​ 可以查找、替换、保存、退出、配置编辑器等。 操作： (1) i：进入编辑模式 (2) ESC：进入一般命令模式 (3) h 或 左箭头键：光标向左移动一个字符 (4) j 或 向下箭头：光标向下移动一个字符 (5) k 或 向上箭头：光标向上移动一个字符 (6) l 或 向右箭头：光标向右移动一个字符 (7) n：n表示数字，按下数字后再按空格，光标会向右移动这一行的n个字符 (8) 0 或 功能键[Home]：光标移动到本行开头 (9) $或 功能键[End]：光标移动到本行末尾 (10) G：光标移动到最后一行 (11) :n 或 nG：n为数字，光标移动到第n行 (12) gg：光标移动到第一行，相当于1G (13) n：n为数字，光标向下移动n行 (14) /word：向光标之下寻找第一个值为word的字符串。 (15) ?word：向光标之上寻找第一个值为word的字符串。 (16) n：重复前一个查找操作 (17) N：反向重复前一个查找操作 (18) :n1,n2s/word1/word2/g：n1与n2为数字，在第n1行与n2行之间寻找word1这个字符串，并将该字符串替换为word2 (19) :1,$s/word1/word2/g：将全文的word1替换为word2 (20) :1,$s/word1/word2/gc：将全文的word1替换为word2，且在替换前要求用户确认。 (21) v：选中文本 (22) d：删除选中的文本 (23) dd: 删除当前行 (24) y：复制选中的文本 (25) yy: 复制当前行 (26) p: 将复制的数据在光标的下一行/下一个位置粘贴 (27) u：撤销 (28) Ctrl + r：取消撤销 (29) 大于号 \u003e：将选中的文本整体向右缩进一次 (30) 小于号 \u003c：将选中的文本整体向左缩进一次 (31) :w 保存 (32) :w! 强制保存 (33) :q 退出 (34) :q! 强制退出 (35) :wq 保存并退出 (36) :set paste 设置成粘贴模式，取消代码自动缩进 (37) :set nopaste 取消粘贴模式，开启代码自动缩进 (38) :set nu 显示行号 (39) :set nonu 隐藏行号 (40) gg=G：将全文代码格式化 (41) :noh 关闭查找关键词高亮 (42) Ctrl + q：当vim卡死时，可以取消当前正在执行的命令 异常处理： 每次用vim编辑文件时，会自动创建一个.filename.swp的临时文件。 如果打开某个文件时，该文件的swp文件已存在，则会报错。此时解决办法有两种： ​ (1) 找到正在打开该文件的程序，并退出 ​ (2) 直接删掉该swp文件即可 ","date":"2024-11-11","objectID":"/vim%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:1:0","tags":["编程"],"title":"vim常用命令","uri":"/vim%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["编程"],"content":"机器学习常用命令 使用conda作为包管理器 环境管理 1.conda env list：列出所有环境 2.conda activate \u003c环境名称\u003e：激活该环境 3.conda create -n \u003c环境名称\u003e python=\u003c版本\u003e：创建新环境 包管理 1.conda list：列出环境中的所有包 2.conda install \u003c包名\u003e：安装包 3.conda update \u003c包名\u003e：更新包 4.conda remove \u003c包名\u003e：删除包 ","date":"2024-10-30","objectID":"/conda%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%8C%85%E7%AE%A1%E7%90%86%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:1:0","tags":["编程"],"title":"conda机器学习常用命令","uri":"/conda%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%8C%85%E7%AE%A1%E7%90%86%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["编程"],"content":"找到正在使用的主题CSS文件（例如 gitHub.css),下面是我从acwing网站上源代码分析爬取下来的关于单行代码渲染的css样式，直接在刚刚找到的css文件的底部，添加下面的样式即可： /* 自定义 code 标签的样式 */ code { background-color: #f8f8f8; color: #c7254e; /* 设为红色 */ padding: 0 5px; border: 1px solid #eaeaea; font-family: Menlo, Monaco, Consolas, \"Courier New\", monospace; border-radius: 3px; white-space: nowrap; } 下面是我从csdn爬下来的，感觉更紧凑一点，和y总的区别也不算大 /* 自定义 code 标签的样式 */ code { background-color: #F9F2F4; /* 背景颜色 */ color: #C7254E; /* 字体颜色 */ padding: 2px 4px; /* 内边距，符合图片的 2px 4px */ font-size: 10px; /* 字体大小 */ font-family: \"Source Code Pro\", \"comic code\", \"DejaVu Sans Mono\", Menlo, Monaco, Consolas, \"Courier New\", monospace; /* 字体设置 */ border-radius: 3px; /* 边框圆角 */ white-space: nowrap; /* 防止换行 */ border: none; /* 去除边框 */ } ","date":"2024-10-28","objectID":"/y%E6%80%BBacwing%E7%BD%91%E7%AB%99markdown%E6%B8%B2%E6%9F%93%E6%A0%B7%E5%BC%8F/:0:0","tags":["编程"],"title":"y总acwing网站markdown渲染样式","uri":"/y%E6%80%BBacwing%E7%BD%91%E7%AB%99markdown%E6%B8%B2%E6%9F%93%E6%A0%B7%E5%BC%8F/"},{"categories":["自我提升"],"content":"泡芙方专注力课程练习合集整理版 顺序是按照课程中提到的练习顺序整理 总原则：使用呼吸法进行高效休息，进入α脑波状态，正念冥想用来修复我们的前额叶 1.四象限法：每天晚上回忆并分类自己的任务 2.超级专注模式四步法：每天至少两个小时学习的时候完全觉察这四步 3.生活上的调整：清醒的时间，每小时设定一次闹铃振动，回顾这个小时做了什么，画出图形 4.开启超级专注：每天开始至少一个小时的超级专注 5.评估四类分心事物：每天早上预估自己可能有什么分心的事情，写在四象限里 6.手机暗示法：使用手机前就心里给自己一个暗示：“这是一台电脑” 7.删除无用软件：使用两台设备，一台专门用来娱乐，另一台专心工作 8.会议觉察法：当必须参加一个会议时，练习使用超级专注力：有觉察的听话，一句提取一个意思。 9.\"申请\"使用网络：有意识的申请明天什么失手使用网络，其余时间使用飞行模式。 10.犹太法：效仿犹太人习俗，固定抽出一天时间，尝试24小时不连接网络（电脑，手机，ipad） 11.釜底抽薪法：每次发现一个让人分心的事物，只去掉一个，不一下子全去掉因为太困难 12.TODO list法: 设置周任务，每天只需要从周任务中取出分配任务。升级法：有需要甚至可以制作分心清单和担忧清单，准备一个玻璃杯，每次把担忧的事情写下来扔进杯子里就相当于告诉自己放下了 13.自测法：番茄工作法的工作时间不适合每个人，应该对自己做一个测试，分布在每天的不同时间段的一次专注时长，一周不同天的同一时间段的一次专注时长 14.腹式呼吸法：练习使用腹式呼吸 15.平地走路呼吸法：行走时吸气呼气比例为1 ：2,如吸气同时走2步，呼气同时走4步，当然也可以3步吸4步呼，只要不要吸气比呼气长就可以 16.身心合一呼吸法：呼吸时感知全身 17.冰人呼吸法：效仿极限运动员“冰人”的呼吸法 18.呼吸法调整α脑波：首先先全身放松，呼气的时候放松紧绷的部位，然后吸气-屏气-呼气-屏气节拍，都是4节拍，通过不断练习逐步过渡到6节拍，再渐渐到8节拍 19.身体放松法调整α脑波：对身体进行放松 20.环境想象法调整α脑波：回忆以前看到过的最美好的自然环境（所以要多旅游） 21.意念调整α脑波法：通过想象人脑释放α波的生理特征来反向刺激引导出α波 22.组合调整α脑波法：找到一个组合法，调配最适合自己的α脑波诱导体系，并养成习惯，如呼吸法+意念调整法 23.分散模式法：三种分散模式的进入方法：习惯式，解决问题式，头脑风暴式 24.身体专注法 25.感觉专注法 26.头脑范围专注法 27.头脑事务专注法 28.空专注法 29.运动专注法 30.无聊练习法：增加正念冥想\"桩子\" 31.记忆字符串法：使用记忆宫殿进行左右脑协调，无聊的时候如上下楼时可以试着在脑海中漫步一圈自己的记忆宫殿 32.速听和速读法：速读三要点：去除音读，减少眼停，去除回读 33.有意识的专注于读书：一般1-2页上用十个字以内标注一个共鸣点并且标下页码；读25min，休息5min；休息之前花一分钟快速看看和回忆一下之前的标注点；读完一章节后把本章笔记整体回忆一遍(35min)，然后休息15min(用呼吸法恢复精力)。一般一天(810h)可以非常扎实的读1本书。基本上可以达到完整复述的程度 34.极限版英文备考：听力：核心是用耳朵背单词，听写虽然无聊但是是最有效的方法，很多人单词会背了但是别人读出来又听不懂就是因为没有用耳朵背单词。听一句写一句，写大概20个单词左右和原文对比，找出没有听出来的部分，然后重新听原文3-5遍，用耳朵把没有听出来的单词短语”背“下来，听完一大段(100300词)重复反复听和倍速听，定期复习。口语：总结在听力中反复出现的句型，提炼出句型模板，总结成册，用句型疯狂造句1020句，定期复习。 35.闭关式思考和创造：如果有条件最好去一个远离世俗的地方 36.不同的专注策略：每几年分别一年超级专注(美国终生教授之后每七年会有一年放假，但是这种太奢侈了，大部分普通人没有必要，而且很可能一下子浪费掉)；每年季度性的超级专注(利用长的法定假期)；每周分别14天超级专注；每天早晨/晚上超级专注(适合新手，甚至有人每天固定2h使用56年时间读了个phd)；随时超级专注(每当有20min以上时间就躲起来，不太适合新手)；混合超级专注模式(对于学生：暑假进行长时间专注，每周2天超级专注，每天早起两小时超级专注) 37.设计随身携带的\"专注屋\"： 99. 音乐法：原则上不建议学习听音乐，但是可以在每天学习很累了之后如晚上通过音乐来让自己可以继续坐在椅子上。但是音乐选取有三个原则：自己熟悉的音乐，调子简单，无歌词。 ","date":"2024-10-26","objectID":"/%E6%B3%A1%E8%8A%99%E6%96%B9%E4%B8%93%E6%B3%A8%E5%8A%9B%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/:1:0","tags":["专注力"],"title":"泡芙方专注力课程练习合集整理版","uri":"/%E6%B3%A1%E8%8A%99%E6%96%B9%E4%B8%93%E6%B3%A8%E5%8A%9B%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"},{"categories":["编程"],"content":"Markdown语法 1.标题 # +一级标题：#后要有空格 ## + 二级标题 2.代码段 ` `：反引号（`）中插入一行代码 ``` ```：三个反引号（）中插入一段代码,注：```后可加语言类型，如 ```css 3.加粗 ** **：语句前后各添加两个星号 4.斜体 * *： 语句前后各添加一个星号 5.换行 \u003cbr/\u003e：使用HTML的br标签来实现换行 6.转义 \\+需要转义的字符 7.网址链接 [name](url)：[我的个人主页](https://lxxinli.github.io)我的个人主页 8.分隔线 ---或***：在当前行的下方插入一条分隔线 9.列表 * List 或- List ： List 1. One One 10. 块注释 \u003e 11. LaTeX语法 LaTeX符号大全 LaTeX LaTeX 代码 说明 $n^2$ $n^2$ $n^{100}$ $n^{100}$ $x_i$ $x_i$ $\\text{x}$ $\\text{x}$ $\\le$ $\\le$ $\\ge$ $\\ge$ $\\ne$ $\\ne$ $\\times$ $\\times$ $\\ast$ $\\ast$ $\\sqrt{x}$ $\\sqrt{x}$ $\\sqrt[n]{x}$ $\\sqrt[n]{x}$ 空格 $\\ $ 如$a \\ b$ $\\gets$ $\\gets$ $\\to$ $\\to$ $\\Rightarrow$ $\\Rightarrow$ $\\begin{cases} x = 1 \\ y = 1 \\end{cases} $ $\\begin{cases} x = 1 \\\\ y = 1 \\end{cases} $ $\\sum_{k=1}^N k^2$ $\\sum_{k=1}^N k^2$ 行内公式 $\\dots$ $\\dots$ ∼ 特殊符号直接复制 $\\frac {n} {2}$ $\\frac {n} {2}$ ","date":"2024-10-25","objectID":"/markdown%E8%AF%AD%E6%B3%95/:1:0","tags":["编程"],"title":"Markdown语法","uri":"/markdown%E8%AF%AD%E6%B3%95/"},{"categories":null,"content":" \u003c!DOCTYPE html\u003e DeepThought | 自学空间 系统正在维护中 我们正在码不停键中，很快回来，请耐心等待。 刷新页面 需要帮助 © 2025 DeepThought | 自学空间 ","date":"0001-01-01","objectID":"/about/:0:0","tags":null,"title":"","uri":"/about/"}]