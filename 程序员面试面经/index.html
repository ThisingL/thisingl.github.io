<!DOCTYPE html>
<html lang="zh-CN">
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="robots" content="noodp" />
        <title>程序员面试面经 - Thising&#39;log | 自学空间</title><meta name="Description" content="Hugo theme - LoveIt"><meta property="og:url" content="https://example.com/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%9D%A2%E7%BB%8F/">
  <meta property="og:site_name" content="Thising&#39;log | 自学空间">
  <meta property="og:title" content="程序员面试面经">
  <meta property="og:description" content="自己在找实习和秋招期间准备的面经总结，包含高频面经考点和实际面试中遇到的题目，还在更新中…">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2026-01-25T23:58:20+08:00">
    <meta property="article:modified_time" content="2026-01-26T13:26:15+08:00">
    <meta property="article:tag" content="编程">
    <meta property="og:image" content="https://example.com/images/logo.png">

  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:image" content="https://example.com/images/logo.png">
  <meta name="twitter:title" content="程序员面试面经">
  <meta name="twitter:description" content="自己在找实习和秋招期间准备的面经总结，包含高频面经考点和实际面试中遇到的题目，还在更新中…">
<meta name="application-name" content="LoveIt">
<meta name="apple-mobile-web-app-title" content="LoveIt"><meta name="theme-color" content="#ffffff"><meta name="msapplication-TileColor" content="#da532c"><link rel="icon" href="/images/favicon.ico"><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"><link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5"><link rel="manifest" href="/site.webmanifest"><link rel="canonical" href="https://example.com/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%9D%A2%E7%BB%8F/" /><link rel="prev" href="https://example.com/%E5%BC%80%E5%8F%91%E6%9C%BA%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE/" /><link rel="stylesheet" href="/css/style.min.css"><link rel="preload" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.1/css/all.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
        <noscript><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.1/css/all.min.css"></noscript><link rel="preload" href="https://cdn.jsdelivr.net/npm/animate.css@4.1.1/animate.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
        <noscript><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@4.1.1/animate.min.css"></noscript><meta name="google-site-verification" content="N4cNfssrLiqOu4yaBlJG5PnkRqQqFOMGXVXNkIMTad4" /><script type="application/ld+json">
    {
        "@context": "http://schema.org",
        "@type": "BlogPosting",
        "headline": "程序员面试面经",
        "inLanguage": "zh-CN",
        "mainEntityOfPage": {
            "@type": "WebPage",
            "@id": "https:\/\/example.com\/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%9D%A2%E7%BB%8F\/"
        },"image": [{
                            "@type": "ImageObject",
                            "url": "https:\/\/example.com\/images\/Apple-Devices-Preview.png",
                            "width":  3200 ,
                            "height":  2048 
                        }],"genre": "posts","keywords": "编程","wordcount":  34403 ,
        "url": "https:\/\/example.com\/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%9D%A2%E7%BB%8F\/","datePublished": "2026-01-25T23:58:20+08:00","dateModified": "2026-01-26T13:26:15+08:00","license": "This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.","publisher": {
            "@type": "Organization",
            "name": "Thising","logo": "https:\/\/example.com\/images\/logo.png"},"author": {
                "@type": "Person",
                "name": "Thising"
            },"description": ""
    }
    </script></head>
    <body data-header-desktop="fixed" data-header-mobile="auto"><script type="text/javascript">(window.localStorage && localStorage.getItem('theme') ? localStorage.getItem('theme') === 'dark' : ('auto' === 'auto' ? window.matchMedia('(prefers-color-scheme: dark)').matches : 'auto' === 'dark')) && document.body.setAttribute('theme', 'dark');</script>

        <div id="mask"></div><div class="wrapper"><header class="desktop" id="header-desktop">
    <div class="header-wrapper">
        <div class="header-title">
            <a href="/" title="Thising&#39;log | 自学空间"><span class="header-title-pre"><i class='far fa-kiss-wink-heart fa-fw' aria-hidden='true'></i></span>Thising&#39;log</a>
        </div>
        <div class="menu">
            <div class="menu-inner"><a class="menu-item" href="/posts/"> 所有文章 </a><a class="menu-item" href="/tags/"> 标签 </a><a class="menu-item" href="/categories/"> 分类 </a><a class="menu-item" href="/about/"> 关于 </a><a class="menu-item" href="https://github.com/thisingl/" title="GitHub" rel="noopener noreffer" target="_blank"><i class='fab fa-github fa-fw' aria-hidden='true'></i>  </a><span class="menu-item delimiter"></span><span class="menu-item search" id="search-desktop">
                        <input type="text" placeholder="搜索文章标题或内容..." id="search-input-desktop">
                        <a href="javascript:void(0);" class="search-button search-toggle" id="search-toggle-desktop" title="搜索">
                            <i class="fas fa-search fa-fw" aria-hidden="true"></i>
                        </a>
                        <a href="javascript:void(0);" class="search-button search-clear" id="search-clear-desktop" title="清空">
                            <i class="fas fa-times-circle fa-fw" aria-hidden="true"></i>
                        </a>
                        <span class="search-button search-loading" id="search-loading-desktop">
                            <i class="fas fa-spinner fa-fw fa-spin" aria-hidden="true"></i>
                        </span>
                    </span><a href="javascript:void(0);" class="menu-item theme-switch" title="切换主题">
                    <i class="fas fa-adjust fa-fw" aria-hidden="true"></i>
                </a><a href="javascript:void(0);" class="menu-item language" title="选择语言">
                    <i class="fa fa-globe fa-fw" aria-hidden="true"></i>                      
                    <select class="language-select" id="language-select-desktop" onchange="location = this.value;"><option value="/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%9D%A2%E7%BB%8F/" selected>简体中文</option></select>
                </a></div>
        </div>
    </div>
</header><header class="mobile" id="header-mobile">
    <div class="header-container">
        <div class="header-wrapper">
            <div class="header-title">
                <a href="/" title="Thising&#39;log | 自学空间"><span class="header-title-pre"><i class='far fa-kiss-wink-heart fa-fw' aria-hidden='true'></i></span>Thising&#39;log</a>
            </div>
            <div class="menu-toggle" id="menu-toggle-mobile">
                <span></span><span></span><span></span>
            </div>
        </div>
        <div class="menu" id="menu-mobile"><div class="search-wrapper">
                    <div class="search mobile" id="search-mobile">
                        <input type="text" placeholder="搜索文章标题或内容..." id="search-input-mobile">
                        <a href="javascript:void(0);" class="search-button search-toggle" id="search-toggle-mobile" title="搜索">
                            <i class="fas fa-search fa-fw" aria-hidden="true"></i>
                        </a>
                        <a href="javascript:void(0);" class="search-button search-clear" id="search-clear-mobile" title="清空">
                            <i class="fas fa-times-circle fa-fw" aria-hidden="true"></i>
                        </a>
                        <span class="search-button search-loading" id="search-loading-mobile">
                            <i class="fas fa-spinner fa-fw fa-spin" aria-hidden="true"></i>
                        </span>
                    </div>
                    <a href="javascript:void(0);" class="search-cancel" id="search-cancel-mobile">
                        取消
                    </a>
                </div><a class="menu-item" href="/posts/" title="">所有文章</a><a class="menu-item" href="/tags/" title="">标签</a><a class="menu-item" href="/categories/" title="">分类</a><a class="menu-item" href="/about/" title="">关于</a><a class="menu-item" href="https://github.com/thisingl/" title="GitHub" rel="noopener noreffer" target="_blank"><i class='fab fa-github fa-fw' aria-hidden='true'></i></a><a href="javascript:void(0);" class="menu-item theme-switch" title="切换主题">
                <i class="fas fa-adjust fa-fw" aria-hidden="true"></i>
            </a><a href="javascript:void(0);" class="menu-item" title="选择语言">
                    <i class="fa fa-globe fa-fw" aria-hidden="true"></i>
                    <select class="language-select" onchange="location = this.value;"><option value="/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%9D%A2%E7%BB%8F/" selected>简体中文</option></select>
                </a></div>
    </div>
</header><div class="search-dropdown desktop">
        <div id="search-dropdown-desktop"></div>
    </div>
    <div class="search-dropdown mobile">
        <div id="search-dropdown-mobile"></div>
    </div><main class="main">
                <div class="container"><div class="toc" id="toc-auto">
            <h2 class="toc-title">目录</h2>
            <div class="toc-content" id="toc-content-auto"></div>
        </div><article class="page single"><h1 class="single-title animate__animated animate__flipInX">程序员面试面经</h1><div class="post-meta">
            <div class="post-meta-line"><span class="post-author"><a href="/" title="Author" rel="author" class="author"><i class="fas fa-user-circle fa-fw" aria-hidden="true"></i>Thising</a></span>&nbsp;<span class="post-category">收录于 <a href="/categories/%E7%BC%96%E7%A8%8B/"><i class="far fa-folder fa-fw" aria-hidden="true"></i>编程</a></span></div>
            <div class="post-meta-line"><i class="far fa-calendar-alt fa-fw" aria-hidden="true"></i>&nbsp;<time datetime="2026-01-25">2026-01-25</time>&nbsp;<i class="fas fa-pencil-alt fa-fw" aria-hidden="true"></i>&nbsp;约 34403 字&nbsp;
                <i class="far fa-clock fa-fw" aria-hidden="true"></i>&nbsp;预计阅读 69 分钟&nbsp;
    

    
        

        
        
            <span id="busuanzi_container_value_page_pv"><i class="far fa-eye fa-fw"></i>
                
                <span id="busuanzi_value_page_pv"></span>&nbsp;次阅读</span>
        
    

</div>
        </div><div class="details toc" id="toc-static"  data-kept="">
                <div class="details-summary toc-title">
                    <span>目录</span>
                    <span><i class="details-icon fas fa-angle-right" aria-hidden="true"></i></span>
                </div>
                <div class="details-content toc-content" id="toc-content-static"><nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#自我介绍">自我介绍</a></li>
        <li><a href="#项目介绍">项目介绍：</a>
          <ul>
            <li><a href="#apache-fory">Apache Fory</a>
              <ul>
                <li><a href="#1-项目信息">1. 项目信息</a></li>
                <li><a href="#2-项目进度">2. 项目进度</a>
                  <ul>
                    <li><a href="#已完成工作">已完成工作</a></li>
                    <li><a href="#遇到的问题及解决方案">遇到的问题及解决方案</a></li>
                    <li><a href="#后续工作安排">后续工作安排</a></li>
                  </ul>
                </li>
              </ul>
            </li>
            <li><a href="#小智医疗">小智医疗</a></li>
            <li><a href="#探店笔记">探店笔记</a>
              <ul>
                <li><a href="#项目介绍-1">项目介绍</a></li>
                <li><a href="#主要功能模块">主要功能模块</a>
                  <ul>
                    <li><a href="#1登录">1.登录</a></li>
                    <li><a href="#2商户缓存">2.商户缓存</a></li>
                    <li><a href="#3优惠卷秒杀">3.优惠卷秒杀</a></li>
                    <li><a href="#4-达人探店">4. 达人探店</a></li>
                    <li><a href="#5-查看附近商户">5. 查看附近商户</a></li>
                    <li><a href="#6全局唯一id">6.全局唯一id</a></li>
                  </ul>
                </li>
              </ul>
            </li>
            <li><a href="#蛇蛇大作战">蛇蛇大作战</a>
              <ul>
                <li><a href="#主要包含模块">主要包含模块：</a></li>
                <li><a href="#kob项目可能面试题">KOB项目可能面试题</a>
                  <ul>
                    <li><a href="#问题在实现bot服务时如何确保代码的安全性避免恶意代码的执行">问题：在实现Bot服务时，如何确保代码的安全性，避免恶意代码的执行？</a></li>
                    <li><a href="#问题请谈谈项目中使用websocket的优势以及在实际应用中遇到的挑战">问题：请谈谈项目中使用WebSocket的优势以及在实际应用中遇到的挑战。</a></li>
                    <li><a href="#问题在匹配服务中如何根据玩家的分值差距和等待时间进行智能匹配">问题：在匹配服务中，如何根据玩家的分值差距和等待时间进行智能匹配？</a></li>
                    <li><a href="#问题在项目中为什么选择将功能划分为三个独立的springboot进程模块">问题：在项目中，为什么选择将功能划分为三个独立的SpringBoot进程模块？</a></li>
                    <li><a href="#问题项目中如何实现线程安全的游戏状态同步">问题：项目中如何实现线程安全的游戏状态同步？</a></li>
                    <li><a href="#问题在项目中如何保证bot代码执行的性能和资源占用">问题：在项目中，如何保证Bot代码执行的性能和资源占用？</a></li>
                    <li><a href="#问题如何保证匹配服务在高并发情况下的性能">问题：如何保证匹配服务在高并发情况下的性能？</a></li>
                    <li><a href="#问题在实现bot服务时如何防止恶意代码的执行">问题：在实现Bot服务时，如何防止恶意代码的执行？</a></li>
                    <li><a href="#问题在游戏平台中如何处理用户的实时在线对战功能">问题：在游戏平台中，如何处理用户的实时在线对战功能？</a></li>
                  </ul>
                </li>
                <li><a href="#项目整体架构类">项目整体架构类</a></li>
                <li><a href="#技术细节类">技术细节类</a>
                  <ul>
                    <li><a href="#前端部分">前端部分</a></li>
                    <li><a href="#后端部分">后端部分</a></li>
                    <li><a href="#数据库部分">数据库部分</a></li>
                  </ul>
                </li>
                <li><a href="#问题解决类">问题解决类</a></li>
                <li><a href="#代码优化类">代码优化类</a></li>
                <li><a href="#扩展性和维护性类">扩展性和维护性类</a></li>
              </ul>
            </li>
          </ul>
        </li>
        <li><a href="#c语法">c++语法</a></li>
        <li><a href="#java代码题">Java代码题</a>
          <ul>
            <li>
              <ul>
                <li><a href="#交替打印abc">交替打印&quot;ABC&quot;</a></li>
              </ul>
            </li>
            <li><a href="#交替打印1-100">交替打印1-100</a></li>
          </ul>
        </li>
        <li><a href="#网络">网络</a>
          <ul>
            <li><a href="#http的常用方法有哪些">HTTP的常用方法有哪些</a></li>
            <li><a href="#有哪些常用状态码">有哪些常用状态码</a></li>
            <li><a href="#讲一下tcp连接的三次握手和四次挥手">讲一下TCP连接的三次握手和四次挥手</a>
              <ul>
                <li>
                  <ul>
                    <li><a href="#1-三次握手才可以阻止重复历史连接的初始化主要原因">1. 三次握手才可以阻止重复历史连接的初始化（主要原因）</a></li>
                    <li><a href="#2-三次握手才可以同步双方的初始序号">2. 三次握手才可以同步双方的初始序号</a></li>
                    <li><a href="#3-三次握手才可以避免资源浪费">3. 三次握手才可以避免资源浪费</a></li>
                  </ul>
                </li>
              </ul>
            </li>
            <li><a href="#tcp和udp共用端口的问题">tcp和udp共用端口的问题</a></li>
            <li><a href="#如何实现一个可靠的udp">如何实现一个可靠的UDP</a>
              <ul>
                <li>
                  <ul>
                    <li>
                      <ul>
                        <li><a href="#1-核心机制设计">‌<strong>1. 核心机制设计</strong>‌</a></li>
                      </ul>
                    </li>
                  </ul>
                </li>
              </ul>
            </li>
            <li><a href="#tsl四次握手">TSL四次握手</a></li>
            <li><a href="#ca证书验证流程存储在哪里">CA证书验证流程，存储在哪里？</a></li>
            <li><a href="#常见攻击手段和预防手段">常见攻击手段和预防手段</a>
              <ul>
                <li>
                  <ul>
                    <li><a href="#1-ddos攻击">1. ddos攻击</a></li>
                    <li><a href="#2-sql注入">2. SQL注入</a></li>
                    <li><a href="#3-csrf攻击">3. CSRF攻击</a></li>
                    <li><a href="#4-xss攻击">4. XSS攻击</a></li>
                  </ul>
                </li>
              </ul>
            </li>
            <li><a href="#socket有哪些了解wxg快手都问了">Socket有哪些了解（wxg，快手都问了）</a></li>
          </ul>
        </li>
        <li><a href="#场景题">场景题</a>
          <ul>
            <li><a href="#如何利用线程池去实现一个比如整点进行日志记录功能">如何利用线程池去实现一个比如整点进行日志记录功能</a></li>
            <li><a href="#三个服务器如何进行负载均衡让同一内容的请求打到同一台副本上以及如何动态扩容在不影响前面三台机器的前提下">三个服务器如何进行负载均衡，让同一内容的请求打到同一台副本上，以及如何动态扩容在不影响前面三台机器的前提下</a></li>
            <li><a href="#如何用redis筛选出前100名的排行榜也就是动态更新redis同时用户非常多redis中放不下所有的">如何用redis筛选出前100名的排行榜，也就是动态更新redis，同时用户非常多，redis中放不下所有的</a></li>
          </ul>
        </li>
        <li><a href="#操作系统">操作系统</a>
          <ul>
            <li><a href="#进程线程和协程">进程，线程和协程</a>
              <ul>
                <li>
                  <ul>
                    <li><a href="#二协程的核心优势">‌<strong>二、协程的核心优势</strong>‌</a>
                      <ul>
                        <li><a href="#1-轻量级并发">‌<strong>1. 轻量级并发</strong>‌</a></li>
                      </ul>
                    </li>
                  </ul>
                </li>
              </ul>
            </li>
            <li><a href="#selectpoll和epoll讲讲区别">select、poll和epoll讲讲区别</a>
              <ul>
                <li><a href="#核心对比表">核心对比表</a></li>
              </ul>
            </li>
            <li><a href="#内核态与用户态">内核态与用户态</a></li>
            <li><a href="#操作系统中进程死锁条件那四个如何死锁避免死锁检测">操作系统中进程死锁条件（那四个），如何死锁避免，死锁检测</a>
              <ul>
                <li>
                  <ul>
                    <li><a href="#死锁的四个必要条件必须同时存在才会死锁">‌<strong>死锁的四个必要条件</strong>‌（必须同时存在才会死锁）</a></li>
                    <li><a href="#死锁避免策略预防死锁发生">‌<strong>死锁避免策略</strong>‌（预防死锁发生）</a></li>
                    <li><a href="#死锁检测方法发生后识别">‌<strong>‌死锁检测方法</strong>‌（发生后识别）</a></li>
                    <li><a href="#死锁恢复手段检测到后处理">‌<strong>死锁恢复手段</strong>‌（检测到后处理）</a></li>
                  </ul>
                </li>
              </ul>
            </li>
          </ul>
        </li>
        <li><a href="#mysql">MySQL</a>
          <ul>
            <li><a href="#sql基础">SQL基础</a>
              <ul>
                <li><a href="#数据库三大范式是什么">数据库三大范式是什么</a>
                  <ul>
                    <li><a href="#先看一个反面教材表格"><strong>先看一个“反面教材”表格</strong></a></li>
                    <li><a href="#第一范式1nf原子性"><strong>第一范式（1NF）——原子性</strong></a></li>
                    <li><a href="#第二范式2nf消除部分依赖"><strong>第二范式（2NF）——消除部分依赖</strong></a></li>
                    <li><a href="#第三范式3nf消除传递依赖"><strong>第三范式（3NF）——消除传递依赖</strong></a></li>
                    <li><a href="#总结三大范式的作用"><strong>总结：三大范式的作用</strong></a></li>
                    <li><a href="#1-减少数据冗余"><strong>1. 减少数据冗余</strong></a></li>
                    <li><a href="#2-避免更新异常"><strong>2. 避免更新异常</strong></a></li>
                    <li><a href="#3-消除插入和删除异常"><strong>3. 消除插入和删除异常</strong></a></li>
                    <li><a href="#4-提高数据一致性"><strong>4. 提高数据一致性</strong></a></li>
                    <li><a href="#5-增强可维护性"><strong>5. 增强可维护性</strong></a></li>
                  </ul>
                </li>
                <li><a href="#mysql-怎么连表查询">MySQL 怎么连表查询？</a></li>
                <li><a href="#讲讲acid">讲讲ACID</a></li>
              </ul>
            </li>
            <li><a href="#存储引擎">存储引擎</a>
              <ul>
                <li><a href="#讲一讲mysql的引擎吧你有什么了解">讲一讲mysql的引擎吧，你有什么了解？</a></li>
              </ul>
            </li>
            <li><a href="#索引">索引</a>
              <ul>
                <li><a href="#索引有哪些优化手段讲一下b树索引">索引有哪些优化手段，讲一下B+树索引</a></li>
                <li><a href="#如果给每一列都建立一个索引会有什么问题">如果给每一列都建立一个索引会有什么问题？</a></li>
              </ul>
            </li>
            <li><a href="#事务">事务</a>
              <ul>
                <li><a href="#隔离级别">隔离级别</a></li>
                <li><a href="#mvcc解释一下">mvcc解释一下</a></li>
              </ul>
            </li>
            <li><a href="#锁">锁</a>
              <ul>
                <li><a href="#讲一下mysql里有哪些锁">讲一下mysql里有哪些锁？</a></li>
              </ul>
            </li>
            <li><a href="#性能调优">性能调优</a>
              <ul>
                <li><a href="#慢sql优化">慢sql优化</a></li>
              </ul>
            </li>
          </ul>
        </li>
        <li><a href="#java基础">Java基础</a>
          <ul>
            <li>
              <ul>
                <li><a href="#final关键字用法">final关键字用法</a>
                  <ul>
                    <li><a href="#1-final修饰变量">1. final修饰变量</a>
                      <ul>
                        <li><a href="#基本类型变量">基本类型变量</a></li>
                        <li><a href="#引用类型变量">引用类型变量</a></li>
                      </ul>
                    </li>
                    <li><a href="#2-final修饰方法">2. final修饰方法</a></li>
                    <li><a href="#3-final修饰类">3. final修饰类</a></li>
                    <li><a href="#4-final参数">4. final参数</a></li>
                    <li><a href="#5-final与并发编程">5. final与并发编程</a></li>
                  </ul>
                </li>
                <li><a href="#讲解hashmap扩容">讲解HashMap扩容</a></li>
                <li><a href="#垃圾回收策略">垃圾回收策略</a></li>
                <li><a href="#讲讲spring">讲讲Spring</a></li>
                <li><a href="#讲讲线程池原理">讲讲线程池原理</a>
                  <ul>
                    <li><a href="#1-线程池的创建">1. 线程池的创建</a></li>
                    <li><a href="#2-参数配置经验">2. 参数配置经验</a></li>
                  </ul>
                </li>
                <li><a href="#讲讲讲一下threadlocal的原理threadlocal存在的问题">讲讲讲一下threadlocal的原理，threadlocal存在的问题?</a></li>
                <li><a href="#如果两个服务需要传递threadlocal中的值例如用户id该如何传递">如果两个服务需要传递threadlocal中的值例如用户ID该如何传递</a></li>
                <li><a href="#你知道哪些jvm的垃圾回收器">你知道哪些JVM的垃圾回收器</a></li>
                <li><a href="#java的类加载机制是怎么样的">Java的类加载机制是怎么样的</a></li>
                <li><a href="#讲讲aqs">讲讲AQS</a></li>
                <li><a href="#讲讲内存区域">讲讲内存区域</a></li>
                <li><a href="#静态变量放哪不同进程压栈在一个共用栈还是私有栈">静态变量放哪,不同进程压栈在一个共用栈还是私有栈？</a></li>
              </ul>
            </li>
          </ul>
        </li>
        <li><a href="#redis">Redis</a>
          <ul>
            <li><a href="#redis了解过吗有哪些应用">redis了解过吗，有哪些应用？</a>
              <ul>
                <li>
                  <ul>
                    <li><a href="#一redis的核心优势">‌<strong>一、Redis的核心优势</strong>‌</a></li>
                    <li><a href="#二redis的6大典型应用场景">‌<strong>二、Redis的6大典型应用场景</strong>‌</a>
                      <ul>
                        <li><a href="#1-缓存cache">‌**1. 缓存（Cache）**‌</a></li>
                        <li><a href="#2-会话存储session-storage">‌**2. 会话存储（Session Storage）**‌</a></li>
                        <li><a href="#3-排行榜与计数器">‌<strong>3. 排行榜与计数器</strong>‌</a></li>
                        <li><a href="#4-消息队列">‌<strong>4. 消息队列</strong>‌</a></li>
                        <li><a href="#5-分布式锁">‌<strong>5. 分布式锁</strong>‌</a></li>
                        <li><a href="#6-实时数据分析">‌<strong>6. 实时数据分析</strong>‌</a></li>
                      </ul>
                    </li>
                    <li><a href="#三redis-vs-其他技术选型对比">‌<strong>三、Redis vs 其他技术选型对比</strong>‌</a></li>
                    <li><a href="#四redis的局限性">‌<strong>四、Redis的局限性</strong>‌</a></li>
                    <li><a href="#总结">‌<strong>总结</strong>‌</a></li>
                  </ul>
                </li>
              </ul>
            </li>
            <li><a href="#redis常用数据结构">redis常用数据结构</a>
              <ul>
                <li>
                  <ul>
                    <li><a href="#1-字符串string">1. <strong>字符串（String）</strong></a></li>
                    <li><a href="#2-列表list">2. <strong>列表（List）</strong></a></li>
                    <li><a href="#3-哈希hash">3. <strong>哈希（Hash）</strong></a></li>
                    <li><a href="#4-集合set">4. <strong>集合（Set）</strong></a></li>
                    <li><a href="#5-有序集合zset">5. <strong>有序集合（ZSet）</strong></a></li>
                    <li><a href="#6-其他结构">6. <strong>其他结构</strong></a></li>
                  </ul>
                </li>
              </ul>
            </li>
            <li><a href="#redis的高可用性方案有哪些具体讲一讲">redis的高可用性方案有哪些，具体讲一讲</a>
              <ul>
                <li>
                  <ul>
                    <li><a href="#1-主从复制replication">1. <strong>主从复制（Replication）</strong></a></li>
                    <li><a href="#2-哨兵模式sentinel">2. <strong>哨兵模式（Sentinel）</strong></a></li>
                    <li><a href="#3-redis-cluster集群模式">3. <strong>Redis Cluster（集群模式）</strong></a></li>
                  </ul>
                </li>
              </ul>
            </li>
            <li><a href="#缓存雪崩击穿穿透是什么怎么解决">缓存雪崩、击穿、穿透是什么？怎么解决？</a>
              <ul>
                <li>
                  <ul>
                    <li><a href="#1-缓存雪崩cache-avalanche">‌**1. 缓存雪崩（Cache Avalanche）**‌</a>
                      <ul>
                        <li><a href="#定义">‌<strong>定义</strong>‌</a></li>
                        <li><a href="#原因">‌<strong>原因</strong>‌</a></li>
                        <li><a href="#解决方案">‌<strong>解决方案</strong>‌</a></li>
                      </ul>
                    </li>
                    <li><a href="#2-缓存击穿cache-breakdown">‌**2. 缓存击穿（Cache Breakdown）**‌</a>
                      <ul>
                        <li><a href="#定义-1">‌<strong>定义</strong>‌</a></li>
                        <li><a href="#原因-1">‌<strong>原因</strong>‌</a></li>
                        <li><a href="#解决方案-1">‌<strong>解决方案</strong>‌</a></li>
                      </ul>
                    </li>
                    <li><a href="#3-缓存穿透cache-penetration">‌**3. 缓存穿透（Cache Penetration）**‌</a>
                      <ul>
                        <li><a href="#定义-2">‌<strong>定义</strong>‌</a></li>
                        <li><a href="#原因-2">‌<strong>原因</strong>‌</a></li>
                        <li><a href="#解决方案-2">‌<strong>解决方案</strong>‌</a></li>
                      </ul>
                    </li>
                    <li><a href="#三者的核心区别">‌<strong>三者的核心区别</strong>‌</a></li>
                    <li><a href="#实战案例">‌<strong>实战案例</strong>‌</a></li>
                  </ul>
                </li>
              </ul>
            </li>
            <li><a href="#大key是什么意思呢怎么解决">大key是什么意思呢？怎么解决</a></li>
            <li><a href="#zset的底层数据结构">Zset的底层数据结构</a></li>
            <li><a href="#redis-的-zset-为何选择跳表skip-list而非红黑树">Redis 的 ZSet 为何选择跳表（Skip List）而非红黑树？</a>
              <ul>
                <li>
                  <ul>
                    <li><a href="#1-查询性能的权衡">1. <strong>查询性能的权衡</strong></a></li>
                    <li><a href="#2-插入和删除操作的效率">2. <strong>插入和删除操作的效率</strong></a></li>
                    <li><a href="#3-范围查询的高效性">3. <strong>范围查询的高效性</strong></a></li>
                    <li><a href="#4-实现复杂度">4. <strong>实现复杂度</strong></a></li>
                    <li><a href="#5-内存占用">5. <strong>内存占用</strong></a></li>
                    <li><a href="#6-并发优化的潜力">6. <strong>并发优化的潜力</strong></a></li>
                    <li><a href="#为什么不是所有场景都用跳表">为什么不是所有场景都用跳表？</a></li>
                    <li><a href="#总结-1">总结</a></li>
                  </ul>
                </li>
              </ul>
            </li>
          </ul>
        </li>
        <li><a href="#消息队列">消息队列</a>
          <ul>
            <li>
              <ul>
                <li><a href="#mq了解过吗解决哪些问题">mq了解过吗？解决哪些问题</a>
                  <ul>
                    <li><a href="#一消息队列解决的4大核心问题">‌<strong>一、消息队列解决的4大核心问题</strong>‌</a>
                      <ul>
                        <li><a href="#1-系统解耦">1. ‌<strong>系统解耦</strong>‌</a></li>
                        <li><a href="#2-异步处理">2. ‌<strong>异步处理</strong>‌</a></li>
                        <li><a href="#3-流量削峰">3. ‌<strong>流量削峰</strong>‌</a></li>
                        <li><a href="#4-数据最终一致性">4. ‌<strong>数据最终一致性</strong>‌</a></li>
                      </ul>
                    </li>
                    <li><a href="#二消息队列的典型应用场景">‌<strong>二、消息队列的典型应用场景</strong>‌</a></li>
                    <li><a href="#三主流消息队列对比">‌<strong>三、主流消息队列对比</strong>‌</a></li>
                  </ul>
                </li>
              </ul>
            </li>
          </ul>
        </li>
        <li><a href="#分布式">分布式</a>
          <ul>
            <li><a href="#1-cap为什么只能同时满足两个"><strong>1. CAP为什么只能同时满足两个？</strong></a>
              <ul>
                <li><a href="#通俗解释"><strong>通俗解释</strong>：</a></li>
                <li><a href="#技术本质"><strong>技术本质</strong>：</a></li>
                <li><a href="#cap的常见取舍"><strong>CAP的常见取舍</strong>：</a></li>
              </ul>
            </li>
          </ul>
        </li>
        <li><a href="#设计模式">设计模式</a>
          <ul>
            <li><a href="#单例模式">单例模式</a>
              <ul>
                <li>
                  <ul>
                    <li><a href="#1-饿汉式线程安全"><strong>1. 饿汉式（线程安全）</strong></a></li>
                    <li><a href="#2-懒汉式线程不安全--需加锁"><strong>2. 懒汉式（线程不安全 → 需加锁）</strong></a></li>
                    <li><a href="#3-双重检查锁定dcl线程安全"><strong>3. 双重检查锁定（DCL，线程安全）</strong></a></li>
                  </ul>
                </li>
                <li><a href="#单例模式使用场景有哪些呢举个例子">单例模式使用场景有哪些呢？举个例子</a></li>
              </ul>
            </li>
          </ul>
        </li>
        <li><a href="#大语言模型">大语言模型</a>
          <ul>
            <li><a href="#transformer">Transformer</a>
              <ul>
                <li><a href="#讲讲transformer模型">讲讲Transformer模型</a></li>
                <li><a href="#transformer时间复杂度是多少呢">Transformer时间复杂度是多少呢</a>
                  <ul>
                    <li><a href="#1-自注意力机制的时间复杂度"><strong>1. 自注意力机制的时间复杂度</strong></a></li>
                    <li><a href="#2-前馈网络ffn的时间复杂度"><strong>2. 前馈网络（FFN）的时间复杂度</strong></a></li>
                    <li><a href="#3-整个-transformer-层的复杂度"><strong>3. 整个 Transformer 层的复杂度</strong></a></li>
                    <li><a href="#4-主导项分析"><strong>4. 主导项分析</strong></a></li>
                    <li><a href="#5-与其他模型的对比"><strong>5. 与其他模型的对比</strong></a></li>
                    <li><a href="#总结-2"><strong>总结</strong></a></li>
                  </ul>
                </li>
                <li><a href="#transformer的bert有了解过吗">Transformer的BERT有了解过吗</a>
                  <ul>
                    <li><a href="#1-bert的核心思想"><strong>1. BERT的核心思想</strong></a></li>
                    <li><a href="#2-关键技术与训练任务"><strong>2. 关键技术与训练任务</strong></a>
                      <ul>
                        <li><a href="#1-masked-language-model-mlm"><strong>(1) Masked Language Model (MLM)</strong></a></li>
                        <li><a href="#2-next-sentence-prediction-nsp"><strong>(2) Next Sentence Prediction (NSP)</strong></a></li>
                      </ul>
                    </li>
                    <li><a href="#3-模型结构细节"><strong>3. 模型结构细节</strong></a></li>
                    <li><a href="#4-微调fine-tuning应用"><strong>4. 微调（Fine-tuning）应用</strong></a></li>
                    <li><a href="#5-bert的优缺点"><strong>5. BERT的优缺点</strong></a>
                      <ul>
                        <li><a href="#优点"><strong>优点</strong>：</a></li>
                        <li><a href="#缺点"><strong>缺点</strong>：</a></li>
                      </ul>
                    </li>
                    <li><a href="#6-常见面试问题与回答思路"><strong>6. 常见面试问题与回答思路</strong></a>
                      <ul>
                        <li><a href="#q1-bert为什么比gpt效果好"><strong>Q1: BERT为什么比GPT效果好？</strong></a></li>
                        <li><a href="#q2-bert的参数量如何估算"><strong>Q2: BERT的参数量如何估算？</strong></a></li>
                        <li><a href="#q3-如何优化bert的长文本处理"><strong>Q3: 如何优化BERT的长文本处理？</strong></a></li>
                      </ul>
                    </li>
                    <li><a href="#7-扩展bert的变体模型"><strong>7. 扩展：BERT的变体模型</strong></a></li>
                  </ul>
                </li>
                <li><a href="#bert与gpt核心区别总结">BERT与GPT核心区别总结</a>
                  <ul>
                    <li><a href="#一架构设计">‌<strong>一、架构设计</strong>‌</a></li>
                    <li><a href="#二训练机制">‌<strong>二、训练机制</strong>‌</a></li>
                    <li><a href="#三应用场景">‌<strong>三、应用场景</strong>‌</a></li>
                    <li><a href="#四上下文处理能力">‌<strong>四、上下文处理能力</strong>‌</a></li>
                    <li><a href="#五模型输出">‌<strong>五、模型输出</strong>‌</a></li>
                    <li><a href="#典型应用对比示例">典型应用对比示例</a></li>
                    <li><a href="#核心结论">核心结论</a></li>
                  </ul>
                </li>
              </ul>
            </li>
            <li><a href="#rag">RAG</a></li>
          </ul>
        </li>
        <li><a href="#思维题">思维题</a>
          <ul>
            <li><a href="#赛马题">赛马题</a></li>
          </ul>
        </li>
        <li><a href="#面试反问">面试反问</a>
          <ul>
            <li><a href="#前述">前述</a></li>
            <li><a href="#一面纯技术面">一面：纯技术面</a>
              <ul>
                <li><a href="#目的">目的</a></li>
                <li><a href="#反问">反问</a></li>
              </ul>
            </li>
            <li><a href="#二面技术综合面主管面">二面：技术综合面/主管面</a>
              <ul>
                <li><a href="#目的-1">目的</a></li>
                <li><a href="#反问-1">反问</a></li>
              </ul>
            </li>
            <li><a href="#三面hr面">三面：<code>HR</code>面</a>
              <ul>
                <li><a href="#目的-2">目的</a></li>
                <li><a href="#反问-2">反问</a></li>
              </ul>
            </li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</nav></div>
            </div><div class="content" id="content"><h2 id="自我介绍">自我介绍</h2>
<p>面试官您好，我叫李鑫，来自江苏盐城。本科毕业于电子科技大学软件工程专业，目前是中国科学技术大学软件学院的研二学生。</p>
<p>目前我在百度搜索架构部实习，主要负责基础检索召回服务相关的研发工作，重点参与了 DIDB中 Storelib底层能力建设，包括原地更新的全内存存储格式
设计、属性写入与反查链路优化，在实际业务场景中显著降低了内存占用并提升了稳定性。</p>
<p>此外，我参加了中科院组织的开源之夏活动，为 ApacheFory 开源项目实现了Go方向的编译时代码生成功能，替代运行时反射，并参与了类型分析、确定
性序列化和工具链建设，对系统设计和工程质量有了比较深入的理解。</p>
<p>我的技术栈以 Java、C++ 为主，对 Go 和 python 也有一定的了解，希望能在贵部门进一步学习和成长。谢谢。</p>
<p>Hello interviewer,</p>
<p>My name is Li Xin, and I&rsquo;m from Yancheng, Jiangsu Province. I did my undergraduate studies at the School of Software Engineering, University of Electronic Science and Technology of China, and I&rsquo;m currently a first-year postgraduate student at the School of Software Engineering, University of Science and Technology of China.</p>
<p>My main programming language is Java, and I also have some knowledge of C++. The projects I&rsquo;ve worked on include a Snake Battle mini-game, a food exploration note project, and an intelligent medical AI agent project.</p>
<p>According to the training program of our college, we are required to intern in enterprises for practical learning, so I can commit to a stable one-year internship. I would love to have the opportunity to learn in your department.</p>
<p>Thank you.</p>
<p><strong>简历中项目应该按照时间顺序，把最新的项目放在上面</strong></p>
<h2 id="项目介绍">项目介绍：</h2>
<h3 id="apache-fory">Apache Fory</h3>
<h4 id="1-项目信息">1. 项目信息</h4>
<ul>
<li>
<p><strong>项目名称</strong>：为 Fury Go 实现编译时代码生成功能</p>
</li>
<li>
<p><strong>方案描述</strong>：</p>
<ul>
<li>
<p>总体目标：</p>
<ul>
<li>在编译阶段生成面向 Fury 二进制协议的强类型序列化/反序列化代码，替代反射热路径，保证协议一致性、性能与类型安全。</li>
</ul>
</li>
<li>
<p>实施思路（项目初期规划）：</p>
<ul>
<li>类型发现：通过 <code>go generate</code>/CLI，扫描源码中带 <code>//fory:generate</code> 注解的结构体，形成待生成清单。</li>
<li>类型分析：获取结构体导出字段的编译期类型信息，识别基础类型、字符串、时间类（如时间戳与本地日期）、指针、结构体、切片与映射等；限定映射键为可比较的基础类型。</li>
<li>字段排序：按运行时反射路径的分组与规则生成稳定顺序（primitive/final/other/collection/map），组内再按类型与命名排序，确保与反射序列化的字段顺序一致。</li>
<li>结构哈希：将字段类型映射为协议类型标识并迭代计算结构哈希；对切片/映射使用统一标识；对指针命名结构体按规则取符号；避免零哈希。</li>
<li>代码生成：为每个目标类型生成一个序列化器及工厂，注册到运行时；生成强类型 <code>WriteTyped/ReadTyped</code> 与接口兼容方法；先读写结构哈希，再按排序顺序逐字段编码/解码。
<ul>
<li>写入规则：可引用类型（指针、结构体、字符串等）走带引用跟踪通道；非引用基本类型写非空标识后再写值；字符串写引用标识后写内容；时间写微秒，本地日期写天数并处理零日期标记；切片先写长度后遍历；映射先写长度、对键排序后写入键值对。</li>
<li>读取规则：对称恢复并校验结构哈希；字符串先读并丢弃引用标识；切片/映射按长度分配或置空；可引用类型走带引用跟踪通道读取并回填。</li>
</ul>
</li>
<li>编译期守卫：生成结构体“快照”与编译期校验。当结构体变更但未重新生成时代码无法通过编译，并给出强制刷新与再生成指引。</li>
<li>开发体验：提供文件/包/类型多入口与 <code>--force</code> 选项；统一注解为 <code>//fory:generate</code>；在出现守卫冲突时输出可操作的提示信息。</li>
<li>兼容与迁移：生成路径与反射路径保持格式完全一致，可在同一工程内混用并互通，支持按文件/类型的增量引入。</li>
<li>测试与验证：构造包含基础类型、切片、映射、指针与嵌套的样例结构体；对比反射与生成路径的二进制；验证读写互通与确定性排序；覆盖零值与引用回路等边界。</li>
<li>风险与应对：针对键排序一致性、变长编码差异、可寻址性、零日期语义等风险，分别通过显式排序、遵循协议编码 API、可寻址写入与专门分支规避。</li>
<li>验收标准：能为 Struct/Slice/Map 生成零反射开销的序列化器；与反射路径二进制完全一致；守卫可检测失配并提供清晰恢复路径；可无侵入增量接入。</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>时间规划</strong>：</p>
<ul>
<li>7 月：熟悉仓库与跨语言协议；学习 Java/Python 版本实现；设计 Go 端 AOT 方案与文件结构</li>
<li>8 月下：提交首个 PR（Struct 代码生成，先支持基础类型）</li>
<li>9 月中：提交第二个 PR（扩展支持 Slice）</li>
<li>9 月下：提交第三个 PR（扩展支持 Map）；完善 CLI、文档与测试，收尾优化</li>
</ul>
</li>
</ul>
<h4 id="2-项目进度">2. 项目进度</h4>
<h5 id="已完成工作">已完成工作</h5>
<ul>
<li>
<p>编译时代码生成全链路</p>
<ul>
<li>元信息解析与类型分析：<code>parser.go</code>、<code>utils.go</code></li>
<li>代码生成核心：<code>encoder.go</code>（WriteTyped）、<code>decoder.go</code>（ReadTyped）、<code>generator.go</code></li>
<li>编译期一致性保护（结构体快照与强校验）：<code>guard.go</code></li>
<li>CLI 工具与使用指引：<code>cmd/fory/main.go</code>、<code>README.md</code></li>
</ul>
</li>
<li>
<p>支持的类型与特性</p>
<ul>
<li>Struct：基础类型、命名类型（含 <code>time.Time</code>、<code>fory.Date</code>）、指针、嵌套结构体</li>
<li>Slice：支持任意维度嵌套 slice 的序列化与反序列化</li>
<li>Map：对基本可比较键的 Map，按键排序实现确定性序列化</li>
<li>引用追踪与接口兼容：生成强类型 <code>WriteTyped/ReadTyped</code>，并生成 <code>reflect.Value</code> 兼容接口方法</li>
<li>字段排序与结构哈希：复刻反射路径排序与哈希规则，确保跨语言/反射路径完全一致</li>
</ul>
</li>
<li>
<p>体验与一致性改进</p>
<ul>
<li>生成文件包含 <code>init()</code> 自动注册，零显式接线</li>
<li>统一注解从 <code>//fory:gen</code> 调整为更语义化的 <code>//fory:generate</code></li>
<li>CLI 支持 <code>--force</code> 自动清理并重试，缓解编译期快照失配引发的错误</li>
</ul>
</li>
<li>
<p>测试与示例</p>
<ul>
<li>新增/完善 <code>tests/structs.go</code> 覆盖 Struct、Slice、Map、动态切片等示例类型（如 <code>ValidationDemo</code>、<code>SliceDemo</code>、<code>DynamicSliceDemo</code>、<code>MapDemo</code>）</li>
<li>生成器及跨语言模式相关用例：<code>tests/generator_test.go</code>、<code>tests/generator_xlang_test.go</code></li>
</ul>
</li>
</ul>
<h5 id="遇到的问题及解决方案">遇到的问题及解决方案</h5>
<ul>
<li>
<p>反射路径对齐与排序一致性</p>
<ul>
<li>问题：生成代码需与反射序列化在字段排序、类型分组、哈希计算上完全一致，否则跨语言/回放失败。</li>
<li>方案：严格复刻反射实现的分组与排序规则；哈希计算对 Slice/Map 采用统一 TypeId（如 LIST=21、MAP=23）；为 <code>int</code>、<code>string</code> 等细节做特判，保证编码一致。</li>
</ul>
</li>
<li>
<p>可空与引用追踪</p>
<ul>
<li>问题：区分可引用类型与非引用类型的头标识（RefValueFlag/NotNullValueFlag），以及字符串/指针等路径的差异。</li>
<li>方案：在生成代码中统一通过 <code>WriteReferencable/ReadReferencable</code> 或非引用路径写入正确标识；字符串等最终类型按协议处理。</li>
</ul>
</li>
<li>
<p>特殊类型与零值语义</p>
<ul>
<li>问题：<code>time.Time</code> 与 <code>fory.Date</code> 在协议中的编码语义不同（如本地日期零值标记）。</li>
<li>方案：为这两类命名类型生成专门分支，零值与时间单位严格按协议读写。</li>
</ul>
</li>
<li>
<p>Map 确定性输出</p>
<ul>
<li>问题：Go map 无序，跨平台/回放可能不一致。</li>
<li>方案：对不同键类型生成相应的排序逻辑（string/int/uint/float/bool），确保序列化稳定。</li>
</ul>
</li>
<li>
<p>Varint 编码与类型位宽</p>
<ul>
<li>问题：部分基础类型在反射路径使用变长编码（如 int32/int64）；若不一致会导致不兼容。</li>
<li>方案：在非引用路径下为对应类型使用变长编码 API，保证与反射路径完全一致。</li>
</ul>
</li>
<li>
<p>编译期守卫导致的首次失败</p>
<ul>
<li>问题：结构体变更后未重新生成会触发守卫，造成一轮编译失败。</li>
<li>方案：CLI 增加智能提示与 <code>--force</code> 清理重试；文档同步指引。</li>
</ul>
</li>
</ul>
<h5 id="后续工作安排">后续工作安排</h5>
<ul>
<li>类型支持拓展：<code>set</code>、<code>array</code>、更丰富的 map 键类型、enum/decimal 等</li>
<li>兼容模式完善：元共享（MetaShare）与 schema 演进场景代码生成</li>
<li>工具链与稳定性：增加 Reflect vs Codegen 对照测试、fuzz 测试、性能基准与 CI 校验</li>
<li>生态完善：更多示例与最佳实践文档，支持更细粒度的生成选项（按包/按文件/按类型）</li>
<li>代码质量：进一步收敛边界分支（指针可寻址性、接口落地类型），提升可维护性</li>
</ul>
<hr>
<h3 id="小智医疗">小智医疗</h3>
<p><strong>嵌入模型</strong>：阿里云百炼平台嵌入模型 <strong>text-embedding-v3</strong>，向量维度1024</p>
<p><strong>持久化数据库</strong>：MongoDB</p>
<p><strong>向量数据库</strong>：<strong>Pinecone</strong>。通过设置 minScore 阈值，能够过滤掉那些与查询文本相关性较低的结果</p>
<p><strong>分片方式</strong>：按段落分割文档：每个片段包含不超过 300个token，并且有 30个token的重叠部分保证连贯性</p>
<p><strong>流式输出</strong>：修改chatModel为<code>streamingChatModel = &quot;qwenStreamingChatModel&quot;</code>,并修改chat方法返回值为<code>Flux&lt;String&gt;</code></p>
<p><strong>@AiService:</strong></p>
<p><strong>Function calling</strong>:用 @Tool 注解的方法,并配置工具名称和描述</p>
<hr>
<h3 id="探店笔记">探店笔记</h3>
<h4 id="项目介绍-1">项目介绍</h4>
<p>仿大众点评 APP，实现了用户登录、关注、发布推送博客以及优惠券秒杀等功能，用户可以浏览首页热门内容，搜索查看附近商家，发布及查看探店博客。</p>
<h4 id="主要功能模块">主要功能模块</h4>
<h5 id="1登录">1.登录</h5>
<p>因为如果使用<strong>Session</strong>在集群不同服务器之间无法共享，所以我们选择借助可以自动进行数据共享的Redis+token的存储方式。</p>
<p>这里有三个细节：</p>
<ul>
<li>用户脱敏的处理：不能将从MySQL中取出来的用户的所有信息都直接在浏览器间传输（需要保护敏感信息），所以需要将基本可展示的属性封装成单独的DTO进行传递</li>
<li>使用双拦截器进行刷新token以及登录验证：如果只用一个拦截器，是无法完成对所有页面刷新token以及对于需要登录的页面进行登录验证的，所以我们设计了双拦截器模式，第一层拦截器会对所有的页面放行，同时刷新用户token的有效期，第二层拦截器会对需要登录的页面进行登录验证。</li>
<li>在第一层拦截器使用 ZSet 结合时间窗口进行登录限流。通过每次用户发起登录请求时，向 ZSet 插入一个 <strong>以当前时间戳为 <code>score</code> 和 <code>member</code></strong> 的记录；然后使用 <code>ZREMRANGEBYSCORE</code> 删除 <strong>窗口开始时间之前</strong> 的所有记录（滑动窗口的核心）；最后通过 <code>ZCARD</code> 获取 ZSet 中剩余成员的数量（即当前窗口内的请求次数），将超过阈值的用户触发限流，拒绝请求。（通过 <strong>Lua 脚本</strong> 将 <code>ZADD</code> + <code>ZREMRANGEBYSCORE</code> + <code>ZCARD</code> 合并为原子操作，避免并发问题）</li>
</ul>
<blockquote>
<p>面试题：讲讲Session和Token的区别</p>
<table>
  <thead>
      <tr>
          <th style="text-align: left"><strong>维度</strong></th>
          <th style="text-align: left"><strong>Session</strong></th>
          <th style="text-align: left"><strong>Token</strong></th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td style="text-align: left"><strong>存储位置</strong></td>
          <td style="text-align: left">服务端存储（如 Redis、DB）</td>
          <td style="text-align: left">客户端存储（如 Cookie、LocalStorage）</td>
      </tr>
      <tr>
          <td style="text-align: left"><strong>状态性</strong></td>
          <td style="text-align: left">有状态（服务端维护会话）</td>
          <td style="text-align: left">无状态（服务端不存储）</td>
      </tr>
      <tr>
          <td style="text-align: left"><strong>典型实现</strong></td>
          <td style="text-align: left">Session ID + 服务端存储</td>
          <td style="text-align: left">JWT、OAuth2 Token</td>
      </tr>
      <tr>
          <td style="text-align: left"><strong>扩展性</strong></td>
          <td style="text-align: left">跨服务器需共享存储</td>
          <td style="text-align: left">天然支持分布式</td>
      </tr>
      <tr>
          <td style="text-align: left"><strong>安全性</strong></td>
          <td style="text-align: left">依赖服务端保护</td>
          <td style="text-align: left">需防篡改（如签名/加密）</td>
      </tr>
  </tbody>
</table></blockquote>
<p><strong>token</strong>可以优化成JWT格式（私钥和公钥）</p>
<h5 id="2商户缓存">2.商户缓存</h5>
<p>细节点：</p>
<p>2.1 双写一致性：</p>
<p>数据库与缓存数据不一致的问题：</p>
<ul>
<li>查：如果缓存未命中，就查询数据库，将结果写入缓存，并设置超时时间</li>
<li>改：先修改数据库，再删除缓存。</li>
</ul>
<p>2.2 缓存穿透问题：</p>
<ul>
<li>缓存并缓存空对象，项目中就用的这个</li>
<li>布隆过滤器（实现比较复杂）</li>
</ul>
<p>2.3 缓存击穿问题：</p>
<ul>
<li>使用互斥锁：这里借助Redis提供的<code>setnx</code>方法来实现，本项目就是使用的这个。</li>
<li>逻辑过期：异步构建缓存</li>
</ul>
<h5 id="3优惠卷秒杀">3.优惠卷秒杀</h5>
<p>基于Redis的setNx方法使得满足分布式系统下多进程可见并且互斥的锁。</p>
<p>细节点：</p>
<ul>
<li>利用setnx方法进行加锁，同时增加过期时间，防止死锁。</li>
<li>释放锁时防误删（使用Lua脚本：在存入锁时，放入自己线程的标识，在删除锁时，判断当前这把锁的标识是不是自己存入的）</li>
<li>一人一单：比如时间是否充足，如果时间充足，则进一步判断库存是否足够，然后再根据优惠卷id和用户id查询是否已经下过这个订单，如果下过这个订单，则不再下单，否则进行下单</li>
</ul>
<p>优化：
采用<strong>消息队列</strong>去将判断和执行操作进行异步化。</p>
<ul>
<li>新增秒杀优惠卷的同时，将优惠卷信息保存到Redis中</li>
<li>基于Lua脚本，判断秒杀库存，一人一单，决定用户是否抢购成功</li>
<li>如果抢购成功，将优惠卷id和用户id封装后存入消息队列（这里我们使用Redis中的Stream作为消息队列）</li>
<li>开启线程任务，不断从消息队列中获取信息，实现异步下单操作</li>
</ul>
<h5 id="4-达人探店">4. 达人探店</h5>
<p>4.1 实现一个人只能点赞一次</p>
<ul>
<li>给Blog类中添加一个isLike字段，标示是否被当前用户点赞</li>
<li>修改点赞功能，利用Redis的set集合判断是否点赞过，未点赞过则点赞数+1，已点赞过则点赞数-1</li>
</ul>
<p>4.2 共同关注功能</p>
<ul>
<li>当然是使用我们之前学习过的set集合咯，在set集合中，有交集并集补集的api，我们可以把两人的关注的人分别放入到一个set集合中，然后再通过api去查看这两个set集合中的交集数据。</li>
</ul>
<p>4.3 好友关注-Feed流实现方案+滚动分页的实现</p>
<h5 id="5-查看附近商户">5. 查看附近商户</h5>
<p>使用Redis的GEO数据结构存储经纬度，实现附近商户查询功能。</p>
<p>当我们点击美食之后，会出现一系列的商家，商家中可以按照多种排序方式，我们此时关注的是距离，这个地方就需要使用到我们的GEO，向后台传入当前app收集的地址(我们此处是写死的) ，以当前坐标作为圆心，同时绑定相同的店家类型type，以及分页信息，把这几个条件传入后台，后台查询出对应的数据再返回。</p>
<p>我们要做的事情是：将数据库表中的数据导入到redis中去，redis中的GEO，GEO在redis中就一个menber和一个经纬度，我们把x和y轴传入到redis做的经纬度位置去，但我们不能把所有的数据都放入到menber中去，毕竟作为redis是一个内存级数据库，如果存海量数据，redis还是力不从心，所以我们在这个地方存储他的id即可。</p>
<p>但是这个时候还有一个问题，就是在redis中并没有存储type，所以我们无法根据type来对数据进行筛选，所以我们可以按照商户类型做分组，类型相同的商户作为同一组，以typeId为key存入同一个GEO集合中即可</p>
<h5 id="6全局唯一id">6.全局唯一id</h5>
<p>这个需要通过redis实现分布式id</p>
<p>为了提高数据库的性能，id会采用数值类型（Long）直接插入数据库（因为数值类型在数据库中占用空间较小，建立索引方便，速度更快）。</p>
<p>因为采用的是Long型，有8个字节，64个比特位，</p>
<p>第一个比特位是符号位，永远为0。</p>
<p>中间31个bit为时间戳（以秒为单位，定一个初始的时间，在计算下订单时的时间与初始时间的时间差是多少秒并记录下来，可以使用69年），用来增加ID复杂性，不是单纯的Redis自增。</p>
<p>后面32位bit为序列号，序列号中就是Redis自增的值。支持每秒产生2^32个不同ID</p>
<p>因此如果在一秒钟下了多份订单，即使时间戳相同，那么后面的序列号也会不同。</p>
<p>综上所述，利用redis就能够满足分布式系统中全局唯一ID的五大特性。
注意事项：不能只选择一个key来坐自增长，即无论订单业务持续多长时间，自始至终就只是这一个key在做自增长，随着不断的发展，key的值会也来越大，而redis单个key的自增长的数值是有限度的，上限为2 ^ 64。而且真正用来记录的序列号只有32位bit，如果接下来存的数值超过了2^32位，那么序列号这一部分就存不下。因此不能一直使用同一个key，哪怕是同一个业务。</p>
<p>解决方案，可以在该key后面在拼接一个时间戳，比如哪一天下的订单，当天的key就为 key名+ “20250605”。向下类推。这样还可以统计每一天下单的总量。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">String</span><span class="w"> </span><span class="n">date</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">LocalDateTime</span><span class="p">.</span><span class="na">now</span><span class="p">().</span><span class="na">format</span><span class="p">(</span><span class="n">DateTimeFormatter</span><span class="p">.</span><span class="na">ofPattern</span><span class="p">(</span><span class="s">&#34;yyyy:MM:dd&#34;</span><span class="p">));</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kt">long</span><span class="w"> </span><span class="n">count</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">stringRedisTemplate</span><span class="p">.</span><span class="na">opsForValue</span><span class="p">().</span><span class="na">increment</span><span class="p">(</span><span class="s">&#34;icr:&#34;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">keyPrefix</span><span class="w"> </span><span class="o">+</span><span class="s">&#34;:&#34;</span><span class="o">+</span><span class="w"> </span><span class="n">date</span><span class="p">);</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><hr>
<del>
<h3 id="蛇蛇大作战">蛇蛇大作战</h3>
<h4 id="主要包含模块">主要包含模块：</h4>
<ul>
<li>
<p>pk模块</p>
</li>
<li>
<p>对局列表模块：</p>
</li>
<li>
<p>排行榜模块</p>
</li>
<li>
<p>用户中心模块</p>
</li>
</ul>
<img src="https://i-blog.csdnimg.cn/blog_migrate/d920547a3ff846296c9f05f7b33801f5.jpeg" alt="img" style="zoom:50%;" />
<p>websocket（全双工）</p>
<h4 id="kob项目可能面试题">KOB项目可能面试题</h4>
<h5 id="问题在实现bot服务时如何确保代码的安全性避免恶意代码的执行">问题：在实现Bot服务时，如何确保代码的安全性，避免恶意代码的执行？</h5>
<blockquote>
<p>为确保代码安全性，我们可以对用户提交的Bot代码进行过滤和限制。例如，可以使用沙箱技术隔离代码执行环境，限制代码对系统资源的访问。同时，我们还可以对代码进行静态分析，以识别并阻止潜在的恶意行为。</p></blockquote>
<h5 id="问题请谈谈项目中使用websocket的优势以及在实际应用中遇到的挑战">问题：请谈谈项目中使用WebSocket的优势以及在实际应用中遇到的挑战。</h5>
<blockquote>
<p>WebSocket的主要优势是提供了一种实时双向通信机制，允许服务器与客户端之间进行低延迟、高效的数据交换。这对于在线游戏这样要求快速响应和实时交互的应用场景非常重要。在实际应用中，我们可能会遇到WebSocket连接不稳定、网络延迟和浏览器兼容性等问题。为了解决这些问题，我们需要确保代码具有足够的容错能力，如重连机制，以及对各种浏览器的充分测试。</p></blockquote>
<h5 id="问题在匹配服务中如何根据玩家的分值差距和等待时间进行智能匹配">问题：在匹配服务中，如何根据玩家的分值差距和等待时间进行智能匹配？</h5>
<blockquote>
<p>在匹配服务中，我们使用一个定时线程来定期检查待匹配玩家列表。根据玩家的分值差距和等待时间，我们可以为每个玩家计算一个匹配优先级。优先级越高，匹配的可能性越大。我们可以利用优先级队列来快速找到最佳匹配对手。为了实现更精确的匹配，我们可以根据实际情况调整优先级计算的权重和阈值。</p></blockquote>
<h5 id="问题在项目中为什么选择将功能划分为三个独立的springboot进程模块">问题：在项目中，为什么选择将功能划分为三个独立的SpringBoot进程模块？</h5>
<blockquote>
<p>将主服务、匹配服务和Bot服务独立出来，可以降低各个模块之间的耦合度，使每个模块专注于自己的功能，便于维护和扩展。</p>
<ul>
<li>可扩展性：各个模块可以根据实际需求进行横向扩展，提高系统的整体性能。</li>
<li>容错性：将功能拆分为多个独立的进程可以提高系统的容错性。当某个模块出现故障时，不会影响到其他模块的正常运行。</li>
<li>灵活部署：各个模块可以根据实际情况灵活部署，例如在不同的服务器上运行，以满足不同模块的资源需求。</li>
</ul></blockquote>
<h5 id="问题项目中如何实现线程安全的游戏状态同步">问题：项目中如何实现线程安全的游戏状态同步？</h5>
<blockquote>
<p>为了实现线程安全的游戏状态同步，我们采用了以下策略：</p>
<ol>
<li>对共享资源进行同步访问：在涉及到多线程访问共享资源的地方，我们使用锁或其他同步机制来保证数据的一致性。</li>
<li>尽量减少共享资源：通过将共享资源封装在ThreadLocal中，可以实现线程之间的数据隔离，从而减少同步的需求。</li>
<li>优先使用无锁数据结构：在适当的场景下，使用无锁数据结构（如ConcurrentHashMap、AtomicInteger等）可以降低锁竞争带来的性能开销。</li>
</ol></blockquote>
<h5 id="问题在项目中如何保证bot代码执行的性能和资源占用">问题：在项目中，如何保证Bot代码执行的性能和资源占用？</h5>
<blockquote>
<p>为了保证Bot代码执行的性能和资源占用，我们采用了以下策略：</p>
<ol>
<li>使用线程池：通过线程池控制并发的Bot任务数量，避免过多的线程导致系统资源耗尽。</li>
<li>设置超时限制：为Bot代码执行设置合理的超时限制，防止某些任务长时间占用系统资源。</li>
<li>资源限制：为每个Bot任务分配固定的资源，例如CPU和内存，以防止某些任务过度消耗系统资源。</li>
</ol></blockquote>
<h5 id="问题如何保证匹配服务在高并发情况下的性能">问题：如何保证匹配服务在高并发情况下的性能？</h5>
<blockquote>
<p>为了保证匹配服务在高并发情况下的性能，我们采用了以下策略：</p>
<ol>
<li>使用高性能数据结构：选择高性能的数据结构（如ConcurrentHashMap、PriorityQueue等）来维护待匹配玩家列表，以减小并发访问的性能开销。</li>
<li>异步处理：通过将匹配任务放入队列并采用异步处理方式，可以有效降低用户请求的响应时间。</li>
<li>定时线程：使用定时线程按照分值差距和等待时间进行动态配对，减少匹配过程中的计算量。</li>
</ol></blockquote>
<h5 id="问题在实现bot服务时如何防止恶意代码的执行">问题：在实现Bot服务时，如何防止恶意代码的执行？</h5>
<blockquote>
<p>为了防止恶意代码的执行，我们在Bot服务中采用了以下策略：</p>
<ol>
<li>代码审查：在用户提交Bot代码前，可以通过代码审查工具对其进行安全性检查，过滤掉潜在的恶意代码。</li>
<li>沙箱环境：将Bot代码运行在隔离的沙箱环境中，限制其对系统资源的访问，从而降低恶意代码对系统的影响。</li>
<li>资源限制：为每个Bot任务分配固定的资源，例如CPU和内存，以防止恶意代码消耗过多的系统资源。</li>
</ol></blockquote>
<h5 id="问题在游戏平台中如何处理用户的实时在线对战功能">问题：在游戏平台中，如何处理用户的实时在线对战功能？</h5>
<blockquote>
<p>为了处理用户的实时在线对战功能，我们采用了以下策略：</p>
<ol>
<li>WebSocket：使用WebSocket实现双向实时通信，使服务器能够及时将游戏状态推送给客户端，同时接收客户端的操作。</li>
<li>多线程处理：针对多对玩家的操作，我们采用多线程处理方式，每对玩家的操作在一个独立的线程中执行，以提高并发处理能力。</li>
<li>游戏状态同步：通过服务器端的游戏状态管理和同步机制，确保所有客户端看到的游戏状态是一致的。</li>
</ol></blockquote>
<h4 id="项目整体架构类">项目整体架构类</h4>
<ol>
<li>请简要描述这个项目的整体架构，包括前端、后端和数据库的交互流程。</li>
<li>项目中使用了哪些微服务？它们之间是如何通信和协作的？</li>
<li>请说明项目中不同模块（如匹配系统、对战系统、回放系统）之间的依赖关系和调用逻辑。</li>
</ol>
<h4 id="技术细节类">技术细节类</h4>
<h5 id="前端部分">前端部分</h5>
<ol>
<li>在 <code>web/src/assets/scripts/GameMap.js</code> 中，<code>add_listening_events</code> 方法在回放模式和正常游戏模式下的处理逻辑有何不同？</li>
<li>前端使用了哪些技术来实现游戏的动画效果，如蛇的移动和死亡状态？</li>
<li>前端如何与后端进行数据交互，特别是在获取对局记录和发送玩家操作方面？</li>
</ol>
<h5 id="后端部分">后端部分</h5>
<ol>
<li>在 <code>kob/backendcloud/backend/src/main/java/com/kob/backend/consumer/utils/Game.java</code> 中，<code>nextStep</code> 方法的作用是什么？它是如何实现等待玩家下一步操作的？</li>
<li>后端使用了哪些技术来实现多线程处理，如 <code>Game</code> 类继承 <code>Thread</code> 类的作用和实现方式？</li>
<li>请解释 <code>kob/backendcloud/botrunningsystem/src/main/java/com/kob/botrunningsystem/service/impl/utils/Consumer.java</code> 中 <code>startTimeout</code> 方法的作用和实现逻辑。</li>
</ol>
<h5 id="数据库部分">数据库部分</h5>
<ol>
<li>项目中使用了哪种数据库？请说明数据库表结构，特别是与对局记录相关的表。</li>
<li>在 <code>kob/backendcloud/backend/src/main/java/com/kob/backend/consumer/utils/Game.java</code> 中，<code>saveToDatabase</code> 方法是如何将对局信息保存到数据库中的？</li>
<li>如何保证数据库操作的事务性和数据一致性？</li>
</ol>
<h4 id="问题解决类">问题解决类</h4>
<ol>
<li>如果在对局回放过程中出现卡顿或延迟，你会从哪些方面进行排查和解决？</li>
<li>当多个玩家同时请求匹配时，如何处理并发问题，确保匹配系统的稳定性和公平性？</li>
<li>如果前端无法获取后端的对局记录，你会如何进行调试和定位问题？</li>
</ol>
<h4 id="代码优化类">代码优化类</h4>
<ol>
<li>请分析 <code>web/src/assets/scripts/Snake.js</code> 中 <code>update_move</code> 方法的性能瓶颈，并提出优化建议。</li>
<li>对于 <code>kob/backendcloud/matchingsystem/src/main/java/com/kob/matchingsystem/service/impl/utils/Player.java</code> 类，你认为可以从哪些方面进行代码优化？</li>
<li>如何优化前端的网络请求，减少响应时间和数据传输量？</li>
</ol>
<h4 id="扩展性和维护性类">扩展性和维护性类</h4>
<ol>
<li>如果要增加一种新的游戏模式，你会从哪些方面对项目进行修改和扩展？</li>
<li>如何保证项目代码的可维护性，特别是在多人协作开发的情况下？</li>
<li>请说明项目中使用的依赖管理工具（如 <code>npm</code> 和 <code>Maven</code>）对项目扩展性和维护性的影响。</li>
</ol>
</del>
<hr>
<h2 id="c语法">c++语法</h2>
<p>大根堆：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">priority_queue</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">greater</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">sort</span><span class="p">(</span><span class="n">nums</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">nums</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="p">[](</span><span class="k">const</span> <span class="kt">int</span> <span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="o">&amp;</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="nf">to_string</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">+</span> <span class="n">to_string</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">to_string</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="o">+</span> <span class="n">to_string</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">});</span>
</span></span></code></pre></td></tr></table>
</div>
</div><hr>
<h2 id="java代码题">Java代码题</h2>
<h4 id="交替打印abc">交替打印&quot;ABC&quot;</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kn">import</span><span class="w"> </span><span class="nn">java.util.concurrent.locks.*</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">PrintABCUsingLock</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">Lock</span><span class="w"> </span><span class="n">lock</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">ReentrantLock</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">state</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">0</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">times</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">PrintABCUsingLock</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">times</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">this</span><span class="p">.</span><span class="na">times</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">times</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">printLetter</span><span class="p">(</span><span class="n">String</span><span class="w"> </span><span class="n">str</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">target_state</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">times</span><span class="p">;</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">lock</span><span class="p">.</span><span class="na">lock</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">target_state</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">state</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">3</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="n">i</span><span class="w"> </span><span class="o">++</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="n">state</span><span class="w"> </span><span class="o">++</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="n">str</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">lock</span><span class="p">.</span><span class="na">unlock</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="n">String</span><span class="w"> </span><span class="n">args</span><span class="o">[]</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">PrintABCUsingLock</span><span class="w"> </span><span class="n">printABCUsingLock</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">PrintABCUsingLock</span><span class="p">(</span><span class="n">10</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">new</span><span class="w"> </span><span class="n">Thread</span><span class="p">(()</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">printABCUsingLock</span><span class="p">.</span><span class="na">printLetter</span><span class="p">(</span><span class="s">&#34;a&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">0</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}).</span><span class="na">start</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">new</span><span class="w"> </span><span class="n">Thread</span><span class="p">(()</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">printABCUsingLock</span><span class="p">.</span><span class="na">printLetter</span><span class="p">(</span><span class="s">&#34;b&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">1</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}).</span><span class="na">start</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">new</span><span class="w"> </span><span class="n">Thread</span><span class="p">(()</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">           </span><span class="n">printABCUsingLock</span><span class="p">.</span><span class="na">printLetter</span><span class="p">(</span><span class="s">&#34;c&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">2</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}).</span><span class="na">start</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">PrintABCUsingLock</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">final</span><span class="w"> </span><span class="n">Object</span><span class="w"> </span><span class="n">lock</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Object</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">state</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">0</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">times</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">PrintABCUsingLock</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">times</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">this</span><span class="p">.</span><span class="na">times</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">times</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">printLetter</span><span class="p">(</span><span class="n">String</span><span class="w"> </span><span class="n">str</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">target</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">times</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="kd">synchronized</span><span class="w"> </span><span class="p">(</span><span class="n">lock</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">state</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">3</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">target</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="k">try</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                        </span><span class="n">lock</span><span class="p">.</span><span class="na">wait</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="p">}</span><span class="w"> </span><span class="k">catch</span><span class="w"> </span><span class="p">(</span><span class="n">InterruptedException</span><span class="w"> </span><span class="n">e</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                        </span><span class="k">throw</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">RuntimeException</span><span class="p">(</span><span class="n">e</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="n">state</span><span class="w"> </span><span class="o">++</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="n">str</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="n">lock</span><span class="p">.</span><span class="na">notifyAll</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="n">String</span><span class="o">[]</span><span class="w"> </span><span class="n">args</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">PrintABCUsingLock</span><span class="w"> </span><span class="n">printABCUsingLock</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">PrintABCUsingLock</span><span class="p">(</span><span class="n">5</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">new</span><span class="w"> </span><span class="n">Thread</span><span class="p">(()</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">printABCUsingLock</span><span class="p">.</span><span class="na">printLetter</span><span class="p">(</span><span class="s">&#34;A&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">0</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}).</span><span class="na">start</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">new</span><span class="w"> </span><span class="n">Thread</span><span class="p">(()</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">printABCUsingLock</span><span class="p">.</span><span class="na">printLetter</span><span class="p">(</span><span class="s">&#34;B&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">1</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}).</span><span class="na">start</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">new</span><span class="w"> </span><span class="n">Thread</span><span class="p">(()</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">printABCUsingLock</span><span class="p">.</span><span class="na">printLetter</span><span class="p">(</span><span class="s">&#34;C&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">2</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}).</span><span class="na">start</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><h3 id="交替打印1-100">交替打印1-100</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kn">import</span><span class="w"> </span><span class="nn">java.util.Objects</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kn">import</span><span class="w"> </span><span class="nn">java.util.concurrent.locks.Lock</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kn">import</span><span class="w"> </span><span class="nn">java.util.concurrent.locks.ReentrantLock</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">Print100UsingLock</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">final</span><span class="w"> </span><span class="n">Object</span><span class="w"> </span><span class="n">lock</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Object</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">mx</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">cur</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">1</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">status</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">0</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">Print100UsingLock</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">mx</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">this</span><span class="p">.</span><span class="na">mx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mx</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">printNumber</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">target</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="kc">true</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="kd">synchronized</span><span class="w"> </span><span class="p">(</span><span class="n">lock</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">status</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">3</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">target</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="k">try</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                        </span><span class="n">lock</span><span class="p">.</span><span class="na">wait</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="p">}</span><span class="w"> </span><span class="k">catch</span><span class="w"> </span><span class="p">(</span><span class="n">InterruptedException</span><span class="w"> </span><span class="n">e</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                        </span><span class="k">throw</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">RuntimeException</span><span class="p">(</span><span class="n">e</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">cur</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">mx</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="n">lock</span><span class="p">.</span><span class="na">notifyAll</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="k">break</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="n">status</span><span class="w"> </span><span class="o">++</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="n">cur</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="n">cur</span><span class="w"> </span><span class="o">++</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="n">lock</span><span class="p">.</span><span class="na">notifyAll</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="n">String</span><span class="o">[]</span><span class="w"> </span><span class="n">args</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">Print100UsingLock</span><span class="w"> </span><span class="n">print100UsingLock</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Print100UsingLock</span><span class="p">(</span><span class="n">100</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">new</span><span class="w"> </span><span class="n">Thread</span><span class="p">(()</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">print100UsingLock</span><span class="p">.</span><span class="na">printNumber</span><span class="p">(</span><span class="n">0</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}).</span><span class="na">start</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">new</span><span class="w"> </span><span class="n">Thread</span><span class="p">(()</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">print100UsingLock</span><span class="p">.</span><span class="na">printNumber</span><span class="p">(</span><span class="n">1</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}).</span><span class="na">start</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">new</span><span class="w"> </span><span class="n">Thread</span><span class="p">(()</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">print100UsingLock</span><span class="p">.</span><span class="na">printNumber</span><span class="p">(</span><span class="n">2</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}).</span><span class="na">start</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><hr>
<h2 id="网络">网络</h2>
<h3 id="http的常用方法有哪些">HTTP的常用方法有哪些</h3>
<ul>
<li>GET</li>
<li>POST</li>
<li>DELETE</li>
<li>PUT</li>
<li>HEAD</li>
</ul>
<hr>
<h3 id="有哪些常用状态码">有哪些常用状态码</h3>
<p>
<figure><a class="lightgallery" href="https://cdn.xiaolincoding.com//picgo/1716787749083-7ae2de46-8e84-492e-8ba4-a1521e533e08.webp" title="img" data-thumbnail="https://cdn.xiaolincoding.com//picgo/1716787749083-7ae2de46-8e84-492e-8ba4-a1521e533e08.webp" data-sub-html="<h2> </h2><p>img</p>">
        <img
            class="lazyload"
            src="/svg/loading.min.svg"
            data-src="https://cdn.xiaolincoding.com//picgo/1716787749083-7ae2de46-8e84-492e-8ba4-a1521e533e08.webp"
            data-srcset="https://cdn.xiaolincoding.com//picgo/1716787749083-7ae2de46-8e84-492e-8ba4-a1521e533e08.webp, https://cdn.xiaolincoding.com//picgo/1716787749083-7ae2de46-8e84-492e-8ba4-a1521e533e08.webp 1.5x, https://cdn.xiaolincoding.com//picgo/1716787749083-7ae2de46-8e84-492e-8ba4-a1521e533e08.webp 2x"
            data-sizes="auto"
            alt="https://cdn.xiaolincoding.com//picgo/1716787749083-7ae2de46-8e84-492e-8ba4-a1521e533e08.webp" />
    </a><figcaption class="image-caption">img</figcaption>
    </figure></p>
<p>其中常见的具体状态码有：</p>
<ul>
<li>200:请求成功；</li>
<li>301:永久重定向；302：临时重定向；</li>
<li>‌<strong>HTTP 403 Forbidden</strong>‌ 是客户端错误状态码，表示服务器理解请求但‌拒绝执行，通常是因为客户端‌没有访问资源的权限。404:无法找到此页面；405：请求的方法类型不支持；401 表示“<strong>未授权</strong>”（Unauthorized）</li>
<li>500:服务器内部出错。</li>
</ul>
<hr>
<h3 id="讲一下tcp连接的三次握手和四次挥手">讲一下TCP连接的三次握手和四次挥手</h3>
<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4/%E7%BD%91%E7%BB%9C/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.drawio.png" alt="TCP 三次握手" style="zoom:33%;" />
<p>这样双方都完成了一次“发送-收到回复”的过程。</p>
<p>接下来，从三个方面分析三次握手的原因：</p>
<h5 id="1-三次握手才可以阻止重复历史连接的初始化主要原因">1. 三次握手才可以阻止重复历史连接的初始化（主要原因）</h5>
<p>我们来看看RFC793指出的TCP连接使用三次握手的首要原因：</p>
<p>The principle reason for the three-way handshake is to prevent old duplicate connection initiations fromcausing confusion.</p>
<p>简单来说，三次握手的首要原因是为了防止旧的重复连接初始化造成混乱。</p>
<p>如果是两次握手连接，就无法阻止历史连接，那为什么TCP两次握手为什么无法阻止历史连接呢？</p>
<p>我先直接说结论，主要是因为在两次握手的情况下，服务端没有中间状态给客户端来阻止历史连接，导致服务端可能建立一个历史连接，造成资源浪费。</p>
<h5 id="2-三次握手才可以同步双方的初始序号">2. 三次握手才可以同步双方的初始序号</h5>
<p>TCP协议的通信双方，都必须维护一个「序列号」，序列号是可靠传输的一个关键因素，它的作用：</p>
<ul>
<li>接收方可以去除重复的数据；</li>
<li>接收方可以根据数据包的序列号按序接收；</li>
<li>可以标识发送出去的数据包中，哪些是已经被对方收到的（通过 <code>ACK</code> 报文中的序列号知道）；</li>
</ul>
<h5 id="3-三次握手才可以避免资源浪费">3. 三次握手才可以避免资源浪费</h5>
<p>即两次握手会造成消息滞留情况下，服务端重复接受无用的连接请求 <code>SYN</code> 报文，而造成重复分配资源。</p>
<img src="https://cdn.xiaolincoding.com//mysql/other/format,png-20230309230614791.png" alt="客户端主动关闭连接 —— TCP 四次挥手" style="zoom: 50%;" />
<hr>
<h3 id="tcp和udp共用端口的问题">tcp和udp共用端口的问题</h3>
<p>可以的</p>
<hr>
<h3 id="如何实现一个可靠的udp">如何实现一个可靠的UDP</h3>
<p>UDP本身是无连接、不可靠的传输层协议，但其低延迟和灵活性使其适用于实时性要求高的场景（如游戏、音视频传输）。若需在UDP基础上实现可靠性，需通过‌<strong>应用层协议设计</strong>‌来弥补其不足。以下是实现可靠UDP的核心方案：</p>
<hr>
<h6 id="1-核心机制设计">‌<strong>1. 核心机制设计</strong>‌</h6>
<table>
  <thead>
      <tr>
          <th>‌<strong>机制</strong>‌</th>
          <th>‌<strong>实现目标</strong>‌</th>
          <th>‌<strong>具体方案</strong>‌</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>‌<strong>序列号</strong>‌</td>
          <td>确保数据包顺序正确性</td>
          <td>为每个数据包分配递增的序列号（Sequence Number），接收方按序重组数据。</td>
      </tr>
      <tr>
          <td>‌**确认应答（ACK）**‌</td>
          <td>确认数据包到达，触发重传</td>
          <td>接收方收到数据包后发送ACK，携带已确认的最大序列号或选择性确认（SACK）。</td>
      </tr>
      <tr>
          <td>‌<strong>超时重传</strong>‌</td>
          <td>处理丢包问题</td>
          <td>发送方维护未确认数据包的计时器，超时后重传。动态计算超时时间（基于RTT）。</td>
      </tr>
      <tr>
          <td>‌<strong>流量控制</strong>‌</td>
          <td>防止发送方压垮接收方</td>
          <td>通过滑动窗口机制限制发送速率，接收方动态通告窗口大小（类似TCP）。</td>
      </tr>
      <tr>
          <td>‌<strong>拥塞控制</strong>‌</td>
          <td>避免网络过载</td>
          <td>实现类似TCP的拥塞控制算法（如AIMD、BBR），根据丢包和延迟调整发送速率。</td>
      </tr>
      <tr>
          <td>‌<strong>数据分片与重组</strong>‌</td>
          <td>处理大数据传输</td>
          <td>发送方将应用层数据分片为适合MTU的包，接收方根据序列号重组。</td>
      </tr>
  </tbody>
</table>
<hr>
<h3 id="tsl四次握手">TSL四次握手</h3>
<hr>
<h3 id="ca证书验证流程存储在哪里">CA证书验证流程，存储在哪里？</h3>
<hr>
<h3 id="常见攻击手段和预防手段">常见攻击手段和预防手段</h3>
<h5 id="1-ddos攻击">1. ddos攻击</h5>
<table>
  <thead>
      <tr>
          <th>‌<strong>攻击原理</strong>‌</th>
          <th>‌<strong>常见手法</strong>‌</th>
          <th>‌<strong>预防手段</strong>‌</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>通过海量恶意流量耗尽目标服务器资源，导致服务不可用。</td>
          <td>- ‌<strong>流量型攻击</strong>‌（如UDP Flood、ICMP Flood） - ‌<strong>协议型攻击</strong>‌（如SYN Flood、ACK Flood） - ‌<strong>应用层攻击</strong>‌（如HTTP Flood）</td>
          <td>- ‌<strong>流量清洗</strong>‌：使用CDN或云防护服务（如Cloudflare、AWS Shield）过滤异常流量。 - ‌<strong>限速与黑名单</strong>‌：通过防火墙或Nginx限速（<code>limit_req</code>）。 - ‌<strong>协议优化</strong>‌：配置服务器抵御SYN Flood（如启用<code>SYN Cookies</code>）。 - ‌<strong>负载均衡</strong>‌：分散流量至多台服务器。</td>
      </tr>
  </tbody>
</table>
<h5 id="2-sql注入">2. SQL注入</h5>
<table>
  <thead>
      <tr>
          <th>‌<strong>攻击原理</strong>‌</th>
          <th>‌<strong>常见手法</strong>‌</th>
          <th>‌<strong>预防手段</strong>‌</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>通过注入恶意SQL代码，篡改数据库查询逻辑。</td>
          <td>- ‌<strong>联合查询注入</strong>‌（<code>UNION SELECT</code>） - ‌<strong>布尔盲注</strong>‌ - ‌<strong>时间盲注</strong>‌ - ‌<strong>报错注入</strong>‌</td>
          <td>- ‌<strong>参数化查询</strong>‌：使用预编译语句（如Java的<code>PreparedStatement</code>）。 - ‌<strong>ORM框架</strong>‌：如Hibernate、SQLAlchemy，避免直接拼接SQL。 - ‌<strong>输入过滤</strong>‌：对特殊字符（如<code>'</code>、<code>;</code>）进行转义或白名单验证。 - ‌<strong>最小权限原则</strong>‌：数据库账户仅授予必要权限。</td>
      </tr>
  </tbody>
</table>
<h5 id="3-csrf攻击">3. CSRF攻击</h5>
<table>
  <thead>
      <tr>
          <th>‌<strong>攻击原理</strong>‌</th>
          <th>‌<strong>常见手法</strong>‌</th>
          <th>‌<strong>预防手段</strong>‌</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>诱导用户执行非预期的跨站请求（如转账、改密）。</td>
          <td>- ‌<strong>伪造GET请求</strong>‌（通过图片链接） - ‌<strong>伪造POST表单</strong>‌（通过隐藏表单）</td>
          <td>- ‌<strong>CSRF Token</strong>‌：服务端生成随机Token，嵌入表单或请求头，验证请求来源。 - ‌<strong>SameSite Cookie属性</strong>‌：设置为<code>Strict</code>或<code>Lax</code>（防止跨域携带Cookie）。 - ‌<strong>检查Referer头</strong>‌：验证请求来源域名是否合法。</td>
      </tr>
  </tbody>
</table>
<h5 id="4-xss攻击">4. XSS攻击</h5>
<table>
  <thead>
      <tr>
          <th>‌<strong>攻击原理</strong>‌</th>
          <th>‌<strong>常见手法</strong>‌</th>
          <th>‌<strong>预防手段</strong>‌</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>注入恶意脚本到网页中，窃取用户数据或会话。</td>
          <td>- ‌<strong>存储型XSS</strong>‌（恶意脚本存入数据库） - ‌<strong>反射型XSS</strong>‌（通过URL参数反射脚本） - ‌<strong>DOM型XSS</strong>‌（客户端DOM操作触发）</td>
          <td>- ‌<strong>输入输出过滤</strong>‌：对用户输入进行HTML实体转义（如<code>&lt;</code>转义为<code>&lt;</code>）。 - ‌<strong>Content Security Policy (CSP)<strong>‌：限制脚本来源（如<code>script-src 'self'</code>）。 - ‌</strong>HttpOnly Cookie</strong>‌：防止JavaScript窃取会话Cookie。</td>
      </tr>
  </tbody>
</table>
<hr>
<h3 id="socket有哪些了解wxg快手都问了">Socket有哪些了解（wxg，快手都问了）</h3>
<p>我对 Socket 编程有比较深入的了解，它是在网络编程中实现进程间通信（特别是跨网络通信）的基础技术。以下是我对 Socket 编程关键方面的理解：</p>
<ol>
<li>
<p>‌**核心概念与作用：**‌</p>
<ul>
<li>‌**Socket 的本质：**‌ 是由操作系统提供的一种编程接口（API），是应用层与传输层之间的抽象层。它允许应用程序通过网络发送和接收数据。</li>
<li>‌**通信端点：**‌ 每个 Socket 代表网络通信的一个端点，由 <code>IP地址 + 端口号</code> 唯一标识。</li>
<li>‌**类比：**‌ 类似于电话插座（Socket）和电话机（应用程序），插座提供了连接网络的物理/逻辑接口。</li>
</ul>
</li>
<li>
<p>‌**关键模型：TCP vs UDP：**‌</p>
<ul>
<li>‌TCP (SOCK_STREAM):
<ul>
<li>‌**面向连接：**‌ 通信前需要建立连接（三次握手）。</li>
<li>‌**可靠传输：**‌ 保证数据顺序、无差错、不丢失、不重复地到达。</li>
<li>‌**流式传输：**‌ 数据被视为字节流，没有明确边界。应用程序需要自己处理消息边界（如添加长度前缀或分隔符）。</li>
<li>‌**适用场景：**‌ 需要高可靠性的应用，如网页浏览 (HTTP/HTTPS)、文件传输 (FTP)、电子邮件 (SMTP/POP3/IMAP)、数据库连接。</li>
</ul>
</li>
<li>‌UDP (SOCK_DGRAM):
<ul>
<li>‌**无连接：**‌ 无需建立连接，直接发送数据报。</li>
<li>‌**不可靠传输：**‌ 不保证数据一定到达、到达顺序、不丢失、不重复。可能丢包、乱序。</li>
<li>‌**数据报传输：**‌ 数据以独立的数据包（Datagram）为单位传输，有明确边界。</li>
<li>‌**高效、低延迟：**‌ 由于开销小，通常比 TCP 更快、延迟更低。</li>
<li>‌**适用场景：**‌ 实时性要求高、能容忍少量丢包的应用，如视频/音频直播、在线游戏、DNS 查询、广播/多播应用（如 DHCP）。</li>
</ul>
</li>
</ul>
</li>
<li>
<p>‌**核心编程步骤（以 TCP 服务器为例）：**‌</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="c1"># 伪代码示意核心步骤</span>
</span></span><span class="line"><span class="cl"><span class="c1"># 1. 创建服务器端 Socket (TCP)</span>
</span></span><span class="line"><span class="cl"><span class="n">server_socket</span> <span class="o">=</span> <span class="n">socket</span><span class="o">.</span><span class="n">socket</span><span class="p">(</span><span class="n">socket</span><span class="o">.</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">socket</span><span class="o">.</span><span class="n">SOCK_STREAM</span><span class="p">)</span>  <span class="c1"># AF_INET 指 IPv4</span>
</span></span><span class="line"><span class="cl"><span class="c1"># 2. 绑定 Socket 到地址和端口</span>
</span></span><span class="line"><span class="cl"><span class="n">server_socket</span><span class="o">.</span><span class="n">bind</span><span class="p">((</span><span class="s1">&#39;0.0.0.0&#39;</span><span class="p">,</span> <span class="mi">8080</span><span class="p">))</span>  <span class="c1"># 监听所有网络接口的 8080 端口</span>
</span></span><span class="line"><span class="cl"><span class="c1"># 3. 开始监听连接请求 (TCP特有)</span>
</span></span><span class="line"><span class="cl"><span class="n">server_socket</span><span class="o">.</span><span class="n">listen</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>  <span class="c1"># 设置等待连接队列的最大长度</span>
</span></span><span class="line"><span class="cl"><span class="c1"># 4. 接受客户端连接 (阻塞直到有连接进来)</span>
</span></span><span class="line"><span class="cl"><span class="n">client_socket</span><span class="p">,</span> <span class="n">client_address</span> <span class="o">=</span> <span class="n">server_socket</span><span class="o">.</span><span class="n">accept</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="c1"># 5. 与客户端通信 (接收/发送数据)</span>
</span></span><span class="line"><span class="cl"><span class="n">data</span> <span class="o">=</span> <span class="n">client_socket</span><span class="o">.</span><span class="n">recv</span><span class="p">(</span><span class="mi">1024</span><span class="p">)</span>  <span class="c1"># 接收最多 1024 字节</span>
</span></span><span class="line"><span class="cl"><span class="n">client_socket</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;Hello Client!&#39;</span><span class="p">)</span>  <span class="c1"># 发送数据 (注意字节串)</span>
</span></span><span class="line"><span class="cl"><span class="c1"># 6. 关闭连接</span>
</span></span><span class="line"><span class="cl"><span class="n">client_socket</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="c1"># 7. (可选) 回到步骤4接收新连接 或 关闭服务器Socket</span>
</span></span><span class="line"><span class="cl"><span class="n">server_socket</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>‌**核心编程步骤（以 TCP 客户端为例）：**‌</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="c1"># 伪代码示意核心步骤</span>
</span></span><span class="line"><span class="cl"><span class="c1"># 1. 创建客户端 Socket (TCP)</span>
</span></span><span class="line"><span class="cl"><span class="n">client_socket</span> <span class="o">=</span> <span class="n">socket</span><span class="o">.</span><span class="n">socket</span><span class="p">(</span><span class="n">socket</span><span class="o">.</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">socket</span><span class="o">.</span><span class="n">SOCK_STREAM</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="c1"># 2. 连接到服务器 (TCP特有)</span>
</span></span><span class="line"><span class="cl"><span class="n">client_socket</span><span class="o">.</span><span class="n">connect</span><span class="p">((</span><span class="s1">&#39;server_ip&#39;</span><span class="p">,</span> <span class="mi">8080</span><span class="p">))</span>  <span class="c1"># 替换为实际服务器IP和端口</span>
</span></span><span class="line"><span class="cl"><span class="c1"># 3. 与服务器通信 (发送/接收数据)</span>
</span></span><span class="line"><span class="cl"><span class="n">client_socket</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;Hello Server!&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">data</span> <span class="o">=</span> <span class="n">client_socket</span><span class="o">.</span><span class="n">recv</span><span class="p">(</span><span class="mi">1024</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="c1"># 4. 关闭连接</span>
</span></span><span class="line"><span class="cl"><span class="n">client_socket</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>‌**关键技术与概念：**‌</p>
<ul>
<li>‌**地址族：**‌ <code>AF_INET</code> (IPv4), <code>AF_INET6</code> (IPv6), <code>AF_UNIX</code> (本地 Unix 域套接字)。</li>
<li>‌**套接字类型：**‌ <code>SOCK_STREAM</code> (TCP), <code>SOCK_DGRAM</code> (UDP), <code>SOCK_RAW</code> (原始套接字)。</li>
<li>‌阻塞 vs 非阻塞：
<ul>
<li>‌**阻塞：**‌ 调用 <code>accept()</code>, <code>connect()</code>, <code>recv()</code>, <code>send()</code> 等函数时，程序会暂停执行，直到操作完成（如连接建立、数据到达）。</li>
<li>‌**非阻塞：**‌ 这些函数会立即返回，无论操作是否完成。需要使用 <code>select</code>, <code>poll</code>, <code>epoll</code> (Linux), <code>kqueue</code> (BSD/macOS) 或异步 I/O 模型（如 <code>asyncio</code>）来高效管理多个 Socket。</li>
</ul>
</li>
<li>‌**I/O 多路复用：**‌ <code>select</code>, <code>poll</code>, <code>epoll</code>, <code>kqueue</code> 等技术，允许一个进程/线程同时监视多个 Socket 的状态（是否可读、可写、有异常），提高并发性能。</li>
<li>‌**字节序：**‌ 网络字节序是大端序。需要使用 <code>htonl()</code>, <code>htons()</code>, <code>ntohl()</code>, <code>ntohs()</code> 等函数在主机字节序和网络字节序之间转换数据（尤其是多字节整数和端口号）。</li>
<li>‌**粘包/拆包：**‌ TCP 流式传输的特性导致发送方多次发送的数据可能在接收方缓冲区中被合并成一个数据块（粘包），或者一个数据块被拆分成多次接收（拆包）。应用程序需要设计协议（如固定长度、长度前缀、分隔符）来处理边界。</li>
<li>‌**错误处理：**‌ 网络通信异常丰富（连接超时、中断、对端关闭、资源不足等），健壮的 Socket 程序必须妥善处理各种错误和异常。</li>
<li>‌**超时设置：**‌ 可以为 Socket 操作设置超时时间 (<code>settimeout()</code>)，防止程序无限期阻塞。</li>
</ul>
</li>
<li>
<p>‌**实际应用：**‌</p>
<ul>
<li>几乎所有网络应用底层都使用 Socket：Web 服务器 (Nginx, Apache)、数据库 (MySQL, Redis)、消息队列 (RabbitMQ, Kafka)、FTP/SFTP 客户端/服务器、邮件客户端/服务器、即时通讯软件、网络游戏、自定义协议的分布式系统通信等。</li>
</ul>
</li>
</ol>
<hr>
<h2 id="场景题">场景题</h2>
<h3 id="如何利用线程池去实现一个比如整点进行日志记录功能">如何利用线程池去实现一个比如整点进行日志记录功能</h3>
<p>【美团面试没做出来血的教训】</p>
<h3 id="三个服务器如何进行负载均衡让同一内容的请求打到同一台副本上以及如何动态扩容在不影响前面三台机器的前提下">三个服务器如何进行负载均衡，让同一内容的请求打到同一台副本上，以及如何动态扩容在不影响前面三台机器的前提下</h3>
<p>【百度面试没做出来血的教训】</p>
<p>提前预估出1000个哈希桶，然后进行划分（也就是做好提前量）</p>
<h3 id="如何用redis筛选出前100名的排行榜也就是动态更新redis同时用户非常多redis中放不下所有的">如何用redis筛选出前100名的排行榜，也就是动态更新redis，同时用户非常多，redis中放不下所有的</h3>
<p>【快手面试没做出来血的教训】</p>
<hr>
<h2 id="操作系统">操作系统</h2>
<h3 id="进程线程和协程">进程，线程和协程</h3>
<p>最后是协程。协程是一种用户态的轻量级线程，其调度完全由用户程序控制，而不需要内核的参与。协程拥有自己的寄存器上下文和栈，但与其他协程共享堆内存。协程的切换开销非常小，因为只需要保存和恢复协程的上下文，而无需进行内核级的上下文切换。这使得协程在处理大量并发任务时具有非常高的效率。然而，协程需要程序员显式地进行调度和管理，相对于线程和进程来说，其编程模型更为复杂。</p>
<h5 id="二协程的核心优势">‌<strong>二、协程的核心优势</strong>‌</h5>
<h6 id="1-轻量级并发">‌<strong>1. 轻量级并发</strong>‌</h6>
<ul>
<li>‌<strong>内存占用极低</strong>‌：协程栈大小通常为KB级（如Go的goroutine默认2KB）。</li>
<li>‌<strong>切换成本极低</strong>‌：协程切换在用户态完成（无需内核介入），单次切换耗时约100纳秒。</li>
<li>‌<strong>支持超高并发</strong>‌：单机可轻松创建数百万协程（如Go的goroutine）。</li>
</ul>
<hr>
<h3 id="selectpoll和epoll讲讲区别">select、poll和epoll讲讲区别</h3>
<h4 id="核心对比表">核心对比表</h4>
<p>IO复用技术</p>
<table>
  <thead>
      <tr>
          <th>特性</th>
          <th>select</th>
          <th>poll</th>
          <th>epoll</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>‌<strong>时间复杂度</strong>‌</td>
          <td>O(n) - 每次轮询所有fd</td>
          <td>O(n) - 每次轮询所有fd</td>
          <td>O(1) - 只处理就绪事件</td>
      </tr>
      <tr>
          <td>‌<strong>最大文件描述符</strong>‌</td>
          <td>有限制 (通常1024)</td>
          <td>无硬性限制</td>
          <td>无硬性限制</td>
      </tr>
      <tr>
          <td>‌<strong>工作方式</strong>‌</td>
          <td>轮询所有文件描述符</td>
          <td>轮询所有文件描述符</td>
          <td>回调通知机制</td>
      </tr>
      <tr>
          <td>‌<strong>内核数据结构</strong>‌</td>
          <td>位图 (fd_set)</td>
          <td>链表 (pollfd)</td>
          <td>红黑树+就绪链表</td>
      </tr>
      <tr>
          <td>‌<strong>触发模式</strong>‌</td>
          <td>仅支持水平触发 (LT)</td>
          <td>仅支持水平触发 (LT)</td>
          <td>支持水平触发 (LT) + 边缘触发 (ET)</td>
      </tr>
      <tr>
          <td>‌<strong>内存拷贝开销</strong>‌</td>
          <td>每次调用需复制整个fd_set</td>
          <td>每次调用需复制整个pollfd数组</td>
          <td>注册时一次拷贝</td>
      </tr>
      <tr>
          <td>‌<strong>适用场景</strong>‌</td>
          <td>低并发/跨平台场景</td>
          <td>需要更多fd但并发不高</td>
          <td>高并发场景 (&gt;1000连接)</td>
      </tr>
      <tr>
          <td>‌<strong>API复杂度</strong>‌</td>
          <td>简单</td>
          <td>较简单</td>
          <td>较复杂</td>
      </tr>
      <tr>
          <td>‌<strong>跨平台性</strong>‌</td>
          <td>广泛支持</td>
          <td>POSIX标准</td>
          <td>Linux特有</td>
      </tr>
  </tbody>
</table>
<hr>
<h3 id="内核态与用户态">内核态与用户态</h3>
<hr>
<h3 id="操作系统中进程死锁条件那四个如何死锁避免死锁检测">操作系统中进程死锁条件（那四个），如何死锁避免，死锁检测</h3>
<h5 id="死锁的四个必要条件必须同时存在才会死锁">‌<strong>死锁的四个必要条件</strong>‌（必须同时存在才会死锁）</h5>
<table>
  <thead>
      <tr>
          <th>‌<strong>条件</strong>‌</th>
          <th>‌<strong>说明</strong>‌</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>1. ‌<strong>互斥</strong>‌</td>
          <td>资源一次只能被一个进程独占（如打印机）</td>
      </tr>
      <tr>
          <td>2. ‌<strong>占有并等待</strong>‌</td>
          <td>进程已持有资源，同时请求新资源且不释放已有资源</td>
      </tr>
      <tr>
          <td>3. ‌<strong>不可抢占</strong>‌</td>
          <td>资源只能由持有者主动释放，不可强行剥夺</td>
      </tr>
      <tr>
          <td>4. ‌<strong>循环等待</strong>‌</td>
          <td>进程间形成环形等待链：P1等P2的资源，P2等P3的资源&hellip; Pn等P1的资源</td>
      </tr>
  </tbody>
</table>
<h5 id="死锁避免策略预防死锁发生">‌<strong>死锁避免策略</strong>‌（预防死锁发生）</h5>
<ol>
<li>‌<strong>资源分配策略</strong>‌
<ul>
<li>‌银行家算法：进程申请资源时，预判分配后系统是否仍处于‌安全状态‌（即存在安全序列）
<ul>
<li>若不安全则拒绝分配（即使当前资源足够）</li>
</ul>
</li>
<li>‌<strong>资源有序分配法</strong>‌：为所有资源类型定义全局顺序，进程必须按序申请资源（如只能先申请A再申请B）</li>
</ul>
</li>
<li>‌<strong>进程启动控制</strong>‌
<ul>
<li>新进程启动时检查其最大资源需求，若可能引发不安全状态则延迟启动</li>
</ul>
</li>
</ol>
<h5 id="死锁检测方法发生后识别">‌<strong>‌死锁检测方法</strong>‌（发生后识别）</h5>
<ol>
<li>‌<strong>资源分配图（RAG）检测</strong>‌
<ul>
<li>‌<strong>顶点</strong>‌：进程（P） + 资源类型（R）</li>
<li>‌边：
<ul>
<li>‌<strong>请求边</strong>‌ P → R（进程等待资源）</li>
<li>‌<strong>分配边</strong>‌ R → P（资源已被进程占用）</li>
</ul>
</li>
<li>‌<strong>检测循环</strong>‌：使用图算法（如DFS）检查图中是否存在闭环 → 存在环即死锁</li>
</ul>
</li>
<li>‌<strong>检测时机</strong>‌
<ul>
<li>定时检测（如每5分钟）</li>
<li>当CPU利用率骤降时触发检测</li>
</ul>
</li>
</ol>
<h5 id="死锁恢复手段检测到后处理">‌<strong>死锁恢复手段</strong>‌（检测到后处理）</h5>
<table>
  <thead>
      <tr>
          <th>‌<strong>方法</strong>‌</th>
          <th>‌<strong>操作</strong>‌</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>‌<strong>进程终止</strong>‌</td>
          <td>强制终止所有死锁进程（简单粗暴）或按优先级逐步终止进程直到死锁解除</td>
      </tr>
      <tr>
          <td>‌<strong>资源抢占</strong>‌</td>
          <td>强制回收某个进程的资源（需解决被抢占进程的后续恢复问题，如回滚操作）</td>
      </tr>
  </tbody>
</table>
<hr>
<h2 id="mysql">MySQL</h2>
<h3 id="sql基础">SQL基础</h3>
<h4 id="数据库三大范式是什么">数据库三大范式是什么</h4>
<p>好的！数据库的三大范式（Normalization）是关系型数据库设计的核心原则，目的是减少数据冗余、提高数据一致性。<strong>我用生活中的例子帮你轻松理解，保证不枯燥！</strong></p>
<hr>
<h5 id="先看一个反面教材表格"><strong>先看一个“反面教材”表格</strong></h5>
<p>假设设计一个「学生课程表」，直接存成这样：</p>
<table>
  <thead>
      <tr>
          <th style="text-align: left"><strong>学号</strong></th>
          <th style="text-align: left"><strong>姓名</strong></th>
          <th style="text-align: left"><strong>课程</strong></th>
          <th style="text-align: left"><strong>学分</strong></th>
          <th style="text-align: left"><strong>教师</strong></th>
          <th style="text-align: left"><strong>教师办公室</strong></th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td style="text-align: left">1001</td>
          <td style="text-align: left">张三</td>
          <td style="text-align: left">数学,英语</td>
          <td style="text-align: left">4,3</td>
          <td style="text-align: left">王老师</td>
          <td style="text-align: left">A栋301, B栋202</td>
      </tr>
      <tr>
          <td style="text-align: left">1002</td>
          <td style="text-align: left">李四</td>
          <td style="text-align: left">物理</td>
          <td style="text-align: left">2</td>
          <td style="text-align: left">张老师</td>
          <td style="text-align: left">C栋105</td>
      </tr>
  </tbody>
</table>
<p><strong>问题</strong>：</p>
<ol>
<li><strong>数据冗余</strong>：同一门课程的教师和办公室被重复存储。</li>
<li><strong>更新异常</strong>：如果“王老师”换办公室，所有相关行都要改。</li>
<li><strong>插入异常</strong>：新教师没安排课程时，无法录入信息。</li>
<li><strong>删除异常</strong>：删除某门课程可能连带删除教师信息。</li>
</ol>
<hr>
<h5 id="第一范式1nf原子性"><strong>第一范式（1NF）——原子性</strong></h5>
<p><strong>核心要求</strong>：每列的值必须是<strong>不可再分的最小数据单元</strong>（原子性）。
<strong>问题</strong>：上表中“课程”、“学分”、“教师”、“教师办公室”包含多个值。
<strong>解决方案</strong>：拆分为单值：</p>
<table>
  <thead>
      <tr>
          <th style="text-align: left"><strong>学号</strong></th>
          <th style="text-align: left"><strong>姓名</strong></th>
          <th style="text-align: left"><strong>课程</strong></th>
          <th style="text-align: left"><strong>学分</strong></th>
          <th style="text-align: left"><strong>教师</strong></th>
          <th style="text-align: left"><strong>教师办公室</strong></th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td style="text-align: left">1001</td>
          <td style="text-align: left">张三</td>
          <td style="text-align: left">数学</td>
          <td style="text-align: left">4</td>
          <td style="text-align: left">王老师</td>
          <td style="text-align: left">A栋301</td>
      </tr>
      <tr>
          <td style="text-align: left">1001</td>
          <td style="text-align: left">张三</td>
          <td style="text-align: left">英语</td>
          <td style="text-align: left">3</td>
          <td style="text-align: left">李老师</td>
          <td style="text-align: left">B栋202</td>
      </tr>
      <tr>
          <td style="text-align: left">1002</td>
          <td style="text-align: left">李四</td>
          <td style="text-align: left">物理</td>
          <td style="text-align: left">2</td>
          <td style="text-align: left">张老师</td>
          <td style="text-align: left">C栋105</td>
      </tr>
  </tbody>
</table>
<p><strong>关键点</strong>：</p>
<ul>
<li>每行数据描述一个<strong>独立实体</strong>（比如一门课程）。</li>
<li>但仍有冗余（如“张老师”的信息重复）。</li>
</ul>
<hr>
<h5 id="第二范式2nf消除部分依赖"><strong>第二范式（2NF）——消除部分依赖</strong></h5>
<p><strong>核心要求</strong>：表中每个字段必须<strong>完全依赖主键</strong>（不能只依赖主键的一部分）。
<strong>前提</strong>：表必须有<strong>复合主键</strong>（多个字段共同作为主键）。</p>
<p><strong>分析上表</strong>：</p>
<ul>
<li><strong>主键</strong>是（学号, 课程），因为需要这两个字段唯一标识一行。</li>
<li><strong>问题</strong>：
<ul>
<li>“姓名”只依赖学号（与课程无关）→ <strong>部分依赖</strong>。</li>
<li>“教师”和“教师办公室”只依赖课程（与学号无关）→ <strong>部分依赖</strong>。</li>
</ul>
</li>
</ul>
<p><strong>解决方案</strong>：拆分为三张表！</p>
<ol>
<li>
<p><strong>学生表</strong>（主键：学号）：</p>
<table>
  <thead>
      <tr>
          <th style="text-align: left">学号</th>
          <th style="text-align: left">姓名</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td style="text-align: left">1001</td>
          <td style="text-align: left">张三</td>
      </tr>
      <tr>
          <td style="text-align: left">1002</td>
          <td style="text-align: left">李四</td>
      </tr>
  </tbody>
</table>
</li>
<li>
<p><strong>课程表</strong>（主键：课程）：</p>
<table>
  <thead>
      <tr>
          <th style="text-align: left">课程</th>
          <th style="text-align: left">学分</th>
          <th style="text-align: left">教师</th>
          <th style="text-align: left">教师办公室</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td style="text-align: left">数学</td>
          <td style="text-align: left">4</td>
          <td style="text-align: left">王老师</td>
          <td style="text-align: left">A栋301</td>
      </tr>
      <tr>
          <td style="text-align: left">英语</td>
          <td style="text-align: left">3</td>
          <td style="text-align: left">李老师</td>
          <td style="text-align: left">B栋202</td>
      </tr>
      <tr>
          <td style="text-align: left">物理</td>
          <td style="text-align: left">2</td>
          <td style="text-align: left">张老师</td>
          <td style="text-align: left">C栋105</td>
      </tr>
  </tbody>
</table>
</li>
<li>
<p><strong>选课表</strong>（主键：学号+课程）：</p>
<table>
  <thead>
      <tr>
          <th style="text-align: left">学号</th>
          <th style="text-align: left">课程</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td style="text-align: left">1001</td>
          <td style="text-align: left">数学</td>
      </tr>
      <tr>
          <td style="text-align: left">1001</td>
          <td style="text-align: left">英语</td>
      </tr>
      <tr>
          <td style="text-align: left">1002</td>
          <td style="text-align: left">物理</td>
      </tr>
  </tbody>
</table>
</li>
</ol>
<p><strong>关键点</strong>：</p>
<ul>
<li>每张表只描述一件事（学生、课程、选课关系）。</li>
<li>冗余消除：教师信息只存一次，修改时只需改一处。</li>
</ul>
<hr>
<h5 id="第三范式3nf消除传递依赖"><strong>第三范式（3NF）——消除传递依赖</strong></h5>
<p><strong>核心要求</strong>：表中字段不能依赖其他非主键字段（即避免“间接依赖”）。</p>
<p><strong>分析课程表</strong>：</p>
<ul>
<li>主键是“课程”。</li>
<li>“教师办公室”依赖“教师”（教师 → 教师办公室），而“教师”依赖主键“课程”。</li>
<li>存在<strong>传递依赖</strong>：课程 → 教师 → 教师办公室。</li>
</ul>
<p><strong>问题</strong>：</p>
<ul>
<li>如果“王老师”换办公室，需修改所有他教授的课程对应的行。</li>
</ul>
<p><strong>解决方案</strong>：继续拆分！</p>
<ol>
<li>
<p><strong>教师表</strong>（主键：教师）：</p>
<table>
  <thead>
      <tr>
          <th style="text-align: left">教师</th>
          <th style="text-align: left">教师办公室</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td style="text-align: left">王老师</td>
          <td style="text-align: left">A栋301</td>
      </tr>
      <tr>
          <td style="text-align: left">李老师</td>
          <td style="text-align: left">B栋202</td>
      </tr>
      <tr>
          <td style="text-align: left">张老师</td>
          <td style="text-align: left">C栋105</td>
      </tr>
  </tbody>
</table>
</li>
<li>
<p><strong>课程表</strong>（主键：课程）：</p>
<table>
  <thead>
      <tr>
          <th style="text-align: left">课程</th>
          <th style="text-align: left">学分</th>
          <th style="text-align: left">教师</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td style="text-align: left">数学</td>
          <td style="text-align: left">4</td>
          <td style="text-align: left">王老师</td>
      </tr>
      <tr>
          <td style="text-align: left">英语</td>
          <td style="text-align: left">3</td>
          <td style="text-align: left">李老师</td>
      </tr>
      <tr>
          <td style="text-align: left">物理</td>
          <td style="text-align: left">2</td>
          <td style="text-align: left">张老师</td>
      </tr>
  </tbody>
</table>
</li>
</ol>
<p><strong>关键点</strong>：</p>
<ul>
<li>教师办公室信息只与教师相关，和课程无关。</li>
<li>修改教师办公室时，只需改“教师表”中的一行。</li>
</ul>
<hr>
<h5 id="总结三大范式的作用"><strong>总结：三大范式的作用</strong></h5>
<table>
  <thead>
      <tr>
          <th style="text-align: left"><strong>范式</strong></th>
          <th style="text-align: left"><strong>核心要求</strong></th>
          <th style="text-align: left"><strong>解决的问题</strong></th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td style="text-align: left">1NF</td>
          <td style="text-align: left">数据原子性</td>
          <td style="text-align: left">字段不可再分（如拆分多值字段）</td>
      </tr>
      <tr>
          <td style="text-align: left">2NF</td>
          <td style="text-align: left">消除部分依赖</td>
          <td style="text-align: left">拆分依赖复合主键的部分字段</td>
      </tr>
      <tr>
          <td style="text-align: left">3NF</td>
          <td style="text-align: left">消除传递依赖</td>
          <td style="text-align: left">拆分间接依赖的非主键字段</td>
      </tr>
  </tbody>
</table>
<h5 id="1-减少数据冗余"><strong>1. 减少数据冗余</strong></h5>
<ul>
<li>
<p><strong>问题</strong>：如果数据重复存储（如学生表中每个课程都重复学生姓名），会浪费存储空间，且容易导致数据不一致。</p>
</li>
<li>
<p><strong>解决</strong>：通过拆分表（如学生表、课程表、选课表），每个信息只存一次。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="c1">-- 反例：冗余存储学生姓名和课程信息
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">CREATE</span><span class="w"> </span><span class="k">TABLE</span><span class="w"> </span><span class="n">bad_design</span><span class="w"> </span><span class="p">(</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">student_id</span><span class="w"> </span><span class="nb">INT</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">student_name</span><span class="w"> </span><span class="nb">VARCHAR</span><span class="p">(</span><span class="mi">50</span><span class="p">),</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">course_name</span><span class="w"> </span><span class="nb">VARCHAR</span><span class="p">(</span><span class="mi">50</span><span class="p">),</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">teacher</span><span class="w"> </span><span class="nb">VARCHAR</span><span class="p">(</span><span class="mi">50</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">-- 遵循范式：拆分为多表
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">CREATE</span><span class="w"> </span><span class="k">TABLE</span><span class="w"> </span><span class="n">students</span><span class="w"> </span><span class="p">(</span><span class="n">student_id</span><span class="w"> </span><span class="nb">INT</span><span class="w"> </span><span class="k">PRIMARY</span><span class="w"> </span><span class="k">KEY</span><span class="p">,</span><span class="w"> </span><span class="n">student_name</span><span class="w"> </span><span class="nb">VARCHAR</span><span class="p">(</span><span class="mi">50</span><span class="p">));</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">CREATE</span><span class="w"> </span><span class="k">TABLE</span><span class="w"> </span><span class="n">courses</span><span class="w"> </span><span class="p">(</span><span class="n">course_id</span><span class="w"> </span><span class="nb">INT</span><span class="w"> </span><span class="k">PRIMARY</span><span class="w"> </span><span class="k">KEY</span><span class="p">,</span><span class="w"> </span><span class="n">course_name</span><span class="w"> </span><span class="nb">VARCHAR</span><span class="p">(</span><span class="mi">50</span><span class="p">),</span><span class="w"> </span><span class="n">teacher</span><span class="w"> </span><span class="nb">VARCHAR</span><span class="p">(</span><span class="mi">50</span><span class="p">));</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">CREATE</span><span class="w"> </span><span class="k">TABLE</span><span class="w"> </span><span class="n">enrollments</span><span class="w"> </span><span class="p">(</span><span class="n">student_id</span><span class="w"> </span><span class="nb">INT</span><span class="p">,</span><span class="w"> </span><span class="n">course_id</span><span class="w"> </span><span class="nb">INT</span><span class="p">);</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
<h5 id="2-避免更新异常"><strong>2. 避免更新异常</strong></h5>
<ul>
<li>
<p><strong>问题</strong>：冗余数据会导致修改时多处同步。</p>
<ul>
<li>例如，如果“王老师”的办公室地址在多个课程行中重复存储，修改时漏掉某一行会导致数据不一致。</li>
</ul>
</li>
<li>
<p><strong>解决</strong>：通过范式拆分后，只需在「教师表」中修改一次。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="c1">-- 反范式设计（修改麻烦）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">UPDATE</span><span class="w"> </span><span class="n">courses</span><span class="w"> </span><span class="k">SET</span><span class="w"> </span><span class="n">teacher_office</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s1">&#39;A栋302&#39;</span><span class="w"> </span><span class="k">WHERE</span><span class="w"> </span><span class="n">teacher</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s1">&#39;王老师&#39;</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">-- 范式设计（只需改一处）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">UPDATE</span><span class="w"> </span><span class="n">teachers</span><span class="w"> </span><span class="k">SET</span><span class="w"> </span><span class="n">office</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s1">&#39;A栋302&#39;</span><span class="w"> </span><span class="k">WHERE</span><span class="w"> </span><span class="n">teacher_name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s1">&#39;王老师&#39;</span><span class="p">;</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
<h5 id="3-消除插入和删除异常"><strong>3. 消除插入和删除异常</strong></h5>
<ul>
<li>
<p><strong>问题</strong>：</p>
<ul>
<li><strong>插入异常</strong>：无法单独插入未分配课程的教师信息。</li>
<li><strong>删除异常</strong>：删除某门课程可能连带删除教师信息。</li>
</ul>
</li>
<li>
<p><strong>解决</strong>：拆分表后，教师和课程独立存在。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="c1">-- 插入异常示例（反范式）：
</span></span></span><span class="line"><span class="cl"><span class="c1">-- 如果“新教师”未授课，无法插入到课程表中。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">-- 范式设计下：
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">INSERT</span><span class="w"> </span><span class="k">INTO</span><span class="w"> </span><span class="n">teachers</span><span class="w"> </span><span class="p">(</span><span class="n">teacher_name</span><span class="p">,</span><span class="w"> </span><span class="n">office</span><span class="p">)</span><span class="w"> </span><span class="k">VALUES</span><span class="w"> </span><span class="p">(</span><span class="s1">&#39;赵老师&#39;</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;D栋101&#39;</span><span class="p">);</span><span class="w"> </span><span class="c1">-- 允许独立插入
</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
<h5 id="4-提高数据一致性"><strong>4. 提高数据一致性</strong></h5>
<ul>
<li>
<p><strong>问题</strong>：冗余数据可能导致矛盾（如某个课程的学分在不同行中不一致）。</p>
</li>
<li>
<p><strong>解决</strong>：通过范式设计，学分只存储在「课程表」中，所有引用该课程的地方通过外键关联，确保一致性。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="c1">-- 反范式设计（学分可能不一致）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">INSERT</span><span class="w"> </span><span class="k">INTO</span><span class="w"> </span><span class="n">bad_table</span><span class="w"> </span><span class="p">(</span><span class="n">course_name</span><span class="p">,</span><span class="w"> </span><span class="n">credit</span><span class="p">)</span><span class="w"> </span><span class="k">VALUES</span><span class="w"> </span><span class="p">(</span><span class="s1">&#39;数学&#39;</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">INSERT</span><span class="w"> </span><span class="k">INTO</span><span class="w"> </span><span class="n">bad_table</span><span class="w"> </span><span class="p">(</span><span class="n">course_name</span><span class="p">,</span><span class="w"> </span><span class="n">credit</span><span class="p">)</span><span class="w"> </span><span class="k">VALUES</span><span class="w"> </span><span class="p">(</span><span class="s1">&#39;数学&#39;</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">);</span><span class="w"> </span><span class="c1">-- 矛盾！
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">-- 范式设计（学分唯一）：
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">CREATE</span><span class="w"> </span><span class="k">TABLE</span><span class="w"> </span><span class="n">courses</span><span class="w"> </span><span class="p">(</span><span class="n">course_id</span><span class="w"> </span><span class="nb">INT</span><span class="w"> </span><span class="k">PRIMARY</span><span class="w"> </span><span class="k">KEY</span><span class="p">,</span><span class="w"> </span><span class="n">credit</span><span class="w"> </span><span class="nb">INT</span><span class="p">);</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
<h5 id="5-增强可维护性"><strong>5. 增强可维护性</strong></h5>
<ul>
<li>
<p><strong>问题</strong>：当业务需求变化时（如新增字段），冗余的表结构修改成本高。</p>
</li>
<li>
<p><strong>解决</strong>：范式设计后，表结构清晰，修改只需调整局部。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="c1">-- 反范式设计：新增“课程类型”字段需修改所有相关行。
</span></span></span><span class="line"><span class="cl"><span class="c1">-- 范式设计：只需在「课程表」中加一列。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">ALTER</span><span class="w"> </span><span class="k">TABLE</span><span class="w"> </span><span class="n">courses</span><span class="w"> </span><span class="k">ADD</span><span class="w"> </span><span class="k">COLUMN</span><span class="w"> </span><span class="n">course_type</span><span class="w"> </span><span class="nb">VARCHAR</span><span class="p">(</span><span class="mi">20</span><span class="p">);</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
<hr>
<h4 id="mysql-怎么连表查询">MySQL 怎么连表查询？</h4>
<p>数据库有以下几种联表查询类型：</p>
<ol>
<li>内连接(INNERJOIN)</li>
<li>左外连接（LEFTJOIN)</li>
<li>右外连接(RIGHTJOIN)</li>
<li>全外连接(FULLJOIN）</li>
</ol>
<hr>
<h4 id="讲讲acid">讲讲ACID</h4>
<p>这四个特性分别是<strong>原子性（Atomicity）</strong>、<strong>一致性（Consistency）</strong>、<strong>隔离性（Isolation）</strong> 和<strong>持久性（Durability）</strong>。</p>
<hr>
<h3 id="存储引擎">存储引擎</h3>
<h4 id="讲一讲mysql的引擎吧你有什么了解">讲一讲mysql的引擎吧，你有什么了解？</h4>
<ul>
<li>
<p>InnoDB：InnoDB是MySQL的默认存储引l擎，具有ACID事务支持、行级锁、外键约束等特性。它适用于
高并发的读写操作，支持较好的数据完整性和并发控制。</p>
</li>
<li>
<p>MyISAM：MyISAM是MySQL的另一种常见的存储引擎，具有较低的存储空间和内存消耗，适用于大量
读操作的场景。然而，MyISAM不支持事务、行级锁和外键约束，因此在并发写入和数据完整性方面有
一定的限制。</p>
</li>
<li>
<p>Memory：Memory引l擎将数据存储在内存中，适用于对性能要求较高的读操作，但是在服务器重启或
崩溃时数据会丢失。它不支持事务、行级锁和外键约束。</p>
</li>
</ul>
<hr>
<h3 id="索引">索引</h3>
<h4 id="索引有哪些优化手段讲一下b树索引">索引有哪些优化手段，讲一下B+树索引</h4>
<p>常见优化索引|的方法：</p>
<ul>
<li>
<p>前缀索引优化：使用前缀索引是为了减小索引字段大小，可以增加一个索引顶中存储的索引值，有效提
高索引的查询速度。在一些大字符串的字段作为索引时，使用前缀索引可以帮助我们减小索引项的大
小。</p>
</li>
<li>
<p>覆盖索引I优化：覆盖索引是指SQL中query的所有字段，在索引|B+Tree的叶子节点上都能找得到的那
些索引，从二级索引中查询得到记录，而不需要通过聚簇索引查询获得，可以避免回表的操作。</p>
</li>
<li>
<p>主键索引最好是自增的：</p>
<p>​	○  如果我们使用自增主键，那么每次插入的新数据就会按顺序添加到当前索引节点的位置，不需要移
​	动已有的数据，当页面写满，就会自动开辟一个新页面。因为每次插入一条新记录，都是追加操
​	作，不需要重新移动数据，因此这种插入数据的方法效率非常高。</p>
<p>​	○ 如果我们使用非自增主键，由于每次插入主键的索引值都是随机的，因此每次插入新的数据时，就
​	可能会插入到现有数据页中间的某个位置，这将不得不移动其它数据来满足新数据的插入，甚至需
​	要从一个页面复制数据到另外一个页面，我们通常将这种情况称为页分裂。页分裂还有可能会造成
​	大量的内存碎片，导致索引结构不紧凑，从而影响查询效率。</p>
</li>
<li>
<p>防止索引失效：</p>
<p>​	○ 当我们使用左或者左右模糊匹配的时候，也就是 <code>like%xx</code> 或者 <code>like%xx%</code> 这两种方式都会造成索
​	引失效；
​	○ 当我们在查询条件中对索引列做了计算、函数、类型转换操作，这些情况下都会造成索引失效；
​	○ 联合索引要能正确使用需要遵循最左匹配原则，也就是按照最左优先的方式进行索引的匹配，否则
​	就会导致索引失效。
​	○ 在WHERE子句中，如果在OR前的条件列是索引列，而在OR后的条件列不是索引I列，那么索引会
​	失效。</p>
</li>
</ul>
<hr>
<h4 id="如果给每一列都建立一个索引会有什么问题">如果给每一列都建立一个索引会有什么问题？</h4>
<p>空间占用多，然后写入频繁场景，因为索引要被更新，所以维护B+树付出的性能消耗也大</p>
<h3 id="事务">事务</h3>
<h4 id="隔离级别">隔离级别</h4>
<table>
  <thead>
      <tr>
          <th>隔离级别</th>
          <th>解决的并发问题</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>读未提交</td>
          <td></td>
      </tr>
      <tr>
          <td>读提交</td>
          <td>脏读</td>
      </tr>
      <tr>
          <td>可重复读</td>
          <td>不可重复读</td>
      </tr>
      <tr>
          <td>串行化</td>
          <td>幻读</td>
      </tr>
  </tbody>
</table>
<hr>
<h4 id="mvcc解释一下">mvcc解释一下</h4>
<p>多版本并发控制</p>
<hr>
<h3 id="锁">锁</h3>
<h4 id="讲一下mysql里有哪些锁">讲一下mysql里有哪些锁？</h4>
<img src="https://cdn.xiaolincoding.com//picgo/1720433609532-38aec7fc-734e-4b35-a802-4e6ba3339ffa.png" alt="img" style="zoom:50%;" />
<ul>
<li>行级锁：InnoDB引擎是支持行级锁的，而MyISAM引擎并不支持行级锁。</li>
<li>记录锁，锁住的是一条记录。而且记录锁是有S锁和X锁之分的，满足读写互斥，写写互斥</li>
<li>间隙锁，只存在于可重复读隔离级别，目的是为了解决可重复读隔离级别下幻读的现象。</li>
<li>Next-KeyLock称为临键锁，是Record Lock+GapLock的组合，锁定一个范围，并且锁定记录本身。</li>
</ul>
<hr>
<h3 id="性能调优">性能调优</h3>
<h4 id="慢sql优化">慢sql优化</h4>
<ul>
<li><strong>分析查询语句</strong>：使用EXPLAIN命令分析SQL执行计划，找出慢查询的原因，比如是否使用了全表扫描，是否存在索引未被利用的情况等，并根据相应情况对索引进行适当修改。</li>
<li><strong>创建或优化索引</strong>：根据查询条件创建合适的索引I，特别是经常用于WHERE子句的字段、Orderby排序的字段、Join连表查询的字典、groupby的字段，并且如果查询中经常涉及多个字段，考虑创建联合索引，使用联合索引要符合最左匹配原则，不然会索引失效</li>
<li>**避免索引失效：**比如不要用左模糊匹配、函数计算、表达式计算等等。</li>
<li><strong>查询优化</strong>：避免使用SELECT，只查询真正需要的列；使用覆盖索引I，即索引I包含所有查询的字段；联表查询最好要以小表驱动大表，并且被驱动表的字段要有索引，当然最好通过冗余字段的设计，避免联表查询。</li>
<li>**<em>分页优化：**针对limit n,y深分页的查询优化，可以把Limit查询转换成某个位置的查询：select</em>from tb_skuwhere id&gt;20000 limit 10，该方案适用于主键自增的表，</li>
<li><strong>优化数据库表</strong>：如果单表的数据超过了干万级别，考虑是否需要将大表拆分为小表，减轻单个表的查询压力。也可以将字段多的表分解成多个表，有些字段使用频率高，有些低，数据量大时，会由于使用频率低的存在而变慢，可以考虑分开。</li>
<li><strong>使用缓存技术</strong>：引入缓存层，如Redis，存储热点数据和频繁查询的结果，但是要考虑缓存一致性的问题，对于读请求会选择旁路缓存策略，对于写请求会选择先更新db，再删除缓存的策略。</li>
</ul>
<hr>
<h2 id="java基础">Java基础</h2>
<h4 id="final关键字用法">final关键字用法</h4>
<h5 id="1-final修饰变量">1. final修饰变量</h5>
<h6 id="基本类型变量">基本类型变量</h6>
<ul>
<li>被final修饰的基本类型变量一旦初始化就不能被修改</li>
<li>必须在声明时或构造函数中初始化</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">final</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">MAX_VALUE</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">100</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">// MAX_VALUE = 200; // 编译错误，不能修改final变量</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><h6 id="引用类型变量">引用类型变量</h6>
<ul>
<li>引用不能改变，但对象内部状态可以改变</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">final</span><span class="w"> </span><span class="n">List</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span><span class="w"> </span><span class="n">list</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">ArrayList</span><span class="o">&lt;&gt;</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">list</span><span class="p">.</span><span class="na">add</span><span class="p">(</span><span class="s">&#34;Hello&#34;</span><span class="p">);</span><span class="w"> </span><span class="c1">// 允许</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">// list = new ArrayList&lt;&gt;(); // 编译错误，不能重新赋值</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><h5 id="2-final修饰方法">2. final修饰方法</h5>
<ul>
<li>被final修饰的方法不能被子类重写</li>
<li>常用于防止子类改变方法的行为</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">class</span> <span class="nc">Parent</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kd">final</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">show</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&#34;Parent show&#34;</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kd">class</span> <span class="nc">Child</span><span class="w"> </span><span class="kd">extends</span><span class="w"> </span><span class="n">Parent</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// @Override</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// public void show() {} // 编译错误，不能重写final方法</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><h5 id="3-final修饰类">3. final修饰类</h5>
<ul>
<li>被final修饰的类不能被继承</li>
<li>常用于设计不希望被扩展的类</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">final</span><span class="w"> </span><span class="kd">class</span> <span class="nc">StringUtils</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// 工具类方法</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">// class MyStringUtils extends StringUtils {} // 编译错误</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><h5 id="4-final参数">4. final参数</h5>
<ul>
<li>方法参数被final修饰后，方法内不能修改该参数</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">process</span><span class="p">(</span><span class="kd">final</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">value</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// value = 10; // 编译错误</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><h5 id="5-final与并发编程">5. final与并发编程</h5>
<ul>
<li>final变量在多线程环境下是线程安全的，不需要额外的同步措施</li>
<li>JVM保证final变量的初始化安全</li>
</ul>
<hr>
<h4 id="讲解hashmap扩容">讲解HashMap扩容</h4>
<p>在JDK1.7版本之前，HashMap数据结构是数组和链表，HashMap通过哈希算法将元素的键(Key）映射到数组中的槽位（Bucket）。如果多个键映射到同一个槽位，它们会以链表的形式存储在同一个槽位上，因为链表的查询时间是O(n)，所以冲突很严重，一个索引上的链表非常长，效率就很低了。</p>
<p>所以在JDK1.8版本的时候做了优化，当一个链表的长度超过8的时候就转换数据结构，不再使用链表存储，而是使用红黑树，查找时使用红黑树，时间复杂度O(logn），可以提高查询性能，但是在数量较少时，即数量小于6时，会将红黑树转换回链表。</p>
<p>hashMap默认的负载因子是0.75，即如果hashmap中的元素个数超过了总容量75%，则会触发扩容，扩容
分为两个步骤：</p>
<ul>
<li>第1步是对哈希表长度的扩展（2倍）</li>
<li>第2步是将旧哈希表中的数据放到新的哈希表中。</li>
</ul>
<hr>
<h4 id="垃圾回收策略">垃圾回收策略</h4>
<ul>
<li>标记-清除算法：标记-清除算法分为”标记”和“清除”两个阶段，首先通过可达性分析，标记出所有需要回收的对象，然后统一回收所有被标记的对象。标记-清除算法有两个缺陷，一个是效率问题，标记和清除的过程效率都不高，另外一个就是，清除结束后会造成大量的碎片空间。有可能会造成在申请大块内存的时候因为没有足够的连续空间导致再次GC。</li>
<li>复制算法：为了解决碎片空间的问题，出现了“复制算法”。复制算法的原理是，将内存分成两块，每次申请内存时都使用其中的一块，当内存不够时，将这一块内存中所有存活的复制到另一块上。然后将然后再把已使用的内存整个清理掉。复制算法解决了空间碎片的问题。但是也带来了新的问题。因为每次在申请内存时，都只能使用一半的内存空间。内存利用率严重不足。</li>
<li>标记-整理算法：复制算法在GC之后存活对象较少的情况下效率比较高，但如果存活对象比较多时，会执行较多的复制操作，效率就会下降。而老年代的对象在GC之后的存活率就比较高，所以就有人提出了“标记-整理算法”。标记-整理算法的“标记”过程与”标记-清除算法”的标记过程一致，但标记之后不会直接清理。而是将所有存活对象都移动到内存的一端。移动结束后直接清理掉剩余部分。</li>
<li>分代回收算法：分代收集是将内存划分成了新生代和老年代。分配的依据是对象的生存周期，或者说经历过的GC次数。对象创建时，一般在新生代申请内存，当经历一次GC之后如果对还存活，那么对象的年龄+1。当年龄超过一定值(默认是15，可以通过参数-XX:MaxTenuringThreshold来设定)后，如果对象还存活，那么该对象会进入老年代。</li>
</ul>
<hr>
<h4 id="讲讲spring">讲讲Spring</h4>
<p>Spring有两个核心模块：IoC和AOP</p>
<p>IoC：控制反转，通过 <strong>依赖查找（DL）</strong> 和 <strong>依赖注入（DI）</strong> 实现的。指的是将创建的对象交给Spring进行管理。</p>
<ul>
<li>应用启动时，Spring会创建所有需要管理的对象（称为Bean）并放入IoC容器</li>
<li>开发者通过注解定义对象的创建规则，而非手动<code>new</code>实例</li>
<li>对象之间的依赖关系由Spring自动处理</li>
</ul>
<p>AOP：面向切面编程，通过<strong>动态代理</strong>技术实现，能够在不修改原有代码的情况下，为程序<strong>横向添加通用功能</strong>（如日志、事务、权限等）。</p>
<hr>
<h4 id="讲讲线程池原理">讲讲线程池原理</h4>
<p>在实际项目中，线程池是我最常用的并发编程工具之一。以下是我使用线程池的经验和最佳实践：</p>
<h5 id="1-线程池的创建">1. 线程池的创建</h5>
<p>我通常使用<code>ThreadPoolExecutor</code>来创建线程池，而不是直接使用<code>Executors</code>的工厂方法，因为这样可以更灵活地控制参数：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="c1">// 推荐方式：明确指定所有参数</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">ThreadPoolExecutor</span><span class="w"> </span><span class="n">executor</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">ThreadPoolExecutor</span><span class="p">(</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">corePoolSize</span><span class="p">,</span><span class="w">  </span><span class="c1">// 核心线程数</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">maximumPoolSize</span><span class="p">,</span><span class="w"> </span><span class="c1">// 最大线程数</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">keepAliveTime</span><span class="p">,</span><span class="w">  </span><span class="c1">// 空闲线程存活时间</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">TimeUnit</span><span class="p">.</span><span class="na">SECONDS</span><span class="p">,</span><span class="w"> </span><span class="c1">// 时间单位</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">new</span><span class="w"> </span><span class="n">LinkedBlockingQueue</span><span class="o">&lt;&gt;</span><span class="p">(</span><span class="n">queueCapacity</span><span class="p">),</span><span class="w"> </span><span class="c1">// 工作队列</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">new</span><span class="w"> </span><span class="n">CustomThreadFactory</span><span class="p">(),</span><span class="w"> </span><span class="c1">// 自定义线程工厂</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">new</span><span class="w"> </span><span class="n">CustomRejectedExecutionHandler</span><span class="p">()</span><span class="w"> </span><span class="c1">// 自定义拒绝策略</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">);</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><h5 id="2-参数配置经验">2. 参数配置经验</h5>
<ul>
<li>‌<strong>核心线程数</strong>‌：通常设置为CPU核心数的1-2倍（CPU密集型任务）或更多（IO密集型任务）</li>
<li>‌<strong>最大线程数</strong>‌：IO密集型可设置较高（如核心数的2-4倍），CPU密集型不宜过高</li>
<li>‌<strong>队列容量</strong>‌：根据业务特点设置，高吞吐场景用大队列，低延迟场景用小队列</li>
<li>‌<strong>拒绝策略</strong>‌：根据业务需求选择或自定义（记录日志、降级处理等）</li>
</ul>
<h4 id="讲讲讲一下threadlocal的原理threadlocal存在的问题">讲讲讲一下threadlocal的原理，threadlocal存在的问题?</h4>
<h4 id="如果两个服务需要传递threadlocal中的值例如用户id该如何传递">如果两个服务需要传递threadlocal中的值例如用户ID该如何传递</h4>
<h4 id="你知道哪些jvm的垃圾回收器">你知道哪些JVM的垃圾回收器</h4>
<ul>
<li>Serial收集器（复制算法): 新生代单线程收集器，标记和清理都是单线程，优点是简单高效；</li>
<li>Parallel GC（并行垃圾回收器):</li>
</ul>
<ul>
<li>G1(Garbage First)收集器 (标记-整理算法)</li>
</ul>
<h4 id="java的类加载机制是怎么样的">Java的类加载机制是怎么样的</h4>
<ol>
<li>
<p>加载（Loading）</p>
<ul>
<li>
<p>通过类的全限定名获取二进制字节流</p>
</li>
<li>
<p>将字节流转换为方法区的运行时数据结构</p>
</li>
<li>
<p>在堆中生成代表该类的Class对象</p>
</li>
</ul>
</li>
<li>
<p>验证（Verification）</p>
<ul>
<li>
<p>文件格式验证（魔数、版本号等）</p>
</li>
<li>
<p>元数据验证（语义分析）</p>
</li>
<li>
<p>字节码验证（确保方法不会危害JVM）</p>
</li>
<li>
<p>符号引用验证（确保解析能正确执行）</p>
</li>
</ul>
</li>
<li>
<p>准备（Preparation）</p>
<ul>
<li>
<p>为类变量（static变量）分配内存并设置初始值（零值）</p>
</li>
<li>
<p>注意：final static变量在此阶段直接赋值为代码中的值</p>
</li>
</ul>
</li>
<li>
<p>解析（Resolution）</p>
<ul>
<li>将常量池内的符号引用替换为直接引用</li>
</ul>
</li>
<li>
<p>初始化（Initialization）</p>
<ul>
<li>
<p>执行类构造器<code>&lt;clinit&gt;()</code>方法（包含static变量赋值和static代码块）</p>
</li>
<li>
<p>父类的<code>&lt;clinit&gt;</code>先于子类执行</p>
</li>
</ul>
</li>
</ol>
<h4 id="讲讲aqs">讲讲AQS</h4>
<p>可重入锁是指同一个线程在获取了锁之后，可以再次重复获取该锁而不会造成死锁或其他问题。当一个线
程持有锁时，如果再次尝试获取该锁，就会成功获取而不会被阻塞。
ReentrantLock实现可重入锁的机制是基于线程持有锁的计数器。
·当一个线程第一次获取锁时，计数器会加1，表示该线程持有了锁。在此之后，如果同一个线程再次获
取锁，计数器会再次加1。每次线程成功获取锁时，都会将计数器加1。
·当线程释放锁时，计数器会相应地减1。只有当计数器减到0时，锁才会完全释放，其他线程才有机会
获取锁。
这种计数器的设计使得同一个线程可以多次获取同一个锁，而不会造成死锁或其他问题。每次获取锁时，
计数器加1；每次释放锁时，计数器减1。只有当计数器减到0时，锁才会完全释放。
ReentrantLock通过这种计数器的方式，实现了可重入锁的机制。它允许同一个线程多次获取同一个锁，
并且能够正确地处理锁的获取和释放，避免了死锁和其他并发问题。</p>
<h4 id="讲讲内存区域">讲讲内存区域</h4>
<p>
<figure><a class="lightgallery" href="https://cdn.xiaolincoding.com//picgo/1713516291293-ce6ee4e7-c5a6-4395-9ee7-4ec1c014b206.webp" title="img" data-thumbnail="https://cdn.xiaolincoding.com//picgo/1713516291293-ce6ee4e7-c5a6-4395-9ee7-4ec1c014b206.webp" data-sub-html="<h2> </h2><p>img</p>">
        <img
            class="lazyload"
            src="/svg/loading.min.svg"
            data-src="https://cdn.xiaolincoding.com//picgo/1713516291293-ce6ee4e7-c5a6-4395-9ee7-4ec1c014b206.webp"
            data-srcset="https://cdn.xiaolincoding.com//picgo/1713516291293-ce6ee4e7-c5a6-4395-9ee7-4ec1c014b206.webp, https://cdn.xiaolincoding.com//picgo/1713516291293-ce6ee4e7-c5a6-4395-9ee7-4ec1c014b206.webp 1.5x, https://cdn.xiaolincoding.com//picgo/1713516291293-ce6ee4e7-c5a6-4395-9ee7-4ec1c014b206.webp 2x"
            data-sizes="auto"
            alt="https://cdn.xiaolincoding.com//picgo/1713516291293-ce6ee4e7-c5a6-4395-9ee7-4ec1c014b206.webp" />
    </a><figcaption class="image-caption">img</figcaption>
    </figure></p>
<hr>
<h4 id="静态变量放哪不同进程压栈在一个共用栈还是私有栈">静态变量放哪,不同进程压栈在一个共用栈还是私有栈？</h4>
<p>私有栈</p>
<hr>
<h2 id="redis">Redis</h2>
<h3 id="redis了解过吗有哪些应用">redis了解过吗，有哪些应用？</h3>
<p>Redis（Remote Dictionary Server）是一款高性能的‌<strong>内存数据库</strong>‌，支持多种数据结构，常用于解决高并发、低延迟场景下的数据管理问题。以下是其核心特性及典型应用场景：</p>
<h5 id="一redis的核心优势">‌<strong>一、Redis的核心优势</strong>‌</h5>
<ol>
<li>‌<strong>内存存储</strong>‌：数据读写速度达微秒级（10万+ QPS），远超传统磁盘数据库。</li>
<li>‌<strong>丰富的数据结构</strong>‌：支持字符串（String）、哈希（Hash）、列表（List）、集合（Set）、有序集合（ZSet）、流（Stream）等，覆盖多样化场景。</li>
<li>‌<strong>持久化机制</strong>‌：通过‌<strong>RDB快照</strong>‌和‌<strong>AOF日志</strong>‌实现数据持久化，保障宕机后数据可恢复。</li>
<li>‌<strong>高可用性</strong>‌：支持主从复制、哨兵（Sentinel）、集群（Cluster）模式，满足高可用需求。</li>
</ol>
<h5 id="二redis的6大典型应用场景">‌<strong>二、Redis的6大典型应用场景</strong>‌</h5>
<h6 id="1-缓存cache">‌**1. 缓存（Cache）**‌</h6>
<ul>
<li>
<p>‌<strong>问题</strong>‌：数据库读写速度慢，无法应对高并发请求。</p>
</li>
<li>
<p>‌<strong>方案</strong>‌：将热点数据（如商品详情、用户信息）缓存到Redis，降低数据库负载。</p>
</li>
<li>
<p>‌实现‌：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">bashCopy Code# 设置缓存（带30分钟过期时间）
</span></span><span class="line"><span class="cl">SET product:1001 <span class="s2">&#34;{name: &#39;Phone&#39;, price: 5999}&#34;</span> EX <span class="m">1800</span>
</span></span><span class="line"><span class="cl"><span class="c1"># 查询缓存</span>
</span></span><span class="line"><span class="cl">GET product:1001
</span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>‌优化技巧‌：</p>
<ul>
<li>缓存穿透：布隆过滤器（Bloom Filter）拦截无效请求。</li>
<li>缓存雪崩：随机化过期时间，避免集中失效。</li>
</ul>
</li>
</ul>
<h6 id="2-会话存储session-storage">‌**2. 会话存储（Session Storage）**‌</h6>
<ul>
<li>
<p>‌<strong>问题</strong>‌：分布式系统中用户会话需跨服务共享。</p>
</li>
<li>
<p>‌<strong>方案</strong>‌：用Redis集中存储会话数据（如登录状态、购物车）。</p>
</li>
<li>
<p>‌实现‌：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">bashCopy Code# 存储用户会话
</span></span><span class="line"><span class="cl">HSET session:user123 token <span class="s2">&#34;abc123&#34;</span> cart <span class="s2">&#34;[{id: 1, count: 2}]&#34;</span>
</span></span><span class="line"><span class="cl"><span class="c1"># 设置30分钟过期</span>
</span></span><span class="line"><span class="cl">EXPIRE session:user123 <span class="m">1800</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
<h6 id="3-排行榜与计数器">‌<strong>3. 排行榜与计数器</strong>‌</h6>
<ul>
<li>
<p>‌<strong>问题</strong>‌：实时更新排名（如游戏积分榜、热搜词）。</p>
</li>
<li>
<p>‌<strong>方案</strong>‌：利用有序集合（ZSet）按分数排序。</p>
</li>
<li>
<p>‌实现‌：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">bashCopy Code# 添加玩家得分
</span></span><span class="line"><span class="cl">ZADD leaderboard <span class="m">5000</span> <span class="s2">&#34;player1&#34;</span> <span class="m">4800</span> <span class="s2">&#34;player2&#34;</span>
</span></span><span class="line"><span class="cl"><span class="c1"># 获取前10名</span>
</span></span><span class="line"><span class="cl">ZREVRANGE leaderboard <span class="m">0</span> <span class="m">9</span> WITHSCORES
</span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
<h6 id="4-消息队列">‌<strong>4. 消息队列</strong>‌</h6>
<ul>
<li>
<p>‌<strong>问题</strong>‌：服务间异步通信需求（如订单支付后通知物流）。</p>
</li>
<li>
<p>‌<strong>方案</strong>‌：使用列表（List）或Stream实现轻量级队列。</p>
</li>
<li>
<p>‌实现（List）‌：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">bashCopy Code# 生产者推送消息
</span></span><span class="line"><span class="cl">LPUSH order:queue <span class="s2">&#34;order1001&#34;</span>
</span></span><span class="line"><span class="cl"><span class="c1"># 消费者阻塞获取</span>
</span></span><span class="line"><span class="cl">BRPOP order:queue <span class="m">30</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>‌<strong>高级场景</strong>‌：Stream支持消费者组（Consumer Group），类似Kafka的分区消费。</p>
</li>
</ul>
<h6 id="5-分布式锁">‌<strong>5. 分布式锁</strong>‌</h6>
<ul>
<li>
<p>‌<strong>问题</strong>‌：多实例服务竞争资源时需互斥访问（如秒杀扣库存）。</p>
</li>
<li>
<p>‌<strong>方案</strong>‌：通过<code>SETNX</code>或<code>RedLock</code>实现分布式锁。</p>
</li>
<li>
<p>‌实现（SETNX）‌：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">bashCopy Code# 加锁（设置唯一值防误删）
</span></span><span class="line"><span class="cl">SET lock:stock <span class="m">1</span> NX EX <span class="m">10</span>
</span></span><span class="line"><span class="cl"><span class="c1"># 释放锁（Lua脚本保证原子性）</span>
</span></span><span class="line"><span class="cl">EVAL <span class="s2">&#34;if redis.call(&#39;get&#39;, KEYS) == ARGV then return redis.call(&#39;del&#39;, KEYS) else return 0 end&#34;</span> <span class="m">1</span> lock:stock <span class="m">1</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
<h6 id="6-实时数据分析">‌<strong>6. 实时数据分析</strong>‌</h6>
<ul>
<li>
<p>‌<strong>问题</strong>‌：高频数据实时统计（如在线人数、UV/PV）。</p>
</li>
<li>
<p>‌<strong>方案</strong>‌：通过HyperLogLog统计基数，Bitmap记录用户行为。</p>
</li>
<li>
<p>‌实现：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">bashCopy Code# HyperLogLog统计UV（误差率0.81%）
</span></span><span class="line"><span class="cl">PFADD uv:20231001 user1 user2 user3
</span></span><span class="line"><span class="cl">PFCOUNT uv:20231001
</span></span><span class="line"><span class="cl"><span class="c1"># Bitmap记录用户签到</span>
</span></span><span class="line"><span class="cl">SETBIT sign:user123:202310 <span class="m">5</span> <span class="m">1</span>  <span class="c1"># 第5天签到</span>
</span></span><span class="line"><span class="cl">BITCOUNT sign:user123:202310    <span class="c1"># 当月签到次数</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
<h5 id="三redis-vs-其他技术选型对比">‌<strong>三、Redis vs 其他技术选型对比</strong>‌</h5>
<table>
  <thead>
      <tr>
          <th>‌<strong>场景</strong>‌</th>
          <th>‌<strong>Redis优势</strong>‌</th>
          <th>‌<strong>替代方案</strong>‌</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>缓存</td>
          <td>数据结构灵活，支持过期时间、持久化</td>
          <td>Memcached（纯缓存，无持久化）</td>
      </tr>
      <tr>
          <td>消息队列</td>
          <td>轻量级，支持Stream的消费者组</td>
          <td>Kafka/RabbitMQ（高吞吐）</td>
      </tr>
      <tr>
          <td>分布式锁</td>
          <td>原子操作简单易用</td>
          <td>ZooKeeper（强一致性）</td>
      </tr>
      <tr>
          <td>实时统计</td>
          <td>HyperLogLog节省内存，适合大数据量</td>
          <td>Flink/Spark（复杂计算）</td>
      </tr>
  </tbody>
</table>
<h5 id="四redis的局限性">‌<strong>四、Redis的局限性</strong>‌</h5>
<ol>
<li>‌<strong>内存成本高</strong>‌：数据量过大时需权衡成本（如冷数据归档到磁盘库）。</li>
<li>‌<strong>持久化性能损耗</strong>‌：AOF的<code>fsync always</code>模式会降低吞吐量。</li>
<li>‌<strong>事务非强一致</strong>‌：Redis事务不支持回滚（通过Lua脚本弥补）。</li>
</ol>
<h5 id="总结">‌<strong>总结</strong>‌</h5>
<p>Redis凭借‌<strong>内存速度</strong>‌和‌<strong>数据结构多样性</strong>‌，成为高并发系统的核心组件，适用于缓存、会话管理、实时排行榜等场景。实际应用中需结合业务特点选择数据结构，并合理设计过期策略、持久化配置及高可用方案（如集群部署）。</p>
<hr>
<h3 id="redis常用数据结构">redis常用数据结构</h3>
<h5 id="1-字符串string">1. <strong>字符串（String）</strong></h5>
<ul>
<li>
<p><strong>底层实现</strong>：<strong>简单动态字符串（SDS, Simple Dynamic String）</strong></p>
<ul>
<li>
<p><strong>特点</strong>：</p>
<ul>
<li>预分配内存空间，减少修改时的内存重分配次数。</li>
<li>二进制安全（可存储任意二进制数据，如 <code>\0</code>）。</li>
<li>直接存储长度（<code>O(1)</code> 复杂度获取长度）。</li>
</ul>
</li>
<li>
<p><strong>结构体</strong>：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">struct</span> <span class="n">sdshdr</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">len</span><span class="p">;</span>     <span class="c1">// 已用长度
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">int</span> <span class="n">free</span><span class="p">;</span>    <span class="c1">// 空闲空间
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">char</span> <span class="n">buf</span><span class="p">[];</span>  <span class="c1">// 字符数组
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
</li>
</ul>
<h5 id="2-列表list">2. <strong>列表（List）</strong></h5>
<ul>
<li><strong>底层实现</strong>：<strong>QuickList（Redis 3.2+）</strong>
<ul>
<li><strong>设计</strong>：双向链表 + 压缩列表（或 listpack）的混合结构。</li>
<li><strong>特点</strong>：
<ul>
<li>每个节点是一个压缩列表（ziplist）或 listpack，平衡内存连续性和插入性能。</li>
<li>支持双向遍历，适合实现队列、栈等结构。</li>
</ul>
</li>
<li><strong>旧版本</strong>：小规模数据使用 <strong>ziplist</strong>，大规模数据使用 <strong>双向链表</strong>。</li>
</ul>
</li>
</ul>
<h5 id="3-哈希hash">3. <strong>哈希（Hash）</strong></h5>
<ul>
<li><strong>底层实现</strong>：
<ul>
<li><strong>小规模数据</strong>：<strong>Listpack</strong>（Redis 7.0+）或 <strong>ziplist</strong>（旧版本）。</li>
<li><strong>大规模数据</strong>：<strong>哈希表（Dict）</strong>，采用链式冲突解决和渐进式 Rehash。</li>
<li><strong>转换条件</strong>：
<ul>
<li><code>hash-max-listpack-entries</code>（默认 512）：键值对数量阈值。</li>
<li><code>hash-max-listpack-value</code>（默认 64字节）：单个值的最大字节。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="4-集合set">4. <strong>集合（Set）</strong></h5>
<ul>
<li><strong>底层实现</strong>：
<ul>
<li><strong>纯整数且元素少</strong>：<strong>IntSet</strong>（整数数组，有序且紧凑）。</li>
<li><strong>其他情况</strong>：<strong>哈希表（Dict）</strong>，键为元素，值为 <code>NULL</code>。</li>
<li><strong>转换条件</strong>：由 <code>set-max-intset-entries</code> 控制（默认 $512$）。</li>
</ul>
</li>
</ul>
<h5 id="5-有序集合zset">5. <strong>有序集合（ZSet）</strong></h5>
<ul>
<li><strong>底层实现</strong>：
<ul>
<li><strong>小规模数据</strong>：<strong>Listpack</strong>（Redis $7.0$+）或 <strong>ziplist</strong>（旧版本），按分值排序。</li>
<li><strong>大规模数据</strong>：<strong>跳表（SkipList） + 哈希表（Dict）</strong>。
<ul>
<li><strong>跳表</strong>：支持 <code>O(logN)</code> 范围查询（如 <code>ZRANGE</code>）。</li>
<li><strong>哈希表</strong>：存储 <code>成员 -&gt; 分值</code> 的映射，实现 <code>O(1)</code> 单元素查询。</li>
</ul>
</li>
<li><strong>转换条件</strong>：
<ul>
<li><code>zset-max-listpack-entries</code>（默认 $128$ ）：元素数量阈值。</li>
<li><code>zset-max-listpack-value</code>（默认 $64$ 字节）：成员最大长度。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="6-其他结构">6. <strong>其他结构</strong></h5>
<ul>
<li><strong>Streams</strong>：基数树（Rax Tree）实现消息队列，支持多播。</li>
<li><strong>HyperLogLog</strong>：稀疏和密集两种编码，用于基数统计。</li>
<li><strong>位图（Bitmap）</strong>：基于 SDS 字符串的位操作。</li>
<li><strong>地理空间（GEO）</strong>：使用 ZSet 存储 GeoHash 编码的位置。</li>
</ul>
<hr>
<h3 id="redis的高可用性方案有哪些具体讲一讲">redis的高可用性方案有哪些，具体讲一讲</h3>
<h5 id="1-主从复制replication">1. <strong>主从复制（Replication）</strong></h5>
<ul>
<li>
<p><strong>原理</strong>：</p>
<ul>
<li>主节点（Master）处理写请求，并将数据异步复制到多个从节点（Slave）。</li>
<li>从节点默认只读，用于负载均衡读请求。</li>
</ul>
</li>
<li>
<p><strong>优点</strong>：</p>
<ul>
<li><strong>数据冗余</strong>：从节点提供数据备份。</li>
<li><strong>读写分离</strong>：分担主节点的读压力。</li>
</ul>
</li>
<li>
<p><strong>缺点</strong>：</p>
<ul>
<li><strong>非高可用</strong>：主节点宕机后需<strong>手动切换</strong>到从节点。</li>
<li><strong>异步复制</strong>：存在数据丢失风险（主节点宕机时未同步的数据会丢失）。</li>
</ul>
</li>
<li>
<p><strong>配置示例</strong>：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="c1"># 在从节点配置文件中指定主节点</span>
</span></span><span class="line"><span class="cl">replicaof &lt;master-ip&gt; &lt;master-port&gt;
</span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
<h5 id="2-哨兵模式sentinel">2. <strong>哨兵模式（Sentinel）</strong></h5>
<ul>
<li>
<p><strong>原理</strong>：</p>
<ul>
<li><strong>哨兵（Sentinel）</strong> 是一个独立的进程集群，监控主从节点的健康状态。</li>
<li>当主节点不可用时，哨兵通过<strong>投票机制</strong>自动选举一个从节点升级为新主节点，并通知客户端和从节点更新配置。</li>
</ul>
</li>
<li>
<p><strong>核心功能</strong>：</p>
<ul>
<li><strong>监控</strong>：定期检测节点状态。</li>
<li><strong>自动故障转移</strong>（Failover）。</li>
<li><strong>配置中心</strong>：客户端通过哨兵获取当前主节点地址。</li>
</ul>
</li>
<li>
<p><strong>工作流程</strong>：</p>
<ol>
<li><strong>主观下线</strong>：单个哨兵认为主节点不可用。</li>
<li><strong>客观下线</strong>：多个哨兵（满足 <code>quorum</code> 数）确认主节点故障。</li>
<li><strong>选举领导者哨兵</strong>：执行故障转移操作。</li>
<li><strong>切换主节点</strong>：选择数据最新的从节点成为新主。</li>
</ol>
</li>
<li>
<p><strong>优点</strong>：</p>
<ul>
<li><strong>自动故障转移</strong>，无需人工干预。</li>
<li>支持多哨兵部署，避免单点故障。</li>
</ul>
</li>
<li>
<p><strong>缺点</strong>：</p>
<ul>
<li><strong>写操作单点</strong>：主节点仍是性能瓶颈。</li>
<li><strong>扩展性有限</strong>：分片需客户端自行实现。</li>
</ul>
</li>
<li>
<p><strong>配置示例</strong>：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="c1"># Sentinel 配置文件</span>
</span></span><span class="line"><span class="cl">sentinel monitor mymaster 127.0.0.1 <span class="m">6379</span> <span class="m">2</span>  <span class="c1"># 监控名为 mymaster 的主节点，2 表示至少 2 个哨兵确认故障</span>
</span></span><span class="line"><span class="cl">sentinel down-after-milliseconds mymaster <span class="m">5000</span>  <span class="c1"># 5 秒无响应视为下线</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
<h5 id="3-redis-cluster集群模式">3. <strong>Redis Cluster（集群模式）</strong></h5>
<ul>
<li>
<p><strong>原理</strong>：</p>
<ul>
<li><strong>数据分片</strong>：将数据按哈希槽（Hash Slot，共 16384 个）分配到多个主节点。</li>
<li><strong>多主多从</strong>：每个主节点有 1 到多个从节点，主节点故障时从节点自动接替。</li>
<li><strong>Gossip 协议</strong>：节点间通过 P2P 通信同步状态和拓扑信息。</li>
</ul>
</li>
<li>
<p><strong>核心特性</strong>：</p>
<ul>
<li><strong>自动分片</strong>：客户端直连任意节点，由节点返回正确路由（MOVED/ASK 重定向）。</li>
<li><strong>高可用</strong>：主节点故障时，从节点自动晋升为新主。</li>
<li><strong>线性扩展</strong>：支持动态增删节点，哈希槽重新分配。</li>
</ul>
</li>
<li>
<p><strong>优点</strong>：</p>
<ul>
<li><strong>去中心化</strong>：无单点瓶颈。</li>
<li><strong>高可用与高扩展性</strong>：适合大规模分布式场景。</li>
</ul>
</li>
<li>
<p><strong>缺点</strong>：</p>
<ul>
<li><strong>客户端兼容性</strong>：需支持 Cluster 协议的客户端（如 Jedis Cluster）。</li>
<li><strong>功能限制</strong>：跨槽事务、多键操作受限（需使用 Hash Tag 保证 key 在同一槽）。</li>
</ul>
</li>
<li>
<p><strong>配置示例</strong>：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="c1"># 启动集群节点</span>
</span></span><span class="line"><span class="cl">redis-server --cluster-enabled yes --cluster-config-file nodes.conf
</span></span><span class="line"><span class="cl"><span class="c1"># 创建集群（3 主 3 从）</span>
</span></span><span class="line"><span class="cl">redis-cli --cluster create 127.0.0.1:7000 127.0.0.1:7001 ... --cluster-replicas <span class="m">1</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
<hr>
<h3 id="缓存雪崩击穿穿透是什么怎么解决">缓存雪崩、击穿、穿透是什么？怎么解决？</h3>
<p>在分布式系统中，缓存是提升性能和降低数据库压力的重要手段，但缓存使用不当可能导致‌<strong>雪崩、击穿、穿透</strong>‌三大经典问题。以下是它们的核心定义、原因及解决方案：</p>
<hr>
<h5 id="1-缓存雪崩cache-avalanche">‌**1. 缓存雪崩（Cache Avalanche）**‌</h5>
<h6 id="定义">‌<strong>定义</strong>‌</h6>
<p>‌<strong>大量缓存数据在同一时间失效或者Redis故障宕机</strong>‌，导致所有请求直接穿透到数据库，引发数据库瞬时高负载甚至崩溃。
‌<strong>类比</strong>‌：多个水库同时决堤，洪水直接冲击下游村庄。</p>
<h6 id="原因">‌<strong>原因</strong>‌</h6>
<ul>
<li>缓存数据设置了相同的过期时间（例如批量预热缓存时未添加随机因子）。</li>
<li>缓存服务整体宕机（如 Redis 集群故障）。</li>
</ul>
<h6 id="解决方案">‌<strong>解决方案</strong>‌</h6>
<ol>
<li>‌差异化过期时间‌
<ul>
<li>在缓存过期时间基础上添加随机值（例如 <code>TTL = 基础时间 + 随机分钟</code>），避免同时失效。</li>
</ul>
</li>
<li>‌互斥锁重建缓存‌
<ul>
<li>当缓存失效时，使用分布式锁（如 Redis 的 <code>SETNX</code>）控制只有一个线程重建缓存，其他线程等待后重试。</li>
</ul>
</li>
<li>‌熔断降级与限流
<ul>
<li>在数据库层面设置熔断机制（如 Hystrix），或使用限流工具（如 Sentinel）控制请求流量。</li>
</ul>
</li>
<li>‌缓存集群高可用
<ul>
<li>使用 Redis Cluster 或哨兵模式（Sentinel）避免单点故障。</li>
</ul>
</li>
</ol>
<hr>
<h5 id="2-缓存击穿cache-breakdown">‌**2. 缓存击穿（Cache Breakdown）**‌</h5>
<h6 id="定义-1">‌<strong>定义</strong>‌</h6>
<p>‌<strong>某个热点数据过期后，大量并发请求同时穿透缓存，直接访问数据库</strong>‌。
‌<strong>类比</strong>‌：一颗子弹击穿防弹衣，所有攻击集中在一个点。</p>
<h6 id="原因-1">‌<strong>原因</strong>‌</h6>
<ul>
<li>热点数据过期（例如明星绯闻、秒杀商品信息）。</li>
<li>高并发请求集中在同一数据上。</li>
</ul>
<h6 id="解决方案-1">‌<strong>解决方案</strong>‌</h6>
<ol>
<li>‌热点数据永不过期
<ul>
<li>缓存不设置过期时间，通过异步线程定期更新（例如每 10 分钟刷新一次）。</li>
</ul>
</li>
<li>‌互斥锁重建缓存
<ul>
<li>类似缓存雪崩的解决方案，使用分布式锁避免多个线程同时重建缓存。</li>
</ul>
</li>
<li>‌逻辑过期
<ul>
<li>缓存中存储数据的逻辑过期时间（例如字段 <code>expire_time</code>），业务层判断是否需异步更新。</li>
</ul>
</li>
<li>‌请求合并
<ul>
<li>将多个并发请求合并为一个数据加载任务（如本地队列或消息队列）。</li>
</ul>
</li>
</ol>
<hr>
<h5 id="3-缓存穿透cache-penetration">‌**3. 缓存穿透（Cache Penetration）**‌</h5>
<h6 id="定义-2">‌<strong>定义</strong>‌</h6>
<p>‌<strong>查询不存在的数据（如非法 ID），绕过缓存直接访问数据库</strong>‌。
‌<strong>类比</strong>‌：攻击者绕过城墙，直接挖掘隧道攻击城内。</p>
<h6 id="原因-2">‌<strong>原因</strong>‌</h6>
<ul>
<li>恶意攻击或业务逻辑缺陷（例如频繁查询不存在的用户 ID）。</li>
<li>数据库和缓存均未存储该数据，导致每次请求都穿透到数据库。</li>
</ul>
<h6 id="解决方案-2">‌<strong>解决方案</strong>‌</h6>
<ol>
<li>‌缓存空值（Null Cache）
<ul>
<li>对查询结果为空的请求，缓存一个短时间空值（例如 <code>key: -1</code>, TTL=5 分钟）。</li>
</ul>
</li>
<li>‌布隆过滤器（Bloom Filter）
<ul>
<li>在缓存层前添加布隆过滤器，快速判断数据是否存在：
<ul>
<li>若布隆过滤器判定数据不存在，直接返回空结果。</li>
<li>若判定存在，再查询缓存或数据库。</li>
</ul>
</li>
</ul>
</li>
<li>‌接口校验与限流
<ul>
<li>对请求参数进行合法性校验（如 ID 必须为数字），拦截非法请求。</li>
<li>对高频 IP 或用户进行限流或黑名单拦截。</li>
</ul>
</li>
<li>‌实时监控与防御
<ul>
<li>监控数据库慢查询日志，识别异常请求模式（如大量 <code>404</code> 请求）。</li>
</ul>
</li>
</ol>
<hr>
<h5 id="三者的核心区别">‌<strong>三者的核心区别</strong>‌</h5>
<table>
  <thead>
      <tr>
          <th>‌<strong>问题类型</strong>‌</th>
          <th>‌<strong>触发条件</strong>‌</th>
          <th>‌<strong>影响范围</strong>‌</th>
          <th>‌<strong>典型场景</strong>‌</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>缓存雪崩</td>
          <td>大量缓存同时失效</td>
          <td>全局性数据库压力</td>
          <td>批量缓存预热、缓存集群宕机</td>
      </tr>
      <tr>
          <td>缓存击穿</td>
          <td>单个热点数据失效</td>
          <td>单点数据库压力</td>
          <td>秒杀商品、热点新闻</td>
      </tr>
      <tr>
          <td>缓存穿透</td>
          <td>查询不存在的数据</td>
          <td>无效请求消耗资源</td>
          <td>恶意攻击、参数伪造</td>
      </tr>
  </tbody>
</table>
<hr>
<h5 id="实战案例">‌<strong>实战案例</strong>‌</h5>
<ol>
<li>‌<strong>电商秒杀场景</strong>‌
<ul>
<li>‌<strong>雪崩</strong>‌：秒杀开始时所有商品缓存同时失效 → 使用随机 TTL + 互斥锁。</li>
<li>‌<strong>击穿</strong>‌：某热门商品缓存过期 → 逻辑过期 + 请求合并。</li>
<li>‌<strong>穿透</strong>‌：恶意刷不存在的商品 ID → 布隆过滤器 + 空值缓存。</li>
</ul>
</li>
<li>‌<strong>社交网络热点事件</strong>‌
<ul>
<li>明星热搜数据缓存失效 → 永不过期 + 异步更新。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="大key是什么意思呢怎么解决">大key是什么意思呢？怎么解决</h3>
<hr>
<h3 id="zset的底层数据结构">Zset的底层数据结构</h3>
<hr>
<h3 id="redis-的-zset-为何选择跳表skip-list而非红黑树">Redis 的 ZSet 为何选择跳表（Skip List）而非红黑树？</h3>
<p>Redis 的有序集合（ZSet）底层默认使用 <strong>跳表（Skip List）</strong> 和 <strong>哈希表</strong> 的组合实现（当元素较少或成员是长字符串时，可能使用压缩列表）。选择跳表而非红黑树，主要基于以下几点原因：</p>
<h5 id="1-查询性能的权衡">1. <strong>查询性能的权衡</strong></h5>
<ul>
<li><strong>跳表的查询复杂度</strong>：平均 O(log⁡n)<em>O</em>(log<em>n</em>)，最坏 O(n)<em>O</em>(<em>n</em>)（但概率极低，通过合理的随机层数控制可避免）。</li>
<li><strong>红黑树的查询复杂度</strong>：严格 O(log⁡n)<em>O</em>(log<em>n</em>)。</li>
</ul>
<p>虽然两者在理论上都是对数级别，但跳表的实际查询效率接近红黑树，且实现更简单。</p>
<h5 id="2-插入和删除操作的效率">2. <strong>插入和删除操作的效率</strong></h5>
<ul>
<li><strong>跳表的插入/删除</strong>：
<ul>
<li>平均 O(log⁡n)<em>O</em>(log<em>n</em>)，仅需局部调整相邻节点的指针。</li>
<li><strong>无需复杂的再平衡</strong>（红黑树需要旋转和变色）。</li>
</ul>
</li>
<li><strong>红黑树的插入/删除</strong>：
<ul>
<li>虽然也是 O(log⁡n)<em>O</em>(log<em>n</em>)，但需要处理复杂的平衡逻辑（旋转和变色），代码实现更复杂。</li>
</ul>
</li>
</ul>
<p><strong>跳表的优势</strong>：在高并发场景下，跳表的局部修改特性更容易实现无锁优化（Redis 6.0 的多线程 I/O 对命令处理仍是单线程，但跳表为未来可能的扩展留了余地）。</p>
<h5 id="3-范围查询的高效性">3. <strong>范围查询的高效性</strong></h5>
<ul>
<li><strong>跳表</strong>：天然支持有序遍历，范围查询（如 <code>ZRANGE</code>）只需遍历链表，时间复杂度 O(log⁡n+m)<em>O</em>(log<em>n</em>+<em>m</em>)（m<em>m</em> 为返回的元素数量）。</li>
<li><strong>红黑树</strong>：范围查询需要中序遍历，实现较复杂，且缓存局部性不如跳表。</li>
</ul>
<p><strong>Redis 的场景需求</strong>：ZSet 常用于排行榜、区间查询（如分数范围），跳表的顺序访问特性更契合。</p>
<h5 id="4-实现复杂度">4. <strong>实现复杂度</strong></h5>
<ul>
<li><strong>跳表</strong>：实现简单，约 200 行代码即可完成核心逻辑，调试和维护成本低。</li>
<li><strong>红黑树</strong>：实现复杂，需处理多种旋转和变色情况，容易出错。</li>
</ul>
<p><strong>Redis 的设计哲学</strong>：优先选择简单、高效的数据结构，跳表在性能和实现复杂度之间取得了更好的平衡。</p>
<h5 id="5-内存占用">5. <strong>内存占用</strong></h5>
<ul>
<li><strong>跳表</strong>：通过随机层数（通常概率为 1/21/2），平均每个节点只需 1.33 个额外指针（相比红黑树的左右子节点指针，内存开销接近）。</li>
<li><strong>红黑树</strong>：每个节点需存储颜色标志、左右子节点指针，实际内存占用与跳表差异不大。</li>
</ul>
<h5 id="6-并发优化的潜力">6. <strong>并发优化的潜力</strong></h5>
<ul>
<li><strong>跳表</strong>：可以通过细粒度的锁或无锁编程（如 CAS）优化并发修改。</li>
<li><strong>红黑树</strong>：平衡操作涉及全局结构调整，并发优化难度大。</li>
</ul>
<h5 id="为什么不是所有场景都用跳表">为什么不是所有场景都用跳表？</h5>
<ul>
<li><strong>红黑树的优势</strong>：严格平衡，查询性能更稳定（跳表的层数依赖随机数）。</li>
<li><strong>其他数据库的选择</strong>：如 MySQL 的索引使用 B+ 树（磁盘友好），而内存数据库（如 Redis）优先考虑内存操作效率。</li>
</ul>
<h5 id="总结-1">总结</h5>
<p>Redis 选择跳表而非红黑树，核心原因是：</p>
<ol>
<li><strong>插入/删除更高效</strong>：无需再平衡，适合高频写操作。</li>
<li><strong>范围查询更优</strong>：直接遍历链表即可。</li>
<li><strong>实现简单</strong>：降低代码维护成本。</li>
<li><strong>契合场景</strong>：ZSet 的典型操作（如排行榜）更依赖顺序访问。</li>
</ol>
<p>虽然红黑树的查询性能理论上更稳定，但跳表在综合性能、实现复杂度和功能需求上更胜一筹。</p>
<hr>
<h2 id="消息队列">消息队列</h2>
<h4 id="mq了解过吗解决哪些问题">mq了解过吗？解决哪些问题</h4>
<p>消息队列（Message Queue, MQ）是分布式系统中广泛使用的中间件技术，主要用于解决系统间的‌<strong>异步通信、解耦、流量削峰</strong>‌等问题。以下是消息队列的核心作用、典型场景及主流产品对比：</p>
<hr>
<h5 id="一消息队列解决的4大核心问题">‌<strong>一、消息队列解决的4大核心问题</strong>‌</h5>
<h6 id="1-系统解耦">1. ‌<strong>系统解耦</strong>‌</h6>
<ul>
<li>‌<strong>问题</strong>‌：服务间直接调用（如RPC）会导致强耦合，任一服务宕机或变更可能引发连锁故障。</li>
<li>‌<strong>解决方案</strong>‌：生产者将消息发送到MQ，消费者独立订阅并处理，双方无需感知彼此的存在。</li>
<li>‌场景‌：
<ul>
<li>电商订单系统：订单服务生成订单后，通过MQ通知库存服务扣减库存、支付服务处理支付，各服务独立演进。</li>
<li>用户注册：注册服务完成数据写入后，通过MQ触发发送欢迎邮件、初始化用户画像等操作。</li>
</ul>
</li>
</ul>
<h6 id="2-异步处理">2. ‌<strong>异步处理</strong>‌</h6>
<ul>
<li>‌<strong>问题</strong>‌：同步阻塞调用（如HTTP请求）导致响应延迟，资源利用率低。</li>
<li>‌<strong>解决方案</strong>‌：非关键流程异步化，生产者发送消息后立即返回，消费者异步处理。</li>
<li>‌场景‌：
<ul>
<li>用户下单后，前端立即返回“订单创建成功”，后台异步处理物流调度、短信通知等耗时操作。</li>
<li>视频上传：用户上传视频后，系统异步进行转码、审核、生成缩略图等操作。</li>
</ul>
</li>
</ul>
<h6 id="3-流量削峰">3. ‌<strong>流量削峰</strong>‌</h6>
<ul>
<li>‌<strong>问题</strong>‌：突发流量（如秒杀活动）超过下游系统处理能力，导致服务崩溃。</li>
<li>‌<strong>解决方案</strong>‌：MQ作为缓冲区，平滑流量峰值，按下游处理能力消费消息。</li>
<li>‌场景‌：
<ul>
<li>秒杀系统：瞬间涌入的10万请求写入MQ，库存服务按每秒1000件的速率消费，避免数据库被击穿。</li>
<li>日志收集：业务高峰期的日志批量写入MQ，下游日志分析服务逐步消费。</li>
</ul>
</li>
</ul>
<h6 id="4-数据最终一致性">4. ‌<strong>数据最终一致性</strong>‌</h6>
<ul>
<li>‌<strong>问题</strong>‌：分布式事务实现复杂，跨服务数据一致性难以保证。</li>
<li>‌<strong>解决方案</strong>‌：通过MQ的可靠投递和重试机制，结合本地事务表，实现最终一致性。</li>
<li>‌场景‌：
<ul>
<li>跨行转账：A银行扣款成功后，通过MQ通知B银行入账，若失败则重试直到成功。</li>
<li>订单状态同步：订单支付成功后，通过MQ同步状态至物流系统，确保双方数据最终一致。</li>
</ul>
</li>
</ul>
<hr>
<h5 id="二消息队列的典型应用场景">‌<strong>二、消息队列的典型应用场景</strong>‌</h5>
<table>
  <thead>
      <tr>
          <th>‌<strong>场景</strong>‌</th>
          <th>‌<strong>技术实现</strong>‌</th>
          <th>‌<strong>代表MQ</strong>‌</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>实时日志处理</td>
          <td>日志采集 -&gt; MQ -&gt; 流式计算（Flink/Spark）</td>
          <td>Kafka</td>
      </tr>
      <tr>
          <td>微服务异步通信</td>
          <td>服务间通过MQ解耦，如订单通知库存</td>
          <td>RabbitMQ</td>
      </tr>
      <tr>
          <td>金融交易消息分发</td>
          <td>高可靠事务消息、顺序消息</td>
          <td>RocketMQ</td>
      </tr>
      <tr>
          <td>IoT设备数据采集</td>
          <td>海量设备数据汇聚与分发</td>
          <td>EMQX（MQTT协议）</td>
      </tr>
  </tbody>
</table>
<hr>
<h5 id="三主流消息队列对比">‌<strong>三、主流消息队列对比</strong>‌</h5>
<table>
  <thead>
      <tr>
          <th>‌<strong>产品</strong>‌</th>
          <th>‌<strong>吞吐量</strong>‌</th>
          <th>‌<strong>延迟</strong>‌</th>
          <th>‌<strong>可靠性</strong>‌</th>
          <th>‌<strong>适用场景</strong>‌</th>
          <th>‌<strong>核心特性</strong>‌</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>‌<strong>Kafka</strong>‌</td>
          <td>超高</td>
          <td>毫秒级</td>
          <td>高（持久化）</td>
          <td>日志收集、大数据流处理</td>
          <td>分区顺序性、持久化存储、高吞吐</td>
      </tr>
      <tr>
          <td>‌<strong>RabbitMQ</strong>‌</td>
          <td>中</td>
          <td>微秒级</td>
          <td>高</td>
          <td>企业级异步通信、复杂路由</td>
          <td>灵活的路由规则、ACK机制、死信队列</td>
      </tr>
      <tr>
          <td>‌<strong>RocketMQ</strong>‌</td>
          <td>高</td>
          <td>毫秒级</td>
          <td>极高</td>
          <td>金融交易、订单处理</td>
          <td>事务消息、顺序消息、消息回溯</td>
      </tr>
      <tr>
          <td>‌<strong>ActiveMQ</strong>‌</td>
          <td>低</td>
          <td>毫秒级</td>
          <td>中</td>
          <td>小型系统、传统JMS应用</td>
          <td>支持JMS协议、多语言客户端</td>
      </tr>
      <tr>
          <td>‌<strong>Pulsar</strong>‌</td>
          <td>高</td>
          <td>毫秒级</td>
          <td>高</td>
          <td>多租户消息平台、云原生场景</td>
          <td>分层存储、低延迟、多租户隔离</td>
      </tr>
  </tbody>
</table>
<hr>
<h2 id="分布式">分布式</h2>
<h3 id="1-cap为什么只能同时满足两个"><strong>1. CAP为什么只能同时满足两个？</strong></h3>
<p><strong>CAP定理</strong>指出，在分布式系统中，<strong>一致性（Consistency）、可用性（Availability）、分区容错性（Partition Tolerance）</strong> 三者无法同时满足，最多只能实现其中两个。其核心原因是 <strong>网络分区（Network Partition）是分布式系统的必然风险</strong>，而面对分区时，系统必须做出取舍。</p>
<h4 id="通俗解释"><strong>通俗解释</strong>：</h4>
<p>想象一个分布式系统有两个节点A和B，存储同一份数据。</p>
<ul>
<li><strong>场景1：网络正常</strong>
<ul>
<li>A和B可以通信，系统可以同时保证一致性（数据相同）和可用性（都能响应请求）。</li>
</ul>
</li>
<li><strong>场景2：网络断开（分区）</strong>
<ul>
<li>A和B无法通信，此时系统必须选择：
<ul>
<li><strong>选择一致性（CP）</strong>：如果用户写入A，但A无法同步到B，则系统会拒绝写入或阻塞，保证数据一致，但牺牲可用性（用户可能无法得到响应）。</li>
<li><strong>选择可用性（AP）</strong>：允许用户继续读写A和B，但可能导致数据不一致（A和B的数据不同）。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="技术本质"><strong>技术本质</strong>：</h4>
<ul>
<li><strong>分区是客观存在的</strong>：网络故障无法完全避免（如光纤被挖断、交换机故障）。</li>
<li><strong>一致性与可用性矛盾</strong>：
<ul>
<li>要保证一致性，必须所有节点达成共识（需通信），但分区时无法通信，只能阻塞或拒绝请求（牺牲可用性）。</li>
<li>要保证可用性，必须允许节点独立响应，但可能返回旧数据（牺牲一致性）。</li>
</ul>
</li>
</ul>
<h4 id="cap的常见取舍"><strong>CAP的常见取舍</strong>：</h4>
<table>
  <thead>
      <tr>
          <th style="text-align: left"><strong>选择</strong></th>
          <th style="text-align: left"><strong>典型系统</strong></th>
          <th style="text-align: left"><strong>场景</strong></th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td style="text-align: left"><strong>CP</strong></td>
          <td style="text-align: left">ZooKeeper、etcd</td>
          <td style="text-align: left">金融交易、配置管理（强一致性）</td>
      </tr>
      <tr>
          <td style="text-align: left"><strong>AP</strong></td>
          <td style="text-align: left">Cassandra、Redis</td>
          <td style="text-align: left">社交网络、实时统计（高可用）</td>
      </tr>
      <tr>
          <td style="text-align: left"><strong>CA</strong></td>
          <td style="text-align: left">单机数据库（如MySQL）</td>
          <td style="text-align: left">无分区的单点系统（非分布式）</td>
      </tr>
  </tbody>
</table>
<hr>
<h2 id="设计模式">设计模式</h2>
<h3 id="单例模式">单例模式</h3>
<p>在Java中，单例模式确保一个类只有一个实例，并提供一个全局访问点。以下是几种常见的单例模式实现方式及其适用场景：</p>
<h5 id="1-饿汉式线程安全"><strong>1. 饿汉式（线程安全）</strong></h5>
<p><strong>特点</strong>：类加载时立即初始化实例，简单但可能浪费资源。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">Singleton</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="kd">final</span><span class="w"> </span><span class="n">Singleton</span><span class="w"> </span><span class="n">instance</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Singleton</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="nf">Singleton</span><span class="p">()</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="n">Singleton</span><span class="w"> </span><span class="nf">getInstance</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">instance</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><hr>
<h5 id="2-懒汉式线程不安全--需加锁"><strong>2. 懒汉式（线程不安全 → 需加锁）</strong></h5>
<p><strong>特点</strong>：延迟初始化，需解决多线程安全问题。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">Singleton</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="n">Singleton</span><span class="w"> </span><span class="n">instance</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="nf">Singleton</span><span class="p">()</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="kd">synchronized</span><span class="w"> </span><span class="n">Singleton</span><span class="w"> </span><span class="nf">getInstance</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">instance</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="kc">null</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">instance</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Singleton</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">instance</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><hr>
<h5 id="3-双重检查锁定dcl线程安全"><strong>3. 双重检查锁定（DCL，线程安全）</strong></h5>
<p><strong>特点</strong>：减少同步开销，需用 <code>volatile</code> 防止指令重排序。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">Singleton</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="kd">volatile</span><span class="w"> </span><span class="n">Singleton</span><span class="w"> </span><span class="n">instance</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="nf">Singleton</span><span class="p">()</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="n">Singleton</span><span class="w"> </span><span class="nf">getInstance</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">instance</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="kc">null</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">                </span><span class="c1">// 第一次检查</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="kd">synchronized</span><span class="w"> </span><span class="p">(</span><span class="n">Singleton</span><span class="p">.</span><span class="na">class</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">  </span><span class="c1">// 同步锁</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">instance</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="kc">null</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">         </span><span class="c1">// 第二次检查</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="n">instance</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Singleton</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">instance</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p><strong>关键点</strong>：</p>
<ul>
<li><code>volatile</code> 防止 <code>new Singleton()</code> 的指令重排序。</li>
<li>双重检查减少同步块执行次数。</li>
</ul>
<hr>
<h4 id="单例模式使用场景有哪些呢举个例子">单例模式使用场景有哪些呢？举个例子</h4>
<hr>
<h2 id="大语言模型">大语言模型</h2>
<h3 id="transformer">Transformer</h3>
<h4 id="讲讲transformer模型">讲讲Transformer模型</h4>
<p>注意力计算可表示为：
$$
\text{Attention}(Q, K, V) = \text{softmax}\left(\frac{QK^T}{\sqrt{d_k}}\right)V
$$</p>
<p>What the Single-Head Attention really is?</p>
<p>​		Transformer的第一步是将输入的每一个token通过 embedding 转换成一个高维空间中的嵌入向量 $\overrightarrow {E_i}$。Transformer的目标是将逐步调整 $\overrightarrow {E_i}$ 使得它们不单单编码单个token，还能融入更丰富的上下文含义。就比如一个名词会问前面的词中有没有形容词啊，这样的提问就被编码成了所谓的查询向量 $\overrightarrow {Q_i}$。而前面的词想要回答后面的哪些查询提问，则被编码成了所谓的键向量 $\overrightarrow {K_i}$。所以这个 $\overrightarrow {Q_i}$ 和 $\overrightarrow {K_i}$ 的点积和的大小，就是衡量每个键和每个查询的匹配程度。而前面的一个比如形容词，需要把后面的名词调整到什么程度，就被编码成了所谓的值向量 $\overrightarrow {V_i}$。所以将上面计算出来的每一个查询的匹配程度，通过softmax函数转换成一个概率分布向量，作为权值再乘以值向量 $\overrightarrow {V_i}$，将上面的这个结果进行求和，得到的就是嵌入向量的调整值 $\Delta\overrightarrow { E_i}$，再将调整值加到原始嵌入向量上，便得到一个编码了更丰富的上下文信息的向量 $\overrightarrow {E_i} + \Delta\overrightarrow { E_i}=\overrightarrow {E_i^{\prime}}$。</p>
<ul>
<li>
<p>$\overrightarrow {E_i}$：嵌入向量。初始嵌入向量只编码了该token的含义以及该词的位置信息，和上下文没有关联。（在GPT3中是 $12288$ 维）</p>
</li>
<li>
<p>$Q$：由查询向量 $\overrightarrow {Q_i}$ 组成的查询矩阵。通过使用一个查询投影矩阵 $W_Q$ 乘以嵌入向量 $\overrightarrow {E_i}$ 得到查询向量 $\overrightarrow {Q_i}$。（注意：$\overrightarrow {Q_i}$ 的维度要比 $\overrightarrow {E_i}$ 小的多，例如只有 $128$ 维，所以它会将嵌入向量映射到低维度空间）</p>
</li>
<li>
<p>$K$：由键向量 $\overrightarrow {K_i}$ 组成的键矩阵。通过使用一个键投影矩阵 $W_K$ 乘以嵌入向量 $\overrightarrow {E_i}$ 得到键向量 $\overrightarrow {K_i}$。</p>
</li>
<li>
<p>$d_k$：查询向量 $\overrightarrow {Q_i}$ 和键向量 $\overrightarrow {K_i}$ 的维度。</p>
</li>
<li>
<p>$\text{softmax}()$：将数值向量归一化为一个概率分布向量。</p>
</li>
<li>
<p>$V$：由值向量 $\overrightarrow {V_i}$ 组成的值矩阵。通过使用一个值投影矩阵 $W_V$ 乘以嵌入向量 $\overrightarrow {E_i}$ 得到值向量 $\overrightarrow {V_i}$。</p>
</li>
</ul>
<p><a href="https://huggingface.co/" target="_blank" rel="noopener noreffer ">大模型届的Github网站huggingface</a></p>
<p>通过下一个词如果输出了<stop>结束标记符就停止，或者操作模型输出的最大值maxlength也会停。</p>
<p>大模型返回结果不要用JSON，而是使用XML，返回结果出错概率更低。</p>
<p>知识星球：<em>大模型面试宝典</em>（作为学习指南，而不是像小林coding那种八股）</p>
<p><a href="https://github.com/modelscope/agentscope/tree/main" target="_blank" rel="noopener noreffer ">agentscope</a></p>
<p>agent开发方向项目：</p>
<ol>
<li>智能客服</li>
<li>复现一下openmanus的本地部分</li>
</ol>
<hr>
<h4 id="transformer时间复杂度是多少呢">Transformer时间复杂度是多少呢</h4>
<p>Transformer模型的时间复杂度主要由其核心组件<strong>自注意力机制</strong>和**前馈网络（FFN）**决定。以下是详细分析：</p>
<h5 id="1-自注意力机制的时间复杂度"><strong>1. 自注意力机制的时间复杂度</strong></h5>
<p>自注意力机制的核心是计算查询（<strong>Q</strong>）、键（<strong>K</strong>）、值（<strong>V</strong>）矩阵的交互：</p>
<ul>
<li><strong>输入</strong>：序列长度 n<em>n</em>，每个 token 的维度 d<em>d</em>。</li>
<li><strong>计算步骤</strong>：
<ol>
<li><strong>QKᵀ 矩阵乘法</strong>：计算 Q⋅KT<em>Q</em>⋅<em>K**T</em>，时间复杂度为 O(n2d)<em>O</em>(<em>n</em>2<em>d</em>)。</li>
<li><strong>Softmax 和缩放</strong>：时间复杂度 O(n2)<em>O</em>(<em>n</em>2)，可忽略。</li>
<li><strong>与 V 矩阵乘法</strong>：将注意力权重与 V<em>V</em> 相乘，时间复杂度 O(n2d)<em>O</em>(<em>n</em>2<em>d</em>)。</li>
</ol>
</li>
<li><strong>总时间复杂度</strong>：O(n2d)<em>O</em>(<em>n</em>2<em>d</em>)。</li>
</ul>
<p><strong>多头注意力</strong>（Multi-Head Attention）通过将 d<em>d</em> 拆分为 h<em>h</em> 个头（每个头维度 d/h<em>d</em>/<em>h</em>），但总时间复杂度仍保持 O(n2d)<em>O</em>(<em>n</em>2<em>d</em>)，因为每个头的计算量总和与原单头一致。</p>
<h5 id="2-前馈网络ffn的时间复杂度"><strong>2. 前馈网络（FFN）的时间复杂度</strong></h5>
<ul>
<li><strong>输入</strong>：序列长度 n<em>n</em>，维度 d<em>d</em>。</li>
<li><strong>结构</strong>：两个线性层（通常从 d<em>d</em> 扩展到 4d4<em>d</em> 再压缩回 d<em>d</em>）。</li>
<li><strong>时间复杂度</strong>：O(nd2)<em>O</em>(<em>n**d</em>2)（每个 token 独立计算）。</li>
</ul>
<h5 id="3-整个-transformer-层的复杂度"><strong>3. 整个 Transformer 层的复杂度</strong></h5>
<p>每个 Transformer 层包含 <strong>1 个自注意力 + 1 个 FFN</strong>：</p>
<ul>
<li><strong>单层时间复杂度</strong>：O(n2d+nd2)<em>O</em>(<em>n</em>2<em>d</em>+<em>n**d</em>2)。</li>
<li><strong>L 层模型总复杂度</strong>：O(Ln2d+Lnd2)<em>O</em>(<em>L**n</em>2<em>d</em>+<em>L<strong>n</strong>d</em>2)。</li>
</ul>
<h5 id="4-主导项分析"><strong>4. 主导项分析</strong></h5>
<ul>
<li><strong>当 n≫d*n*≫*d*</strong>（长文本场景）：主导项为 O(Ln2d)<em>O</em>(<em>L**n</em>2<em>d</em>)。</li>
<li><strong>当 d≫n*d*≫*n*</strong>（高维特征场景）：主导项为 O(Lnd2)<em>O</em>(<em>L<strong>n</strong>d</em>2)。</li>
</ul>
<h5 id="5-与其他模型的对比"><strong>5. 与其他模型的对比</strong></h5>
<table>
  <thead>
      <tr>
          <th style="text-align: left">模型</th>
          <th style="text-align: left">时间复杂度</th>
          <th style="text-align: left">并行性</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td style="text-align: left">Transformer</td>
          <td style="text-align: left">O(n2d)<em>O</em>(<em>n</em>2<em>d</em>)</td>
          <td style="text-align: left">完全并行</td>
      </tr>
      <tr>
          <td style="text-align: left">RNN</td>
          <td style="text-align: left">O(nd2)<em>O</em>(<em>n**d</em>2)</td>
          <td style="text-align: left">无法并行</td>
      </tr>
      <tr>
          <td style="text-align: left">CNN</td>
          <td style="text-align: left">O(knd2)<em>O</em>(<em>kn**d</em>2)</td>
          <td style="text-align: left">局部并行</td>
      </tr>
  </tbody>
</table>
<ul>
<li><strong>Transformer 的劣势</strong>：序列长度 n<em>n</em> 的平方增长导致长文本计算代价高。</li>
<li><strong>改进方案</strong>：稀疏注意力（如 Longformer）、分块计算（如 Reformer）等优化方法可降低复杂度至 O(nlog⁡n)<em>O</em>(<em>n</em>log<em>n</em>) 或线性 O(n)<em>O</em>(<em>n</em>)。</li>
</ul>
<h5 id="总结-2"><strong>总结</strong></h5>
<p>Transformer 的时间复杂度为：</p>
<p>O(Ln2d+Lnd2)<em>O</em>(<em>L**n</em>2<em>d</em>+<em>L<strong>n</strong>d</em>2)</p>
<p>实际应用中，长序列（n<em>n</em> 大）时 O(n2d)<em>O</em>(<em>n</em>2<em>d</em>) 是主要瓶颈，而通过模型优化（如稀疏化）可缓解这一问题。</p>
<hr>
<h4 id="transformer的bert有了解过吗">Transformer的BERT有了解过吗</h4>
<p>是的，我对BERT（Bidirectional Encoder Representations from Transformers）非常熟悉。它是基于Transformer架构的预训练模型，由Google在2018年提出，彻底改变了自然语言处理（NLP）领域的多项任务。以下是针对面试可能涉及的BERT核心知识点整理：</p>
<h5 id="1-bert的核心思想"><strong>1. BERT的核心思想</strong></h5>
<ul>
<li><strong>双向上下文建模</strong>：
与传统语言模型（如GPT）不同，BERT通过<strong>Masked Language Model (MLM)</strong> 同时利用左右两侧的上下文信息，从而捕捉更丰富的语义。</li>
<li><strong>Transformer Encoder</strong>：
仅使用Transformer的<strong>Encoder堆叠</strong>（无Decoder），每一层包含自注意力机制和前馈网络。</li>
</ul>
<h5 id="2-关键技术与训练任务"><strong>2. 关键技术与训练任务</strong></h5>
<h6 id="1-masked-language-model-mlm"><strong>(1) Masked Language Model (MLM)</strong></h6>
<ul>
<li><strong>随机遮盖输入词的15%</strong>，模型预测被遮盖的词（如：&ldquo;I [MASK] a student&rdquo; → &ldquo;am&rdquo;）。</li>
<li><strong>改进</strong>：10%替换为随机词，10%保留原词，缓解预训练-微调不一致性。</li>
</ul>
<h6 id="2-next-sentence-prediction-nsp"><strong>(2) Next Sentence Prediction (NSP)</strong></h6>
<ul>
<li><strong>二分类任务</strong>：判断两个句子是否连续（如：&quot;[CLS] Sentence A [SEP] Sentence B [SEP]&quot; → IsNext/NotNext）。</li>
<li><strong>用途</strong>：提升模型理解句子间关系的能力（后续研究如RoBERTa发现NSP可能非必要）。</li>
</ul>
<h5 id="3-模型结构细节"><strong>3. 模型结构细节</strong></h5>
<ul>
<li><strong>输入表示</strong>：
<ul>
<li><code>[CLS]</code>：分类任务的特殊标记（其输出用作聚合表示）。</li>
<li><code>[SEP]</code>：分隔句子对。</li>
<li><strong>Token Embedding + Segment Embedding + Position Embedding</strong>（三嵌入求和）。</li>
</ul>
</li>
<li><strong>层数与参数量</strong>：
<ul>
<li><strong>BERT-base</strong>：12层Transformer，隐藏层维度768，12个头，参数量约110M。</li>
<li><strong>BERT-large</strong>：24层，隐藏层1024，16个头，参数量约340M。</li>
</ul>
</li>
</ul>
<h5 id="4-微调fine-tuning应用"><strong>4. 微调（Fine-tuning）应用</strong></h5>
<ul>
<li><strong>任务适配</strong>：通过添加任务特定输出层，BERT可应用于多种下游任务：
<ul>
<li><strong>文本分类</strong>（如情感分析）：使用<code>[CLS]</code>输出。</li>
<li><strong>序列标注</strong>（如NER）：对每个token的输出分类。</li>
<li><strong>问答任务</strong>（如SQuAD）：预测答案段的起止位置。</li>
<li><strong>句子对任务</strong>（如语义相似度）：联合处理两个句子。</li>
</ul>
</li>
</ul>
<h5 id="5-bert的优缺点"><strong>5. BERT的优缺点</strong></h5>
<h6 id="优点"><strong>优点</strong>：</h6>
<ul>
<li><strong>强大的泛化能力</strong>：预训练捕捉深层语言特征，微调所需数据少。</li>
<li><strong>多任务统一架构</strong>：同一模型可处理分类、标注、生成等任务（需调整输出层）。</li>
</ul>
<h6 id="缺点"><strong>缺点</strong>：</h6>
<ul>
<li><strong>计算资源消耗大</strong>：预训练需要大规模GPU/TPU集群。</li>
<li><strong>长文本处理受限</strong>：因自注意力的O(n2)<em>O</em>(<em>n</em>2)复杂度，序列长度通常限制为512。</li>
<li><strong>生成能力弱</strong>：无Decoder，不擅长文本生成（需结合GPT或Seq2Seq结构）。</li>
</ul>
<h5 id="6-常见面试问题与回答思路"><strong>6. 常见面试问题与回答思路</strong></h5>
<h6 id="q1-bert为什么比gpt效果好"><strong>Q1: BERT为什么比GPT效果好？</strong></h6>
<ul>
<li><strong>关键点</strong>：GPT是单向（从左到右）的生成模型，而BERT通过双向上下文捕捉更全面的语义信息。</li>
<li><strong>举例</strong>：在预测&quot;bank&quot;时，BERT能同时利用&quot;river&quot;和&quot;money&quot;的上下文，而GPT仅能看到左侧信息。</li>
</ul>
<h6 id="q2-bert的参数量如何估算"><strong>Q2: BERT的参数量如何估算？</strong></h6>
<ul>
<li><strong>公式</strong>：参数量 ≈ L×(12d2+13d)<em>L</em>×(12<em>d</em>2+13<em>d</em>)（L为层数，d为隐藏层维度）。</li>
<li><strong>BERT-base示例</strong>：12层 × (12×768² + 13×768) ≈ 110M。</li>
</ul>
<h6 id="q3-如何优化bert的长文本处理"><strong>Q3: 如何优化BERT的长文本处理？</strong></h6>
<ul>
<li><strong>回答方向</strong>：
<ol>
<li><strong>稀疏注意力</strong>（如Longformer的滑动窗口注意力）。</li>
<li><strong>分块+池化</strong>（如将文本分段后聚合表示）。</li>
<li><strong>层次化建模</strong>（如先处理句子再处理文档）。</li>
</ol>
</li>
</ul>
<h5 id="7-扩展bert的变体模型"><strong>7. 扩展：BERT的变体模型</strong></h5>
<ul>
<li><strong>RoBERTa</strong>：移除NSP，更大批次/更多数据训练。</li>
<li><strong>ALBERT</strong>：参数共享与嵌入分解，降低内存占用。</li>
<li><strong>DistilBERT</strong>：知识蒸馏压缩模型。</li>
<li><strong>ELECTRA</strong>：用生成器-判别器架构替代MLM，提升训练效率。</li>
</ul>
<hr>
<h4 id="bert与gpt核心区别总结">BERT与GPT核心区别总结</h4>
<h5 id="一架构设计">‌<strong>一、架构设计</strong>‌</h5>
<ul>
<li>‌<strong>BERT</strong>‌
<ul>
<li>基于Transformer的‌<strong>Encoder-only架构</strong>‌，强调双向上下文理解35</li>
<li>输入支持句子对（如问答对），通过双向注意力机制捕捉全局语义18</li>
</ul>
</li>
<li>‌<strong>GPT</strong>‌
<ul>
<li>基于Transformer的‌<strong>Decoder-only架构</strong>‌，采用单向自回归生成模式34</li>
<li>仅依赖已生成的上文预测下一个词，无法获取未来词的上下文信息58</li>
</ul>
</li>
</ul>
<h5 id="二训练机制">‌<strong>二、训练机制</strong>‌</h5>
<table>
  <thead>
      <tr>
          <th>模型</th>
          <th>预训练任务</th>
          <th>训练目标</th>
          <th>特点</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>BERT</td>
          <td>掩码语言模型（MLM）+ 下一句预测（NSP）37</td>
          <td>预测被遮蔽词及判断句子间连续性68</td>
          <td>通过双向训练全面学习语义关系56</td>
      </tr>
      <tr>
          <td>GPT</td>
          <td>自回归语言模型</td>
          <td>最大化下一个词的概率36</td>
          <td>单向生成导致上下文理解受限48</td>
      </tr>
  </tbody>
</table>
<h5 id="三应用场景">‌<strong>三、应用场景</strong>‌</h5>
<ul>
<li>‌<strong>BERT适用领域</strong>‌
<ul>
<li>‌<strong>文本理解类任务</strong>‌：情感分析、命名实体识别、语义匹配15</li>
<li>需捕捉双向上下文语义的场景（如问答系统）67</li>
</ul>
</li>
<li>‌<strong>GPT适用领域</strong>‌
<ul>
<li>‌<strong>文本生成类任务</strong>‌：对话系统、文本补全、机器翻译56</li>
<li>强调生成连贯性而非深度理解的场景（如故事创作）18</li>
</ul>
</li>
</ul>
<h5 id="四上下文处理能力">‌<strong>四、上下文处理能力</strong>‌</h5>
<ul>
<li>‌<strong>BERT</strong>‌：双向建模使其能同时分析前后文关联，对复杂语义关系（如反讽、指代）捕捉更强37</li>
<li>‌<strong>GPT</strong>‌：单向生成模式限制了上下文理解，但生成连贯性优于双向模型56</li>
</ul>
<h5 id="五模型输出">‌<strong>五、模型输出</strong>‌</h5>
<ul>
<li>‌<strong>BERT</strong>‌：输出上下文相关的词向量，需微调适配下游任务16</li>
<li>‌<strong>GPT</strong>‌：直接输出生成文本序列，适用于端到端的生成式应用38</li>
</ul>
<h5 id="典型应用对比示例">典型应用对比示例</h5>
<table>
  <thead>
      <tr>
          <th>任务类型</th>
          <th>BERT优势场景</th>
          <th>GPT优势场景</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>文本分类</td>
          <td>✔️（情感极性分析）5</td>
          <td>-</td>
      </tr>
      <tr>
          <td>文本生成</td>
          <td>-</td>
          <td>✔️（自动摘要生成）6</td>
      </tr>
      <tr>
          <td>问答系统</td>
          <td>✔️（答案抽取型任务）7</td>
          <td>✔️（开放域对话型任务）8</td>
      </tr>
  </tbody>
</table>
<h5 id="核心结论">核心结论</h5>
<ul>
<li>‌<strong>BERT更适合需要深度语义理解的任务</strong>‌，通过双向编码获取全局信息78</li>
<li>‌<strong>GPT更擅长生成连贯文本</strong>‌，但需权衡其上下文理解局限性56</li>
<li>实际应用中，两者常结合使用（如BERT生成特征输入GPT）以平衡理解与生成能力</li>
</ul>
<hr>
<h3 id="rag">RAG</h3>
<p>
<figure><a class="lightgallery" href="https://img-blog.csdnimg.cn/img_convert/b41fff7a375b5d4a98f9bc9a5742546b.png" title="b41fff7a375b5d4a98f9bc9a5742546b.png (854×479)" data-thumbnail="https://img-blog.csdnimg.cn/img_convert/b41fff7a375b5d4a98f9bc9a5742546b.png" data-sub-html="<h2> </h2><p>b41fff7a375b5d4a98f9bc9a5742546b.png (854×479)</p>">
        <img
            class="lazyload"
            src="/svg/loading.min.svg"
            data-src="https://img-blog.csdnimg.cn/img_convert/b41fff7a375b5d4a98f9bc9a5742546b.png"
            data-srcset="https://img-blog.csdnimg.cn/img_convert/b41fff7a375b5d4a98f9bc9a5742546b.png, https://img-blog.csdnimg.cn/img_convert/b41fff7a375b5d4a98f9bc9a5742546b.png 1.5x, https://img-blog.csdnimg.cn/img_convert/b41fff7a375b5d4a98f9bc9a5742546b.png 2x"
            data-sizes="auto"
            alt="https://img-blog.csdnimg.cn/img_convert/b41fff7a375b5d4a98f9bc9a5742546b.png" />
    </a><figcaption class="image-caption">b41fff7a375b5d4a98f9bc9a5742546b.png (854×479)</figcaption>
    </figure></p>
<h2 id="思维题">思维题</h2>
<h3 id="赛马题">赛马题</h3>
<h2 id="面试反问">面试反问</h2>
<h3 id="前述">前述</h3>
<p>针对自己在秋招的面试中，根据自己面试情况中，在后面的面试复盘中，针对于面试官要求最后的反问环节的一些注意细节，从反问的角度对于下面问题：</p>
<ul>
<li>我们应该如何进行提问？</li>
<li>应该分别针对不同阶段的面试提问哪些内容？</li>
<li>提问上应该抱有那些心态？</li>
<li>……</li>
</ul>
<p>自己从每次面试，这里做一次简单的总结分享一下，希望能帮助到各位同学。</p>
<h3 id="一面纯技术面">一面：纯技术面</h3>
<h4 id="目的">目的</h4>
<p>对于技术面来说，一面主要是进行基础的技术面，涉及到你对该方向的基础知识的掌握程度。比如软开：会涉及到对于</p>
<ul>
<li>计算机的基础知识的掌握情况：让你说说操作系统，网络方面的知识等；</li>
<li>编程能力的熟悉程度：相应手撕几道编程题目；</li>
<li>编程语言的理解程度：比如对于你所熟悉的编程语言，如<code>CPP</code>或者 <code>jave</code>会让你说一些这些语言底层的机制是如何如何等等问题。</li>
</ul>
<h4 id="反问">反问</h4>
<p>技术层面上反问：</p>
<ul>
<li>比如刚刚面试中有遇到自己不太清楚的问题，或者答的不太好的问题点，自己可以问下：<strong>您刚才问的xxx问题，我想问下您的思路？</strong></li>
<li>比如自己和面试的部门的匹配程度：部门的主营业务和使用的技术栈都是哪些（组里面进去的新人一般做哪些任务）？岗位主要负责的业务？</li>
<li>当前部门的一个大概分工方向？部门主要的架构？</li>
</ul>
<p>能力层面上的反问：</p>
<ul>
<li><strong>就我的这次面试，您觉得我的能力有哪些地方（比如技术上或者语言表达能力上）需要提升？</strong></li>
<li>面试一般多久会通知结果？</li>
</ul>
<h3 id="二面技术综合面主管面">二面：技术综合面/主管面</h3>
<h4 id="目的-1">目的</h4>
<p>二面一般是一个部门的小领导或者一个主管来进行面试的（大部分情况是这样的），等顺利进入改公司的时候，也大概率是你的领导或者小组长之类的。二面的出发点，表明你的一面技术基础面是<code>OK</code>的，至少对于该公司来说是基本够用。</p>
<p>二面综合面，会相应对的技术综合实力来进行考量的，</p>
<ul>
<li>一搬会根据你的项目经历，结合你的技术来深入项目细节展开交流，所以你一定得对的项目所涉及的知识网非常熟悉方可。</li>
<li>同时，会结合你的项目，穿插一些情景类的技术问题，让你说一下自己的解决思路和想法。我认为这也是一个和面试官进行交互想法的过程，不懂的也可以问，互相讨论感觉效果更好（不乏有的面试官总向咄咄逼人😅）</li>
</ul>
<h4 id="反问-1">反问</h4>
<p>从综合层面上的反问：</p>
<ul>
<li>面试的候选人，特别是对于我们这样的校招生，企业一般最看重什么？</li>
<li>您对进入您团队的成员的要求是什么？或者说，我们需要具备哪些能力才能胜任这个岗位？</li>
<li>团队工作氛围？</li>
</ul>
<h3 id="三面hr面">三面：<code>HR</code>面</h3>
<h4 id="目的-2">目的</h4>
<p>如果能顺利进入<code>HR</code>面，也意味着你是较大可能的能顺利拿到该家公司的<code>offer</code>了👏。</p>
<p><code>HR</code>也仅仅是考一下的个人软能力方面的问题。</p>
<h4 id="反问-2">反问</h4>
<ul>
<li>公司对新人的培养模式是什么样的？</li>
<li>公司氛围？</li>
<li>一般情况大概多久可以出结果？（这时候，应该去想<code>HR</code>确认最终什么时候出结果，后续的还有那些流程等）8</li>
</ul>
</div><div class="post-footer" id="post-footer">
    <div class="post-info">
        <div class="post-info-line">
            <div class="post-info-mod">
                <span>更新于 2026-01-26&nbsp;<a class="git-hash" href="https://github.com/ThisingL/thisingl.github.io/commit/70a05e59510053fb2c9c156466c18e2a4bcf5814" target="_blank" title="commit by JarVis(2055543978@qq.com) 70a05e59510053fb2c9c156466c18e2a4bcf5814: docs: update posts/">
                                    <i class="fas fa-hashtag fa-fw" aria-hidden="true"></i>70a05e5</a></span>
            </div></div>
        <div class="post-info-line">
            <div class="post-info-md"></div>
            <div class="post-info-share">
                <span><a href="javascript:void(0);" title="分享到 Twitter" data-sharer="twitter" data-url="https://example.com/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%9D%A2%E7%BB%8F/" data-title="程序员面试面经" data-hashtags="编程"><i class="fab fa-twitter fa-fw" aria-hidden="true"></i></a><a href="javascript:void(0);" title="分享到 Facebook" data-sharer="facebook" data-url="https://example.com/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%9D%A2%E7%BB%8F/" data-hashtag="编程"><i class="fab fa-facebook-square fa-fw" aria-hidden="true"></i></a><a href="javascript:void(0);" title="分享到 Hacker News" data-sharer="hackernews" data-url="https://example.com/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%9D%A2%E7%BB%8F/" data-title="程序员面试面经"><i class="fab fa-hacker-news fa-fw" aria-hidden="true"></i></a><a href="javascript:void(0);" title="分享到 Line" data-sharer="line" data-url="https://example.com/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%9D%A2%E7%BB%8F/" data-title="程序员面试面经"><i data-svg-src="https://cdn.jsdelivr.net/npm/simple-icons@7.3.0/icons/line.svg" aria-hidden="true"></i></a><a href="javascript:void(0);" title="分享到 微博" data-sharer="weibo" data-url="https://example.com/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%9D%A2%E7%BB%8F/" data-title="程序员面试面经"><i class="fab fa-weibo fa-fw" aria-hidden="true"></i></a></span>
            </div>
        </div>
    </div>

    <div class="post-info-more">
        <section class="post-tags"><i class="fas fa-tags fa-fw" aria-hidden="true"></i>&nbsp;<a href="/tags/%E7%BC%96%E7%A8%8B/">编程</a></section>
        <section>
            <span><a href="javascript:void(0);" onclick="window.history.back();">返回</a></span>&nbsp;|&nbsp;<span><a href="/">主页</a></span>
        </section>
    </div>

    <div class="post-nav"><a href="/%E5%BC%80%E5%8F%91%E6%9C%BA%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE/" class="prev" rel="prev" title="开发机常用配置"><i class="fas fa-angle-left fa-fw" aria-hidden="true"></i>开发机常用配置</a></div>
</div>
<div id="comments"><div id="valine" class="comment"></div><noscript>
                Please enable JavaScript to view the comments powered by <a href="https://valine.js.org/">Valine</a>.
            </noscript></div></article></div>
            </main><footer class="footer">
        <div class="footer-container">
            <div class="footer-line">
                <span id="run-time"></span>
            </div>

            <div class="footer-line" itemscope itemtype="http://schema.org/CreativeWork"><i class="far fa-copyright fa-fw" aria-hidden="true"></i><span itemprop="copyrightYear">2024 - 2026</span>&nbsp;|&nbsp;<span class="license"><a rel="license external nofollow noopener noreffer" href="https://creativecommons.org/licenses/by-nc/4.0/" target="_blank">CC BY-NC 4.0</a></span></div>
    
        
        <script async src=" //busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js "></script>
    

    
        
            <section>
                
                    <span id="busuanzi_container_value_site_pv"><i class="far fa-eye fa-fw"></i>
                        
                        <span id="busuanzi_value_site_pv"></span>
                    </span>
                

                
                    &nbsp;|&nbsp;              
                

                
                    <span id="busuanzi_container_value_site_uv"><i class="fa fa-user"></i>
                        
                        <span id="busuanzi_value_site_uv"></span>
                    </span>
                
            </section>
        

        
        
    

</div>
    </footer></div>

        <div id="fixed-buttons"><a href="#" id="back-to-top" class="fixed-button" title="回到顶部">
                <i class="fas fa-arrow-up fa-fw" aria-hidden="true"></i>
            </a><a href="#" id="view-comments" class="fixed-button" title="查看评论">
                <i class="fas fa-comment fa-fw" aria-hidden="true"></i>
            </a>
        </div><link rel="stylesheet" href="/lib/valine/valine.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@2.5.0/css/lightgallery-bundle.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.css"><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/valine@1.5.3/dist/Valine.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/autocomplete.js@0.38.1/dist/autocomplete.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lunr@2.3.9/lunr.min.js"></script><script type="text/javascript" src="/lib/lunr/lunr.stemmer.support.min.js"></script><script type="text/javascript" src="/lib/lunr/lunr.zh.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lazysizes@5.3.2/lazysizes.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lightgallery@2.5.0/lightgallery.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lightgallery@2.5.0/plugins/thumbnail/lg-thumbnail.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lightgallery@2.5.0/plugins/zoom/lg-zoom.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/clipboard@2.0.11/dist/clipboard.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/sharer.js@0.5.1/sharer.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/contrib/auto-render.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/contrib/copy-tex.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/contrib/mhchem.min.js"></script><script type="text/javascript">window.config={"code":{"copyTitle":"复制到剪贴板","maxShownLines":50},"comment":{"valine":{"appId":"QGzwQXOqs5JOhN4RGPOkR2mR-MdYXbMMI","appKey":"WBmoGyJtbqUswvfLh6L8iEBr","avatar":"mp","el":"#valine","emojiCDN":"https://cdn.jsdelivr.net/npm/emoji-datasource-google@15.1.2/img/google/64/","emojiMaps":{"100":"1f4af.png","alien":"1f47d.png","anger":"1f4a2.png","angry":"1f620.png","anguished":"1f627.png","astonished":"1f632.png","black_heart":"1f5a4.png","blue_heart":"1f499.png","blush":"1f60a.png","bomb":"1f4a3.png","boom":"1f4a5.png","broken_heart":"1f494.png","brown_heart":"1f90e.png","clown_face":"1f921.png","cold_face":"1f976.png","cold_sweat":"1f630.png","confounded":"1f616.png","confused":"1f615.png","cry":"1f622.png","crying_cat_face":"1f63f.png","cupid":"1f498.png","dash":"1f4a8.png","disappointed":"1f61e.png","disappointed_relieved":"1f625.png","dizzy":"1f4ab.png","dizzy_face":"1f635.png","drooling_face":"1f924.png","exploding_head":"1f92f.png","expressionless":"1f611.png","face_vomiting":"1f92e.png","face_with_cowboy_hat":"1f920.png","face_with_hand_over_mouth":"1f92d.png","face_with_head_bandage":"1f915.png","face_with_monocle":"1f9d0.png","face_with_raised_eyebrow":"1f928.png","face_with_rolling_eyes":"1f644.png","face_with_symbols_on_mouth":"1f92c.png","face_with_thermometer":"1f912.png","fearful":"1f628.png","flushed":"1f633.png","frowning":"1f626.png","ghost":"1f47b.png","gift_heart":"1f49d.png","green_heart":"1f49a.png","grimacing":"1f62c.png","grin":"1f601.png","grinning":"1f600.png","hankey":"1f4a9.png","hear_no_evil":"1f649.png","heart":"2764-fe0f.png","heart_decoration":"1f49f.png","heart_eyes":"1f60d.png","heart_eyes_cat":"1f63b.png","heartbeat":"1f493.png","heartpulse":"1f497.png","heavy_heart_exclamation_mark_ornament":"2763-fe0f.png","hole":"1f573-fe0f.png","hot_face":"1f975.png","hugging_face":"1f917.png","hushed":"1f62f.png","imp":"1f47f.png","innocent":"1f607.png","japanese_goblin":"1f47a.png","japanese_ogre":"1f479.png","joy":"1f602.png","joy_cat":"1f639.png","kiss":"1f48b.png","kissing":"1f617.png","kissing_cat":"1f63d.png","kissing_closed_eyes":"1f61a.png","kissing_heart":"1f618.png","kissing_smiling_eyes":"1f619.png","laughing":"1f606.png","left_speech_bubble":"1f5e8-fe0f.png","love_letter":"1f48c.png","lying_face":"1f925.png","mask":"1f637.png","money_mouth_face":"1f911.png","nauseated_face":"1f922.png","nerd_face":"1f913.png","neutral_face":"1f610.png","no_mouth":"1f636.png","open_mouth":"1f62e.png","orange_heart":"1f9e1.png","partying_face":"1f973.png","pensive":"1f614.png","persevere":"1f623.png","pleading_face":"1f97a.png","pouting_cat":"1f63e.png","purple_heart":"1f49c.png","rage":"1f621.png","relaxed":"263a-fe0f.png","relieved":"1f60c.png","revolving_hearts":"1f49e.png","right_anger_bubble":"1f5ef-fe0f.png","robot_face":"1f916.png","rolling_on_the_floor_laughing":"1f923.png","scream":"1f631.png","scream_cat":"1f640.png","see_no_evil":"1f648.png","shushing_face":"1f92b.png","skull":"1f480.png","skull_and_crossbones":"2620-fe0f.png","sleeping":"1f634.png","sleepy":"1f62a.png","slightly_frowning_face":"1f641.png","slightly_smiling_face":"1f642.png","smile":"1f604.png","smile_cat":"1f638.png","smiley":"1f603.png","smiley_cat":"1f63a.png","smiling_face_with_3_hearts":"1f970.png","smiling_imp":"1f608.png","smirk":"1f60f.png","smirk_cat":"1f63c.png","sneezing_face":"1f927.png","sob":"1f62d.png","space_invader":"1f47e.png","sparkling_heart":"1f496.png","speak_no_evil":"1f64a.png","speech_balloon":"1f4ac.png","star-struck":"1f929.png","stuck_out_tongue":"1f61b.png","stuck_out_tongue_closed_eyes":"1f61d.png","stuck_out_tongue_winking_eye":"1f61c.png","sunglasses":"1f60e.png","sweat":"1f613.png","sweat_drops":"1f4a6.png","sweat_smile":"1f605.png","thinking_face":"1f914.png","thought_balloon":"1f4ad.png","tired_face":"1f62b.png","triumph":"1f624.png","two_hearts":"1f495.png","unamused":"1f612.png","upside_down_face":"1f643.png","weary":"1f629.png","white_frowning_face":"2639-fe0f.png","white_heart":"1f90d.png","wink":"1f609.png","woozy_face":"1f974.png","worried":"1f61f.png","yawning_face":"1f971.png","yellow_heart":"1f49b.png","yum":"1f60b.png","zany_face":"1f92a.png","zipper_mouth_face":"1f910.png","zzz":"1f4a4.png"},"enableQQ":false,"highlight":true,"lang":"zh-CN","pageSize":10,"placeholder":"你的评论 ...","recordIP":true,"serverURLs":"https://valine.hugoloveit.com","visitor":false}},"lightgallery":true,"math":{"delimiters":[{"display":true,"left":"$$","right":"$$"},{"display":true,"left":"\\[","right":"\\]"},{"display":true,"left":"\\begin{equation}","right":"\\end{equation}"},{"display":true,"left":"\\begin{equation*}","right":"\\end{equation*}"},{"display":true,"left":"\\begin{align}","right":"\\end{align}"},{"display":true,"left":"\\begin{align*}","right":"\\end{align*}"},{"display":true,"left":"\\begin{alignat}","right":"\\end{alignat}"},{"display":true,"left":"\\begin{alignat*}","right":"\\end{alignat*}"},{"display":true,"left":"\\begin{gather}","right":"\\end{gather}"},{"display":true,"left":"\\begin{CD}","right":"\\end{CD}"},{"display":false,"left":"$","right":"$"},{"display":false,"left":"\\(","right":"\\)"}],"strict":false},"search":{"highlightTag":"em","lunrIndexURL":"/index.json","lunrLanguageCode":"zh","lunrSegmentitURL":"/lib/lunr/lunr.segmentit.js","maxResultLength":10,"noResultsFound":"没有找到结果","snippetLength":50,"type":"lunr"}};</script><script type="text/javascript" src="/js/theme.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/jquery@2.1.3/dist/jquery.min.js"></script>
<script type="text/javascript" src="/js/custom.js"></script></body>
</html>
